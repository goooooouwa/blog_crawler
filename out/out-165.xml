<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0">
<channel>
<title>Coding Horror</title>
<description>programming and human factors</description>
<link>https://blog.codinghorror.com/</link>
<pubDate>Sun, 19 Apr 2020 00:00:01 GMT</pubDate>
<!-- other elements omitted from this example -->
<item>
<title>Compiled or Bust?</title>
<link>https://blog.codinghorror.com/compiled-or-bust/</link>
<content>
                <!--kg-card-begin: markdown--><p>
While I may have <a href="http://www.codinghorror.com/blog/2009/06/all-abstractions-are-failed-abstractions.html">mixed emotions toward LINQ to SQL</a>, we've had great success with it on Stack Overflow. That's why I was <a href="http://weblogs.asp.net/omarzabir/archive/2008/10/28/solving-common-problems-with-compiled-queries-in-linq-to-sql-for-high-demand-asp-net-websites.aspx">surprised to read the following</a>:
</p>
<p>
</p>
<blockquote>
If you are building an ASP.NET web application that's going to get thousands of hits per hour, the execution overhead of Linq queries is going to consume too much CPU and make your site slow. Thereâ€™s a runtime cost associated with each and every Linq Query you write. The queries are parsed and converted to a nice SQL Statement on <i>every</i> hit. Itâ€™s not done at compile time because thereâ€™s no way to figure out what you might be sending as the parameters in the queries during runtime.
<p>
So, if you have common Linq to Sql statements like the following one ..
</p>
<p>
</p>
<pre>
var query = from widget in dc.Widgets
where widget.ID == id &amp;&amp; widget.PageID == pageId
select widget;
var widget = query.SingleOrDefault();
</pre>
<p>
..  throughout your growing web application, you are soon going to have scalability nightmares.
</p>
</blockquote>
<p>
J.D. Conley <a href="http://www.jdconley.com/blog/archive/2007/11/28/linq-to-sql-surprise-performance-hit.aspx">goes further</a>:
</p>
<p>
</p>
<blockquote>
So I dug into the call graph a bit and found out the code causing by far the most damage was the creation of the LINQ query object for every call! The actual round trip to the database paled in comparison.
</blockquote>
<p>
I must admit, these results seem ... unbelievable. Querying the database is so slow (relative to typical code execution) that if you have to ask how long it will take, <i>you can't afford it</i>. I have a very hard time accepting the idea that <b>dynamically parsing a Linq query would take longer than round-tripping to the database.</b> Pretend I'm from Missouri: show me. Because I am unconvinced.
</p>
<p>
All of this is very curious, because Stack Overflow uses naive, uncompiled Linq queries on every page, and we are a top 1,000 website on the public internet by most accounts these days. We get a considerable amount of traffic; the last time I checked it was about 1.5 million pageviews per day. We go to great pains to make sure everything is as fast as we can. We're not as fast as we'd like to be yet, but I think we're doing a reasonable job so far. The journey is still very much underway -- we realize that <a href="http://www.codinghorror.com/blog/2009/01/overnight-success-it-takes-years.html">overnight success takes years</a>.
</p>
<p>
Anyway, <b>Stack Overflow has dozens to hundreds of plain vanilla uncompiled Linq to SQL queries on every page</b>. What we <i>don't</i> have is "scalability nightmares". CPU usage has been one of our least relevant constraints over the last two years as the site has grown. We've also heard from other development teams, multiple times, that Linq to SQL is "slow". But we've never been able to reproduce this even when armed with a profiler.
</p>
<p>
Quite the mystery.
</p>
<p>
Now, it's absolutely true that Linq to SQL has the performance peculiarity both posters are describing. We know that's true because <a href="http://blogs.msdn.com/ricom/archive/2008/01/14/performance-quiz-13-linq-to-sql-compiled-query-cost-solution.aspx">Rico tells us so</a>, and Rico ... well, Rico's <i>the man</i>.
</p>
<p>
</p>
<blockquote>
In short the problem is that <b>the basic Linq construction (we donâ€™t really have to reach for a complex query to illustrate) results in repeated evaluations of the query if you ran the query more than once.</b>
<p>
Each execution builds the expression tree, and then builds the required SQL. In many cases all that will be different from one invocation to another is a single integer filtering parameter. Furthermore, any databinding code that we must emit via lightweight reflection will have to be jitted each time the query runs. Implicit caching of these objects seems problematic because we could never know what good policy is for such a cache -- only the user has the necessary knowledge.
</p>
</blockquote>
<p>
It's fascinating stuff; you should <a href="http://blogs.msdn.com/ricom/archive/2007/06/22/dlinq-linq-to-sql-performance-part-1.aspx">read the whole series</a>.
</p>
<p>
What's unfortunate about Linq in this scenario is that you're intentionally sacrificing something that any <a href="http://www.yafla.com/dforbes/Getting_Real_about_NoSQL_and_the_SQL_Isnt_Scalable_Lie/">old and busted SQL database</a> gives you for free. When you send a garden variety parameterized SQL query through to a traditional SQL database, it's hashed, then matched against existing cached query plans. The computational cost of pre-processing a given query is only paid the first time the database sees the new query. All subsequent runs of that same query use the cached query plan and skip the query evaluation. Not so in Linq to SQL. As Rico said, <b>every single run of the Linq query is fully parsed every time it happens</b>.
</p>
<p>
Now, there <i>is</i> a way to compile your Linq queries, but I personally find the syntax kind of ... ugly and contorted. You tell me:
</p>
<p>
</p>
<pre>
Func&lt;Northwinds, IQueryable&lt;Orders&gt;, int&gt; q =
CompiledQuery.Compile&lt;Northwinds, int, IQueryable&lt;Orders&gt;&gt;
((Northwinds nw, int orderid) =&gt;
from o in nw.Orders
where o.OrderId == orderid
select o );
Northwinds nw = new Northwinds(conn);
foreach (Orders o in q(nw, orderid))
{
}
</pre>
<p>
Anyway, that's neither here nor there; we can confirm the performance penalty of failing to compile our queries ourselves. We recently wrote a one time conversion job against a simple 3 column table containing about 500,000 records. The meat of it looked like this:
</p>
<p>
</p>
<pre>
db.PostTags.Where(t =&gt; t.PostId == this.Id).ToList();
</pre>
<p>
Then we compared it with the SQL variant; note that this is also being auto-cast down to the handy <code>PostTag</code> object as well, so the only difference is whether or not the query itself is SQL.
</p>
<p>
</p>
<pre>
db.ExecuteQuery<posttag>(
"select * from PostTags where PostId={0}", this.Id).ToList();
</posttag></pre>
<p>
On an Intel Core 2 Quad running at 2.83 GHz, the former took <b>422 seconds</b> while the latter took <b>275 seconds</b>.
</p>
<p>
The penalty for failing to compile this query, across 500k iterations, was 147 seconds. Wow! That's 1.5 times slower! Man, only a <i>BASIC programmer</i> would be dumb enough to skip compiling all their Linq queries. But wait a second, no, wait 147 seconds. Let's do the math, even though I suck at it. Each uncompiled run of the query took less than <b><i>one third of a millisecond</i></b> longer.
</p>
<p>
At first I was worried that every Stack Overflow page was 1.5 times slower than it should be. But then I realized it's probably more realistic to make sure that any page we generate isn't doing <b>500 freakin' thousand queries!</b>  Have we found ourselves in <a href="http://www.codinghorror.com/blog/2009/01/the-sad-tragedy-of-micro-optimization-theater.html">the sad tragedy of micro-optimization theater</a> ... again? I think we might have. Now I'm just depressed.
</p>
<p>
While it's arguably correct to say that every compiled Linq query (or for that matter, any compiled anything) will be faster, your decisions should be a bit more nuanced than <b>compiled or bust</b>. How much benefit you get out of compilation depends how many times you're doing it. Rico would be the first to point this out, and in fact <a href="http://blogs.msdn.com/ricom/archive/2008/01/14/performance-quiz-13-linq-to-sql-compiled-query-cost-solution.aspx">he already has</a>:
</p>
<p>
</p>
<pre>
Testing 1 batches of 5000 selects
<p>
uncompiled  543.48 selects/sec
compiled    925.75 selects/sec
</p><p>
Testing 5000 batches of 1 selects
</p><p>
uncompiled  546.03 selects/sec
compiled    461.89 selects/sec
</p></pre>
<p>
Have I mentioned that Rico is the man? Do you see the inversion here? Either you're doing 1 batch of 5000 queries, or 5000 batches of 1 query. One is dramatically faster when compiled; the other is actually a big honking net negative if you consider the developer time spent converting all those beautifully, wonderfully simple Linq queries to the contorted syntax necessary for compilation. Not to mention the implied code maintenance.
</p>
<p>
I'm a big fan of compiled languages. Even Facebook will tell you that <a href="http://developers.facebook.com/news.php?story=358&amp;blog=1">PHP is about as half as fast as it should be</a> on a good day with a tailwind. But compilation alone is not the entire performance story. Not even close. If you're compiling something -- whether it's PHP, a regular expression, or a Linq query, don't expect <a href="http://en.wikipedia.org/wiki/No_Silver_Bullet">a silver bullet</a>, or you may end up disappointed.
</p>
<p>
</p>
<p>
<!--kg-card-end: markdown-->
            </p></content>
<pubDate>2010-03-19T04:56:46.000Z</pubDate>
<guid>https://blog.codinghorror.com/compiled-or-bust/</guid>
</item>
</channel>
</rss>
