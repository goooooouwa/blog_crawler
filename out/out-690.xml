<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0">
<channel>
<title>Coding Horror</title>
<description>programming and human factors</description>
<link>https://blog.codinghorror.com/</link>
<pubDate>Sun, 19 Apr 2020 00:00:01 GMT</pubDate>
<!-- other elements omitted from this example -->
<item>
<title>The Problem With C++</title>
<link>https://blog.codinghorror.com/the-problem-with-c/</link>
<content>
                <!--kg-card-begin: markdown--><p>
MIT's Technology Review recently interviewed <a href="http://en.wikipedia.org/wiki/Bjarne_Stroustrup">Bjarne Stroustrup</a> in a two-part article (<a href="http://www.technologyreview.com/InfoTech/17831/">part one</a>, <a href="http://www.technologyreview.com/Infotech/17868/">part two</a>). You may know Bjarne as the inventor of the <a href="http://en.wikipedia.org/wiki/C++">C++ programming language</a>. Indeed, he even maintains a <a href="http://www.research.att.com/~bs/bs_faq.html">comprehensive C++ FAQ</a> that answers every imaginable C++ question.
</p>
<p>
Here are a few select quotes from the interview that I found notable:
</p>
<p>
</p>
<blockquote>
C++ has indeed become too "expert friendly" at a time where the degree of effective formal education of the average software developer has declined. However, the solution is not to dumb down the programming languages but to use a variety of programming languages and educate more experts. There has to be languages for those experts to use-- and C++ is one of those languages.
<p>
What I did do was to design C++ as first of all a systems programming language: I wanted to be able to write device drivers, embedded systems, and other code that needed to use hardware directly. Next, I wanted C++ to be a good language for designing tools. That required flexibility and performance, but also the ability to express elegant interfaces. My view was that to do higher-level stuff, to build complete applications, you first needed to buy, build, or borrow libraries providing appropriate abstractions. Often, when people have trouble with C++, the real problem is that they don't have appropriate libraries--or that they can't find the libraries that are available.
</p>
<p>
Other languages have tried to more directly support high-level applications. That works, but often that support comes at the cost of specialization. Personally, I wouldn't design a tool that could do only what I wanted--I aim for generality.
</p>
<p>
I think [making computer languages easier for average people] would be misguided. The idea of programming as a semiskilled task, practiced by people with a few months' training, is dangerous. We wouldn't tolerate plumbers or accountants that poorly educated. We don't have as an aim that architecture (of buildings) and engineering (of bridges and trains) should become more accessible to people with progressively less training. Indeed, one serious problem is that currently, too <i>many</i> software developers are undereducated and undertrained.
</p>
</blockquote>
<p>
In the <a href="http://www.research.att.com/~bs/bs_faq.html">FAQ</a> and the <a href="http://www.technologyreview.com/InfoTech/17831/">interview</a>, <b>Bjarne comes off as a little defensive about C++</b> and its role in <a href="http://www.codinghorror.com/blog/archives/000686.html">the history of computer languages</a>. Maybe that's because the importance of C++ has diminished over time, principally for two reasons:
</p>
<p>
</p>
<ol>
<li>
<b>C++ is fast but unforgiving.</b> It was an appropriate solution for an era of limited computing resources. But we've long since left that behind; we live in an <a href="http://longtail.typepad.com/the_long_tail/2005/03/the_tragically_.html">era of abundance</a>. We have more computer power than we possibly know what to do with on the desktop. Even the naive solutions for most computing problems are "fast enough" these days.  Computers get faster every day, but programmers' brains, sadly, do not. It'd be a waste not to trade some of that abundant raw power to make things easier on us. It's time to evolve up <a href="http://www.codinghorror.com/blog/archives/000224.html">the one trillion dollar programming pyramid</a>.
<p>
</p>
</li>
<li>
<b>C++ is designed for any possible programming task, from the lowest level to the highest.</b> It makes sense to use C++ to write operating system kernels and device drivers. But when was the last time you used C++ to write a line of business app or website? C++ is perhaps the ultimate generalist language. Because it can do all these things, it's complicated and <a href="http://en.wikipedia.org/wiki/Buffer_overflow">dangerous</a>. Other languages don't try to span the entire range of low-level to high-level programming tasks; they simplify to attack a specific high-level problem domain.
</li>
</ol>
<p>
C++ is a key historic milestone in the evolution of computer languages. There will always be a place in a programmer's toolbox for C++,  but I'd argue that it's an increasingly a niche language for a very specific subset of programming tasks. The most important question to ask about any language these days isn't how fast it is, or how general it is, but <b>how well does it protect you from yourself?</b> Stroustrup <a href="http://www.research.att.com/~bs/bs_faq.html#really-say-that">has a great quote that says it all</a>:
</p>
<p>
</p>
<blockquote>
C makes it easy to shoot yourself in the foot; C++ makes it harder, but when you do it blows your whole leg off.
</blockquote>
<p>
</p>
<p></p>
<!--kg-card-end: markdown-->
            </content>
<pubDate>2007-01-12T12:00:00.000Z</pubDate>
<guid>https://blog.codinghorror.com/the-problem-with-c/</guid>
</item>
</channel>
</rss>
