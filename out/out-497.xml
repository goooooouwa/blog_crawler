<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0">
<channel>
<title>Coding Horror</title>
<description>programming and human factors</description>
<link>https://blog.codinghorror.com/</link>
<pubDate>Sun, 19 Apr 2020 00:00:01 GMT</pubDate>
<!-- other elements omitted from this example -->
<item>
<title>Why Does Software Spoil?</title>
<link>https://blog.codinghorror.com/why-does-software-spoil/</link>
<content>
                <!--kg-card-begin: markdown--><p>
In the software industry, the release of newer, better versions is part of the natural order. It's a relentless march towards perfection that <a href="http://www.codinghorror.com/blog/archives/000718.html">started with the first personal computers</a>, and continues today. We expect software to get larger and more sophisticated over time, to track with the hardware improvements that <a href="http://www.codinghorror.com/blog/archives/000741.html">Moore's law has provided us</a> for so many years. Rapid evolution is a good thing, and it's one reason the computer industry is so exciting to work in. If you don't like the way things are today, <a href="http://www.codinghorror.com/blog/archives/000545.html">just wait five years</a>; everything will be different.
</p>
<p>
</p>
<blockquote>
Letts' Law: All programs evolve until they can send email.
<p>
<a href="http://www.catb.org/~esr/jargon/html/Z/Zawinskis-Law.html">Zawinski's Law</a>: Every program attempts to expand until it can read mail.
</p>
<p>
<a href="http://www.furrygoat.com/2005/05/furrygoats_law.html">Furrygoat's Law</a>: Every program attempts to expand until it can read RSS feeds.
</p>
</blockquote>
<p>
I love the prospect of upgrading my favorite software. Done right, it's like watching a caterpillar shed its skin and become a beautiful butterfly. Or at least a <a href="http://en.wikipedia.org/wiki/Hyalophora_cecropia">decent-looking moth</a>.
</p>
<p>
<a href="http://en.wikipedia.org/wiki/Hyalophora_cecropia"><img alt="cecropia caterpillar" border="0" class="at-xid-6a0120a85dcdae970b0128777022f7970c" height="332" src="https://blog.codinghorror.com/content/images/uploads/2007/10/6a0120a85dcdae970b0128777022f7970c-pi.jpg" width="363"></a>
Â 
<a href="http://en.wikipedia.org/wiki/Hyalophora_cecropia"><img alt="cecropia moth" border="0" class="at-xid-6a0120a85dcdae970b012877702305970c" height="332" src="https://blog.codinghorror.com/content/images/uploads/2007/10/6a0120a85dcdae970b012877702305970c-pi.jpg" width="269"></a>
</p>
<p>
But for some software packages, something goes terribly, horribly wrong during the process of natural upgrade evolution. Instead of becoming <i>better</i> applications over time, they become <i>worse</i>. They end up more bloated, more slow, more complex, more painful to use.
</p>
<p>
<b>They spoil.</b>
</p>
<p>
I know this first hand because I'm a long-time <a href="http://en.wikipedia.org/wiki/Paint_Shop_Pro">Paint Shop Pro</a> user. As a programmer who doesn't need the kitchen sink of graphics editor features, I found it an <a href="http://www.codinghorror.com/blog/archives/000849.html">ideal match for my modest programmer needs</a>. I didn't upgrade to every new version, but when I did, for every new feature I could actually use and benefit from, there were dozens of other features included that I didn't care about. These new features cluttered up the user interface and often interfered with what I wanted to do. My computers kept getting faster, and yet PSP kept taking longer and longer to start up with each new version.
</p>
<p>
</p>
<table cellpadding="4" cellspacing="4" width="300">
<tr>
<td>2.0</td>
<td>1994?</td>
<td>0.4 MB</td>
</tr>
<tr>
<td>3.11</td>
<td>1995</td>
<td>1.8 MB</td>
</tr>
<tr>
<td>4.12</td>
<td>1997</td>
<td>2.4 MB</td>
</tr>
<tr>
<td>5.0</td>
<td>1998</td>
<td>6.7 MB</td>
</tr>
<tr>
<td>6.0</td>
<td>1999</td>
<td>?</td>
</tr>
<tr>
<td>7.0</td>
<td>2000</td>
<td>32 MB</td>
</tr>
<tr>
<td>8.0</td>
<td>2003</td>
<td>54 MB</td>
</tr>
<tr>
<td>9.0</td>
<td>2004</td>
<td>108 MB</td>
</tr>
<tr>
<td>10.0</td>
<td>2005</td>
<td>104 MB</td>
</tr>
<tr>
<td>11.00</td>
<td>2006</td>
<td>211 MB</td>
</tr>
<tr>
<td>12.00</td>
<td>2007</td>
<td>326 MB</td>
</tr>
</table>
<p>
If this spoilage goes on long enough, <b>eventually you begin to loathe and fear the upgrade process</b>. And that strikes me as profoundly sad, because it rips the heart out of the essential enjoyment of software engineering. We write software. If we inevitably end up making software <i>worse</i>, then why are we bothering? What are we doing wrong?
</p>
<p>
I'm not against progress by any means. But it sure seems to me that certain software packages have truly lost their way. In their never-ending quest to add feature bullets, they've somehow forgotten their users and their core values. In trying to be everything to everyone, they progressively destroy that tiny core of uniqueness that they started with. I'm singling out Paint Shop Pro here, but this same software spoilage principle applies to many other applications. <a href="http://www.pcworld.com/article/id,137703-page,1-c,software/article.html">PC World compiled an annotated list of 13 software applications</a> they liked better before they were "improved":
</p>
<p>
</p>
<ul>
<li>AIM
</li>
<li>ICQ
</li>
<li>Windows Live Messenger
</li>
<li>Windows Media Player
</li>
<li>iTunes
</li>
<li>QuickTime
</li>
<li>iMovie
</li>
<li>Paint Shop Pro
</li>
<li>ACDSee
</li>
<li>Adobe Acrobat Reader
</li>
<li>Eudora
</li>
</ul>
<p>
They helpfully provide links to <a href="http://www.oldversion.com/">oldversion.com</a>, <a href="http://oldapps.com/">oldapps.com</a>, and <a href="http://old-versions.net/">old-versions.net</a>, where you can go back in time and obtain those classic, unspoiled versions.
</p>
<p>
</p>
<blockquote>
My favorite version is Winamp 2.95. That's before they started bulking up the client and adding completely unnecessary things. I just want something that plays my MP3s. I don't need it to burn CDs for me or download new music or cook my breakfast or massage my feet.
</blockquote>
There are also some emerging lightweight alternatives to choose from in each category. Instead of <a href="http://www.oldversion.com/program.php?n=acrobat">Adobe's 20 MB Acrobat Reader</a>, you could opt for the <a href="http://www.foxitsoftware.com/pdf/rd_intro.php">2 MB Foxit PDF Reader</a>. Instead of suffering through another 300+ MB Paint Shop Pro upgrade, chock full of features I'll never use, I could opt for the open source <a href="http://www.getpaint.net/">Paint.NET</a>.
<p>
It's depressing to me that there are very few apps I can stick with for more than five years before they become an untenable, unbearable mess. I can think of so many that I've liked and since discarded: Nero Burning ROM, WinAmp, ACDSee, Microsoft Money, WinZip, and many others.
</p>
<p>
I suppose features sell software. For many companies, putting users on the version upgrade treadmill is their business model; it's how they generate revenue. But if this fiscally rewarding feature creep goes on long enough, spoilage inevitably sets in. So I wonder: <b>Is all software destined to spoil over time?</b> Is it possible for software packages with long histories to avoid the trap of becoming bloated and irrelevant? What are your favorite bits of software that <i>haven't</i> spoiled over the years-- and what is their secret?
</p>
<p>
</p>
<p></p>
<!--kg-card-end: markdown-->
            </content>
<pubDate>2007-10-17T12:00:00.000Z</pubDate>
<guid>https://blog.codinghorror.com/why-does-software-spoil/</guid>
</item>
</channel>
</rss>
