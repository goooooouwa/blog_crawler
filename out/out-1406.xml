<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0">
<channel>
<title>Coding Horror</title>
<description>programming and human factors</description>
<link>https://blog.codinghorror.com/</link>
<pubDate>Sun, 19 Apr 2020 00:00:01 GMT</pubDate>
<!-- other elements omitted from this example -->
<item>
<title>Why Objects Suck</title>
<link>https://blog.codinghorror.com/why-objects-suck/</link>
<content>
                <!--kg-card-begin: markdown--><p>
There's been a lot of discussion recently about the <a href="http://en.wikipedia.org/wiki/Object-relational_mapping">Object to Relational mapping problem</a>, which is a serious one. This <a href="http://staff.newtelligence.net/clemensv/PermaLink.aspx?guid=8a119c62-2fc1-4409-9ae4-0b250fdb785b">Clemens Vasters blog entry</a> summarizes it best:
</p>
<blockquote>
Maybe I am too much of a data (read: XML, Messages, SQL) guy by now, but <b>I just lost faith that objects are any good on the "business logic" abstraction level</b>. The whole inheritance story is usually refactored away for very pragmatic reasons and the encapsulation story isn't all that useful either.<p>
What you end up with are elements and attributes (infoset) for the data that flows across, services that deal with the data that flows, and rows and columns that efficiently store data and let you retrieve it flexibly and quickly. Objects lost (except on the abstract and conceptional analysis level where they are useful to understand a problem space) their place in that picture for me.
</p>
</blockquote>
A followup from <a href="http://hyperthink.net/blog/PermaLink,guid,22728ae4-a1d4-4fa7-b8fd-757640112d06.aspx">Steve Maine's blog</a> elaborates a bit:
<blockquote>
A typical business problem is the converse of a typical object-oriented problem. Business problems are generally interested in a very limited set of operations (CRUD being the most popular). These operations are only as polymorphic as the data on which they operate. The Customer.Create() operation is really no different behaviorally than Product.Create() (if Product and Customer had the same name, you could reuse the same code modulo stored procedure or table name), however the respective data sets on which they both operate are likely to be vastly different. As collective industry experience has shown, handing polymorphic data with language techniques optimized for polymorphic behavior is tricky at best. Yes, it can be done, but it requires fits of extreme cleverness on the part of the developer. <b>Often those fits of cleverness turn into fugues of frustration because the programming techniques designed to reduce complexity have actually compounded it.</b>
</blockquote>
<p>
All I can say to the above is, I concur. We've concluded the same thing in a few projects at work. We started with naive Object implementations, and then scaled back-- purely for reasons of simplicity-- to passing around raw DataSets. As one of my co-workers said:
</p>
<blockquote>
At first you're like "whee! objects!" and then you realize-- hey, this is a lot of tedious, error-prone mapping code I didn't have to write before...
</blockquote>
I've always maintained that the IDE should be able to support named dot-style access to the database and tables, which it automatically absorbs from the database schema behind the scenes. I know we have Typed Datasets, but those are not transparent and certainly not automatic. So instead of this syntax, which raises the hackles of SmallTalk fans worldwide:
<p>
</p>
<pre>
ds.Tables("Customers").Rows(1).Item("FirstName")
</pre>
<p>
We could use this syntax:
</p>
<p>
</p>
<pre>
ds.Customers.Customer(1).FirstName
</pre>
<p>
Again, this is <u>only</u> useful if it is <b>completely automatic in the IDE, with intellisense support-- that is, zero code required from the developer!</b> It also would force you to have a clean schema design for your DB, which can't be a bad thing.
</p>
<p>
</p>
<p></p>
<!--kg-card-end: markdown-->
            </content>
<pubDate>2004-07-10T12:00:00.000Z</pubDate>
<guid>https://blog.codinghorror.com/why-objects-suck/</guid>
</item>
</channel>
</rss>
