<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0">
<channel>
<title>Coding Horror</title>
<description>programming and human factors</description>
<link>https://blog.codinghorror.com/</link>
<pubDate>Sun, 19 Apr 2020 00:00:01 GMT</pubDate>
<!-- other elements omitted from this example -->
<item>
<title>Cross-Site Request Forgeries and You</title>
<link>https://blog.codinghorror.com/cross-site-request-forgeries-and-you/</link>
<content>
                <!--kg-card-begin: markdown--><p>
As the web becomes more and more pervasive, so do web-based security vulnerabilities. I talked a little bit about the most common web vulnerability, cross-site scripting, in <a href="http://www.codinghorror.com/blog/archives/001167.html">Protecting Your Cookies: HttpOnly</a>. Although XSS is incredibly dangerous, it's a fairly straightforward exploit to understand. <b>Do not allow users to insert arbitrary HTML on your site.</b> The name of the XSS game is sanitizing user input. If you stick to a whitelist based approach -- <i>only</i> allow input that you know to be good, and <i>immediately</i> discard anything else -- then you're usually well on your way to solving any XSS problems you might have.
</p>
<p>
I thought we had our website vulnerabilies licked with XSS. I was wrong. <a href="http://blog.codeville.net/2008/09/01/prevent-cross-site-request-forgery-csrf-using-aspnet-mvcs-antiforgerytoken-helper/">Steve Sanderson explains</a>:
</p>
<p>
</p>
<blockquote>
<b>Since XSS gets all the limelight, few developers pay much attention to another form of attack that's equally destructive and potentially far easier to exploit.</b> Your application can be vulnerable to cross-site request forgery (CSRF) attacks not because you the developer did something wrong (as in, failing to encode outputs leads to XSS), but simply because of how the whole Web is designed to work. Scary!
</blockquote>
<p>
It turns out I didn't understand how <a href="http://en.wikipedia.org/wiki/Cross-site_request_forgery">cross-site request forgery</a>, also known as XSRF or CSRF, works. It's not complicated, necessarily, but it's more.. subtle.. than XSS.
</p>
<p>
Let's say we allow users to post images on our forum. What if one of our users posted this image?
</p>
<p>
</p>
<pre>
&lt;img src="http://foo.com/logout"&gt;
</pre>
<p>
Not really an image, true, but it will force the target URL to be retrieved by any random user who happens to browse that page -- <b>using their browser credentials!</b> From the webserver's perspective, there is no difference whatsoever between a real user initiated browser request and the above image URL retrieval.
</p>
<p>
If our logout page was a simple HTTP GET that required no confirmation, <b>every user who visited that page would immediately be logged out.</b> That's XSRF in action. Not necessarily dangerous, but annoying.  Not too difficult to envision much more destructive versions of this technique, is it?
</p>
<p>
There are two obvious ways around this sort of basic XSRF attack:
</p>
<p>
</p>
<ol>
<li>Use a HTTP POST form submission for logout, not a garden variety HTTP GET.
</li>
<li>Make the user confirm the logout.
</li>
</ol>
<p>
Easy fix, right? We probably should never have never done either of these things in the first place. Duh!
</p>
<p>
Not so fast. Even with both of the above fixes, you are <i>still</i> vulnerable to XSRF attacks. Let's say I took my own advice, and converted the logout form to a HTTP POST, with a big button titled "Log Me Out" confirming the action. What's to stop a malicious user from placing a form like this on their own website ..
</p>
<p>
</p>
<pre>
&lt;body onload="document.getElementById('f').submit()"&gt;
&lt;form id="f" action="http://foo.com/logout" method="post"&gt;
&lt;input name="Log Me Out" value="Log Me Out" /&gt;
&lt;/form&gt;
&lt;/body&gt;
</pre>
<p>
.. and then <b>convincing other users to click on it?</b>
</p>
<p>
Remember, the browser will happily act on this request, submitting this form along with all necessary cookies and credentials directly to your website.  Blam. Logged out. Exactly as if they had clicked on the "Log Me Out" button themselves.
</p>
<p>
Sure, it takes a tiny bit more social engineering to convince users to visit some random web page, but it's not much. And the possibilities for attack are enormous: with XSRF, <b>malicious users can initiate any arbitrary action they like on a target website</b>. All they need to do is trick unwary users of <i>your</i> website -- who already have a validated user session cookie stored in their browser -- into clicking on <i>their</i> links.
</p>
<p>
So what can we do to protect our websites from these kinds of cross site request forgeries?
</p>
<p>
</p>
<ol>
<li>
<b>Check the referrer</b>. The HTTP referrer, or HTTP "referer" as it is now permanently misspelled, should always come from your own domain. You could reject any form posts from alien referrers. However, this is risky, as some corporate proxies strip the referrer from all HTTP requests as an anonymization feature. You would end up potentially blocking legitimate users. Furthermore, spoofing the referrer value is extremely easy. All in all, a waste of time. Don't even bother with referrer checks.
<p></p>
</li>
<li>
<b>Secret hidden form value</b>. Send down a unique server form value with each form -- typically tied to the user session -- and validate that you get the same value back in the form post. The attacker can't simply scrape your remote form as the target user through JavaScript, thanks to same-domain request limits in the <code>XmlHttpRequest</code> function.
<p></p>
</li>
<li>
<b>Double submitted cookies</b>. It's sort of ironic, but another way to prevent XSRF, essentially a cookie-based exploit, is to <i>add more cookies!</i> Double submitting means sending the cookie both ways in every form request: first as a traditional header value, and again as a form value -- read via JavaScript and inserted. The trick here is that remote <code>XmlHttpRequest</code> calls can't read cookies. If either of the values don't match, discard the input as spoofed. The only downside to this approach is that it does require your users to have JavaScript enabled, otherwise their own form submissions will be rejected.
</li>
</ol>
<p>
If your web site is vulnerable to XSRF, you're in good company. <a href="http://4diggers.blogspot.com/2006/06/how-to-defeat-digg.html">Digg</a>, <a href="http://directwebremoting.org/blog/joe/2007/01/01/csrf_attacks_or_how_to_avoid_exposing_your_gmail_contacts.html">GMail</a>, and <a href="http://sourceforge.net/project/shownotes.php?release_id=307067">Wikipedia</a> have all been successfully attacked this way before.
</p>
<p>
Maybe you're already protected from XSRF. Some web frameworks provide built in protection for XSRF attacks, usually through unique form tokens. But do you know for sure? Don't make the same mistake I did! Understand how XSRF works and ensure you're protected <i>before</i> it becomes a problem.
</p>
<p>
</p>
<p></p>
<!--kg-card-end: markdown-->
            </content>
<pubDate>2008-09-23T12:00:00.000Z</pubDate>
<guid>https://blog.codinghorror.com/cross-site-request-forgeries-and-you/</guid>
</item>
</channel>
</rss>
