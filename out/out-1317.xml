<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0">
<channel>
<title>Coding Horror</title>
<description>programming and human factors</description>
<link>https://blog.codinghorror.com/</link>
<pubDate>Sun, 19 Apr 2020 00:00:01 GMT</pubDate>
<!-- other elements omitted from this example -->
<item>
<title>Who Needs Stored Procedures, Anyways?</title>
<link>https://blog.codinghorror.com/who-needs-stored-procedures-anyways/</link>
<content>
                <!--kg-card-begin: markdown--><p>
It's intended as sarcasm, but I believe this <a href="http://thedailywtf.com/archive/2004/05/25/153.aspx">Daily WTF entry on Stored Procedures</a> should be taken at face value:
</p>
<p>
</p>
<blockquote>
I'm sure we've all heard, over and over, that inline SQL is generally a bad practice, and that we should use Stored Procedures when possible. But let's be realistic for a minute. Who wants to write a stupid stored procedure for every stupid little simple query needed.
</blockquote>
<p>
Have you ever worked on a system where someone decreed* that <b>all database calls must be Stored Procedures, and SQL is strictly verboten?</b> I have, and this decision leads to incredible development pain:
</p>
<ol>
<li>Stored Procedures are written in big iron database "languages" like PL/SQL (Oracle) or T-SQL (Microsoft). These so-called languages are archaic, and full of the crazy, incoherent design choices that always result from the torturous evolution of ten years of backwards compatibility.  You really don't want to be writing a lot of code in this stuff. For context, JavaScript is a giant step up from PL/SQL or T-SQL.
</li>
<li>Stored Procedures typically cannot be debugged in the same IDE you write your UI. Every time I isolate an exception in the procs, I have to stop what I am doing, bust out my copy of <a href="http://www.quest.com/toad/">Toad</a>, and load up the database packages to see what's going wrong. Frequently transitioning between two totally different IDEs, with completely different interfaces and languages, is not exactly productive.
</li>
<li>Stored Procedures don't provide much feedback when things go wrong. Unless the proc is coded interally with weird T-SQL or PL/SQL exception handling, we get cryptic 'errors' returned based on the particular line inside the proc that failed, such as <i>Table has no rows</i>. Uh, ok?
</li>
<li>Stored Procedures can't pass objects. So, if you're not careful, you can end up with a zillion parameters. If you have to populate a table row with 20+ fields using a proc, say hello to 20+ parameters. Worst of all, if I pass a bad parameter-- either too many, not enough, or bad datatypes-- I get a generic "bad call" error. Oracle can't tell me which parameters are in error! So I have to pore over 20 parameters, by hand, to figure out which one is the culprit.
</li>
<li>Stored Procedures hide business logic. I have no idea what a proc is doing, or what kind of cursor (DataSet) or values it will return to me. I can't view the source code to the proc (at least, without resorting to #2 if I have appropriate access) to verify that it is actually doing what I think it is-- or what the designer intended it to do. Inline SQL may not be pretty, but at least I can see it in context, alongside the other business logic.
</li>
</ol>
So why use Stored Procedures at all? <a href="http://msdn.microsoft.com/library/default.asp?url=/library/en-us/dnbda/html/daag.asp">Conventional wisdom</a> says we do it because:
<ul>
<li>Stored procedures generally result in improved performance because the database can optimize the data access plan used by the procedure and cache it for subsequent reuse.
</li>
<li>Stored procedures can be individually secured within the database. A client can be granted permissions to execute a stored procedure without having any permissions on the underlying tables.
</li>
<li>Stored procedures result in easier maintenance because it is generally easier to modify a stored procedure than it is to change a hard-coded SQL statement within a deployed component.
</li>
<li>Stored procedures add an extra level of abstraction from the underlying database schema. The client of the stored procedure is isolated from the implementation details of the stored procedure and from the underlying schema.
</li>
<li>Stored procedures can reduce network traffic, because SQL statements can be executed in batches rather than sending multiple requests from the client.
</li>
</ul>
<p>
And many people <a href="http://weblogs.asp.net/rhoward/archive/2003/11/17/38095.aspx">buy into this philosophy</a>, lock stock and barrel:
</p>
<blockquote><i>
At just about every talk I give I always try to make several consistent statements. One of which is: Ã¢â‚¬ËœWhenever possible use stored procedures to access your data'.
</i></blockquote>
<p>
However, there's one small problem: <b>none of these things are true in practice</b>. The benefits are marginal, but the pain is substantial. And I'm <a href="http://weblogs.asp.net/fbouma/archive/2003/11/18/38178.aspx">not the only person that feels this way</a>. John Lam <a href="http://www.iunknown.com/000387.html">also adds</a>:
</p>
<p>
</p>
<blockquote>
<i>
As a guy who dabbles in low-level bit twiddling stuff from time-to-time, the performance claims are quite interesting to me. The new (as of SQL Server 7.0) <a href="http://msdn.microsoft.com/library/default.asp?url=/library/en-us/architec/8_ar_sa_4azp.asp">cached execution plan optimization</a> in SQL Server looks to me a lot like JIT compilation. If this is, in fact, the case it seems to me that the only overhead that would be associated with dynamic SQL would be:
</i><p>
</p>
<ol>
<li>The amount of bandwidth + time it takes to transmit the dynamic SQL text to the database.
</li>
<li>The amount of time it takes to calculate the hash of the dynamic SQL text to look up the cached execution plan.
</li>
</ol>
I can imagine quite a few scenarios where the above overhead would disappear into the noise of the network roundtrip. What upsets me are the folks who spout forth anecdotal arguments that claim stored procedures have "much better" performance than dynamic SQL.
</blockquote>
<p>
For modern databases and real world usage scenarios, I believe a Stored Procedure architecture has serious downsides and little practical benefit. <b>Stored Procedures should be considered database assembly language: for use in only the most performance critical situations</b>. There are plenty of ways to design a solid, high performing data access layer without resorting to Stored Procedures; you'll realize a lot of benefits if you stick with <a href="http://www.uberasp.net/getarticle.aspx?id=46">parameterized SQL</a> and a single coherent development environment.
</p>
<p>
* "the man".
</p>
<p>
</p>
<p></p>
<!--kg-card-end: markdown-->
            </content>
<pubDate>2004-10-28T12:00:00.000Z</pubDate>
<guid>https://blog.codinghorror.com/who-needs-stored-procedures-anyways/</guid>
</item>
</channel>
</rss>
