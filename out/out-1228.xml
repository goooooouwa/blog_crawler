<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0">
<channel>
<title>Coding Horror</title>
<description>programming and human factors</description>
<link>https://blog.codinghorror.com/</link>
<pubDate>Sun, 19 Apr 2020 00:00:01 GMT</pubDate>
<!-- other elements omitted from this example -->
<item>
<title>Gettin' Greppy Wit It</title>
<link>https://blog.codinghorror.com/gettin-greppy-wit-it/</link>
<content>
                <!--kg-card-begin: markdown--><p>
We're currently supporting a third party application that, in addition to producing some <a href="http://www.thedailywtf.com/ShowPost.aspx?PostID=29337">truly impressive WTFs</a>, generates incredibly verbose log files with zillions of 'error messages' that aren't really errors. This makes diagnosing problems in their server code* very difficult.
</p>
<p>
It is, however, a great use for a GREP tool-- basically, <a href="http://www.codinghorror.com/blog/archives/000027.html">regular expressions</a> applied to the filesystem. Let's filter this set of log files to the <i>real</i> errors:
</p>
<p>
<img alt="PowerGREP screenshot" class="at-xid-6a0120a85dcdae970b0128776facdc970c" height="493" src="https://blog.codinghorror.com/content/images/uploads/2005/02/6a0120a85dcdae970b0128776facdc970c-pi.png" width="787">
</p>
<p>
This is <a href="http://www.powergrep.com/cgi-bin/affref.pl?aff=jatwood">PowerGREP</a>, from the same guy who wrote <a href="http://www.regexbuddy.com/cgi-bin/affref.pl?aff=jatwood">RegexBuddy</a>. I haven't used any GUI GREP tools before, so I can't say how PowerGREP compares, but it's certainly of the same high quality I've come to expect from using RegexBuddy (which also has, not coincidentally, a mini-GREP mode in the latest version).
</p>
<p>
GREP is originally a UNIX command, so of course there's <a href="http://unxutils.sourceforge.net/">a command line GREP</a>. There are a million command line params, which is expected. Let me save you some time. First, use the <code>--V</code> command to make sure you're using GREP version 2.5.1 or later. Here's the syntax you'll likely want if you're used to standard (Perl-style) .NET regular expressions :
</p>
<p>
Show only the actual text that matches this pattern, case insensitive, against a single file. This is great for summarizing stuff:
</p>
<p>
</p>
<pre>
grep -P -i -o "d{2}:d{2}:d{2}|&gt;[^&lt;&gt;]+" xyz.txt
</pre>
<p>
Attempt to match the pattern contained in the file myregex.txt to every file in the current folder. If a match is found, output the entire line that matches including the line number. You end up with a nice little file of matches and line numbers (note that filename will be included if the matches span more than one file, although this can be disabled).
</p>
<p>
</p>
<pre>
grep -P -i -n --file myregex.txt *.* &gt;output.txt
</pre>
<p>
When you start typing complicated regular expressions at the command line, beware <a href="http://www.eightypercent.net/Archive/2004/12/05.html#a226">truly mind-melting command line escaping rules!</a> And that's on top of the regex escaping rules. I found it easier to put complex regexes in a file and use the <code>--file</code> command, or wrap the whole thing in a tiny .bat file and use <code>CALL</code> to execute it.
</p>
<p>
After I developed the regex to eliminate all the spurious errors (as pictured), I set up a batch file that:
</p>
<p>
</p>
<ol>
<li>command-line greps that regex on the log folder to a temp file
</li>
<li>grep the temp file using a simpler regex, filtering out just the times and messages without all the surrounding pseudo-XML cruft
</li>
<li>use <a href="http://sourceforge.net/projects/blat">blat</a> to email the file output to me
</li>
<li>placed batch file in a scheduled task
</li>
</ol>
<p>
Using only three lines in a batch file (GREP, GREP, BLAT), I get a list of relevant errors generated by this system every morning. It's enough to make you almost appreciate UNIX.
</p>
<p>
Almost.
</p>
<p>
* It's sort of assumed that third party vendors are writing code of higher quality than we do internally. That is, after all, why they're in the software business, and we're not. If using third party software instills a strong desire to rewrite the application, that's a damning indictment. If I wanted slow, buggy, and crash-prone, I would have written it myself.
</p>
<p>
This app jumped the shark when I forwarded <a href="http://www.faqs.org/rfcs/rfc821.html">RFC821</a> to their engineering department. I diagnosed a "we're not getting email" ticket with the sniffer, and saw their app wasn't sending the domain name with the HELO command. Sendmail was (rightly) rejecting them. Way to adhere to the very first command in a standard written in 1982, people!
</p>
<p>
</p>
<p></p>
<!--kg-card-end: markdown-->
            </content>
<pubDate>2005-02-11T12:00:00.000Z</pubDate>
<guid>https://blog.codinghorror.com/gettin-greppy-wit-it/</guid>
</item>
</channel>
</rss>
