<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0">
<channel>
<title>Coding Horror</title>
<description>programming and human factors</description>
<link>https://blog.codinghorror.com/</link>
<pubDate>Sun, 19 Apr 2020 00:00:01 GMT</pubDate>
<!-- other elements omitted from this example -->
<item>
<title>Version 1 Sucks, But Ship It Anyway</title>
<link>https://blog.codinghorror.com/version-1-sucks-but-ship-it-anyway/</link>
<content>
                <!--kg-card-begin: markdown--><p>I've been unhappy with every single piece of software I've ever released. Partly because, like many software developers, I'm a perfectionist. And then, there are inevitably … <i>problems</i>:</p>
<ul>
<li>The schedule was too aggressive and too short. We need more time!</li>
<li>We ran into unforeseen technical problems that forced us to make compromises we are uncomfortable with.</li>
<li>We had the wrong design, and needed to change it in the middle of development.</li>
<li>Our team experienced internal friction between team members that we didn't anticipate.</li>
<li>The customers weren't who we thought they were.</li>
<li>Communication between the designers, developers, and project team wasn't as efficient as we thought it would be.</li>
<li>We overestimated how quickly we could learn a new technology.</li>
</ul>
<p>The list goes on and on. Reasons for failure on a software project <a href="http://blog.codinghorror.com/escaping-from-gilligans-island/">are legion</a>.</p>
<p>At the end of the development cycle, you end up with <b>software that is a pale shadow of the shining, glorious monument to software engineering that you envisioned when you started</b>.</p>
<p>It's tempting, at this point, to throw in the towel – to add more time to the schedule so you can get it right before shipping your software. Because, after all, <a href="http://blog.codinghorror.com/shipping-isnt-enough/">real developers ship</a>.</p>
<p>I'm here to tell you that <b>this is a mistake</b>.</p>
<p>Yes, you did a ton of things wrong on this project. But you also did a ton of things wrong that <i>you don't know about yet</i>. And there's no other way to find out what those things are until you ship this version and get it in front of users and customers. I think <a href="http://www.slate.com/id/2081042/">Donald Rumsfeld put it best</a>:</p>
<blockquote>
<p>As we know,<br><br>
There are known knowns.<br><br>
There are things we know we know.<br><br>
We also know<br><br>
There are known unknowns.<br><br>
That is to say<br><br>
We know there are some things<br><br>
We do not know.<br><br>
But there are also unknown unknowns,<br><br>
The ones we don't know<br><br>
We don't know.</p>
</blockquote>
<p>In the face of the inevitable end-of-project blues – rife with compromises and totally unsatisfying quick fixes and partial soutions – you could hunker down and lick your wounds. You could regroup and spend a few extra months fixing up this version before releasing it. You might even feel good about yourself for making the hard call to get the engineering right before unleashing yet another buggy, incomplete chunk of software on the world.</p>
<p>Unfortunately, this is an even bigger mistake than shipping a flawed version.</p>
<p>Instead of spending three months fixing up this version in a sterile, isolated lab, you <i>could</i> be spending that same three month period <b>listening to feedback from real live, honest-to-god, <s>annoying</s>dedicated users of your software</b>. Not the software as you imagined it, and the users as you imagined them, but as they exist in the real world. You can turn around and use that directed, real world feedback to not only <i>fix</i> all the sucky parts of version 1, but spend your whole development budget more efficiently, predicated on hard usage data from your users.</p>
<p>Now, I'm not saying you should release crap. Believe me, we're all perfectionists here. But the real world can be a cruel, unforgiving place for us perfectionists. It's saner to let go and realize that when your software crashes on the rocky shore of the real world, disappointment is inevitable … <i>but fixable!</i> What's important isn't so much the initial state of the software – in fact, some say <a href="http://successfulsoftware.net/2007/08/07/if-you-arent-embarrassed-by-v10-you-didnt-release-it-early-enough/">if you aren't embarrassed by v1.0 you didn't release it early enough</a> – but what you do <i>after</i> releasing the software.</p>
<p>The velocity and responsiveness of your team to user feedback will set the tone for your software, far more than any single release ever could. That's what you need to get good at. Not the platonic ideal of shipping mythical, perfect software, but being responsive to your users, to your customers, and demonstrating that through the act of continually improving and refining your software based on their feedback. So to the extent that you're optimizing for near-perfect software releases, you're optimizing for the wrong thing.</p>
<p>There's no <i>question</i> that, for whatever time budget you have, you will end up with better software by releasing as early as practically possible, and then spending the rest of your time <a href="http://blog.codinghorror.com/boyds-law-of-iteration/">iterating rapidly based on real world feedback</a>.</p>
<p>So trust me on this one: <b>even if version 1 sucks, ship it anyway</b>.</p>
<!--kg-card-end: markdown-->
            </content>
<pubDate>2009-12-03T12:00:00.000Z</pubDate>
<guid>https://blog.codinghorror.com/version-1-sucks-but-ship-it-anyway/</guid>
</item>
</channel>
</rss>
