<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0">
<channel>
<title>Coding Horror</title>
<description>programming and human factors</description>
<link>https://blog.codinghorror.com/</link>
<pubDate>Sun, 19 Apr 2020 00:00:01 GMT</pubDate>
<!-- other elements omitted from this example -->
<item>
<title>Filesystem Paths: How Long is Too Long?</title>
<link>https://blog.codinghorror.com/filesystem-paths-how-long-is-too-long/</link>
<content>
                <!--kg-card-begin: markdown--><p>I recently imported some source code for a customer that <b>exceeded the maximum path limit of 256 characters</b>. The paths in question weren't particularly meaningful, just <i>pathologically</i>* long, with redundant subfolders. To complete the migration, I renamed some of the parent folders to single character values.</p>
<p>This made me wonder: <b>is 256 characters a reasonable limit for a path?</b> And what's the longest path in my filesystem, anyway? I whipped up this little C# console app to loop through all the paths on my drive and report the longest one.</p>
<pre><code>static string _MaxPath = "";
static void Main(string[] args)
{
  RecursePath(@"c:\");
  Console.WriteLine("Maximum path length is " + _MaxPath.Length);
  Console.WriteLine(_MaxPath);
  Console.ReadLine();
}

static void RecursePath(string p)
{
  foreach (string d in Directory.GetDirectories(p))
  {
    if (IsValidPath(d))
    {
      foreach (string f in Directory.GetFiles(d))
      {
        if (f.Length &gt; _MaxPath.Length)
        {
          _MaxPath = f;
        }
      }
      RecursePath(d);
    }
  }
}
static bool IsValidPath(string p)
{
  if ((File.GetAttributes(p) &amp; FileAttributes.ReparsePoint) == FileAttributes.ReparsePoint)
  {
    Console.WriteLine("'" + p + "' is a reparse point. Skipped");
    return false;
  }
  if (!IsReadable(p))
  {
    Console.WriteLine("'" + p + "' *ACCESS DENIED*. Skipped");
    return false;
  }
  return true;
}
static bool IsReadable(string p)
{
  try
  {
    string[] s = Directory.GetDirectories(p);
  }
  catch (UnauthorizedAccessException ex)
  {
    return false;
  }
  return true;
}
</code></pre>
<p>It works, but it's a bit more complicated than I wanted it to be, because</p>
<ol>
<li>There are a few folders we don't have permission to access.</li>
<li>Vista makes heavy use of <a href="http://en.wikipedia.org/wiki/NTFS#Features">reparse points</a> to <a href="http://www.hanselman.com/blog/MoreOnVistaReparsePoints.aspx">remap old XP folder locations as symbolic links</a>.</li>
</ol>
<p><b>The longest path on a clean install of Windows XP is 152 characters.</b></p>
<pre><code>c:\Documents and Settings\All Users\Application Data\Microsoft\Crypto\RSAS-1-5-18d42cc0c3858a58db2db37658219e6400_89e7e133-abee-4041-a1a7-406d7effde91
</code></pre>
<p>This is followed closely by a bunch of stuff in <code>c:\WINDOWS\assembly\GAC_MSIL</code>, which is a side-effect of .NET 2.0 being installed.</p>
<p><b>The longest path on a semi-clean install of Windows 8.1 is 273 characters:</b></p>
<pre><code>c:\Users\wumpus-home\AppData\Local\Packages\WinStore_cw5n1h2txyewy\AC\Microsoft\Windows Store\Cache\0\0-Namespace-https???services.apps.microsoft.com?browse?6.2.9200-1?615?en-US?c?US?Namespace?pc?00000000-0000-0000-0000-000000000000?00000000-0000-0000-0000-000000000000.
</code></pre>
<p>The longest path <i>Microsoft</i> created in Windows 8.1 is 273 characters. But what's the longest path I can create in Windows Explorer?</p>
<img alt="Windows Vista path limit screenshot" border="0" class="at-xid-6a0120a85dcdae970b0120a86d7281970b" height="269" src="https://blog.codinghorror.com/content/images/uploads/2006/11/6a0120a85dcdae970b0120a86d7281970b-pi.png" width="720">
<p>The best I could do is 239 characters for folders, and 11 characters for the filename. Add in 3 characters for the inevitable "c:", plus 6 slashes. <b>That's a grand total of 259 characters</b>. Anything longer and I got a "destination path too long" error.</p>
<img alt="Windows Vista destination path too long error" border="0" class="at-xid-6a0120a85dcdae970b0120a86d7293970b" height="261" src="https://blog.codinghorror.com/content/images/uploads/2006/11/6a0120a85dcdae970b0120a86d7293970b-pi.png" width="496">
<p>The 259 character path limit I ran into jibes with the <a href="http://shellrevealed.com/blogs/shellblog/archive/2006/09/28/Common-Questions-Concerning-the-SHFileOperation-API_3A00_-Part-2.aspx">documented MAX_PATH limitation of the Windows shell</a>:</p>
<blockquote>
<p>The maximum length path (in characters) that can be used by the [Windows] shell is <code>MAX_PATH</code> (defined as 260).  Therefore, you should create buffers that you will pass to SHFILEOPSTRUCT to be of length <code>MAX_PATH</code> + 1 to account for these NULLs.</p>
</blockquote>
<p>If 259 characters plus a null seems like an unusually restrictive path limit for a modern filesystem like NTFS, you're right. <b>The NTFS filesystem supports paths of 32,000 characters</b>, but it's largely irrelevant because the majority of Windows APIs you'd use to <i>get</i> to those paths only accept paths of <code>MAX_PATH</code> or smaller. There is a <a href="http://msdn.microsoft.com/en-us/library/aa365247.aspx">wonky Unicode workaround to the MAX_PATH limitation</a>, according to MSDN:</p>
<blockquote>
<p>In the Windows API (with some exceptions discussed in the following paragraphs), the maximum length for a path is <code>MAX_PATH</code>, which is defined as 260 characters. A local path is structured in the following order: drive letter, colon, backslash, name components separated by backslashes, and a terminating null character. For example, the maximum path on drive D is "D:\some 256-character path string&lt;NUL&gt;" where "&lt;NUL&gt;" represents the invisible terminating null character for the current system codepage. (The characters &lt; &gt; are used here for visual clarity and cannot be part of a valid path string.)</p>
<p>The Windows API has many functions that also have Unicode versions to permit an extended-length path for a maximum total path length of 32,767 characters. This type of path is composed of components separated by backslashes, each up to the value returned in the lpMaximumComponentLength parameter of the GetVolumeInformation function (this value is commonly 255 characters). To specify an extended-length path, use the "\?" prefix. For example, "\?\D:\very long path".</p>
<p>The "\?" prefix can also be used with paths constructed according to the universal naming convention (UNC). To specify such a path using UNC, use the "\?\UNC" prefix. For example, "\?\UNC\server\share", where "server" is the name of the computer and "share" is the name of the shared folder. These prefixes are not used as part of the path itself. They indicate that the path should be passed to the system with minimal modification, which means that you cannot use forward slashes to represent path separators, or a period to represent the current directory, or double dots to represent the parent directory. Because you cannot use the "\?" prefix with a relative path, relative paths are always limited to a total of <code>MAX_PATH</code> characters.</p>
<p>The shell and the file system may have different requirements. It is possible to create a path with the API that the shell UI cannot handle.</p>
</blockquote>
<p>Still, I wonder if the world really needs 32,000 character paths. Is a 260 character path really that much of a limitation? <b>Do we need hierarchies that deep?</b> Martin Hardee has <a href="https://web.archive.org/web/20070205200717/http://blogs.sun.com/MartinHardee/date/20040624">an amusing anecdote on this topic</a>:</p>
<blockquote>
<p>We were very proud of our user interface and the fact that we had a way to browse 16,000 (!!) pages of documentation on a CD-ROM.  But browsing the hierarchy felt a little complicated to us. So we asked <a href="http://www.edwardtufte.com/">Tufte</a> to come in and have a look, and were hoping perhaps for a pat on the head or some free advice.</p>
<p>He played with our AnswerBook for about 90 seconds, turned around, and pronounced his review:</p>
<p>"Dr Spock's Baby Care is a best-selling owner's manual for the most complicated 'product' imaginable â€“ and it only has two levels of headings.  You people have 8 levels of hierarchy and I haven't even stopped counting yet.  No wonder you think it's complicated."</p>
</blockquote>
<p><b>I think 260 characters of path is more than enough rope to hang ourselves with.</b> If you're running into path length limitations, the real problem isn't the operating system, or even the computers. The problem is the <a href="http://www.codinghorror.com/blog/archives/000246.html">deep, dark pit of hierarchies</a> the human beings have dug themselves into.</p>
<p>* ouch</p>
<!--kg-card-end: markdown-->
            </content>
<pubDate>2006-11-20T12:00:00.000Z</pubDate>
<guid>https://blog.codinghorror.com/filesystem-paths-how-long-is-too-long/</guid>
</item>
</channel>
</rss>
