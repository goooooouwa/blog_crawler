<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0">
<channel>
<title>Coding Horror</title>
<description>programming and human factors</description>
<link>https://blog.codinghorror.com/</link>
<pubDate>Sun, 19 Apr 2020 00:00:01 GMT</pubDate>
<!-- other elements omitted from this example -->
<item>
<title>Obfuscating Code</title>
<link>https://blog.codinghorror.com/obfuscating-code/</link>
<content>
                <!--kg-card-begin: markdown--><p>
Robert Cringeley, in a post early last year, raised some concerns about <a href="http://www.pbs.org/cringely/pulpit/pulpit20040219.html">reverse engineering .NET code</a>:
</p>
<p>
</p>
<blockquote>
<i>
.NET is almost exclusively Just-In-Time compiled. JIT'ing means, "I was just about to interpret this, but I'll compile it at the very last minute instead." In effect, the .NET code remains in interpretation-intended form right up until the end. The point is that it carries around tons of info with it that makes reverse engineering easy just as with interpreted languages. The original Microsoft BASIC was an interpreted language and subject to this vulnerability, which is why it was so easy to copy on punched paper tape and why Bill Gates once referred to many of his earliest users as "thieves." Many languages are interpreted including some of my favorites like Forth, PostScript, and Scheme. Java is interpreted and subject to this same vulnerability but the evolution of Java has led to it being used mainly for server applications where the source is a bit further out of reach. <b>.NET, on the other hand, is Microsoft's chosen successor to Visual BASIC, and effectively exposes source code at the very heart of Microsoft consumer and enterprise applications.</b>
</i><p>
The answer to providing a modicum of security for interpreted applications has to this point been <a href="http://en.wikipedia.org/wiki/Obfuscation">obfuscation</a> -Ã¢â‚¬â€œ <b>making the code look different so it can be difficult to decompile and figure out.</b> Obfuscation used to mean padding the code with extra variables and gibberish -- that is until a company in Cleveland, Ohio, called Preemptive Solutions Inc. came out with a bytecode optimizer for Java. Called DashO, this software was intended to make Java programs load and run faster by removing all code that wasn't necessary, which is to say de-obfuscating and making perfectly clear what had been so carefully muddied before.
</p>
</blockquote>
<p>
Preemptive also makes <a href="http://www.preemptive.com/products/dotfuscator/">Dotfuscator</a> for the .NET market. A <a href="http://www.gotdotnet.com/team/dotfuscator/">"community edition" of this obfuscator</a> was included with VS.NET 2003. Microsoft knew they had a thorny problem on their hands-- <b>balancing the utility of source code access with the legitimate need to protect commercial software</b>.
</p>
<p>
I believe you can attribute much of .NET's success to its transparency; it's free, easy to obtain, easy to write, and <i>easy to reverse engineer</i>. I've read dozens of blog posts where authors successfully decompiled Microsoft .NET libraries to diagnose difficult problems. .NET's openness is also an indirect compliment to the open source movement, where <a href="http://en.wikipedia.org/wiki/Security_through_obscurity">"security through obscurity"</a> is a derogatory slur.
</p>
<p>
On the other hand, there are special conditions where you do need some additional security. <b>Why pay for a component when you can download it, easily decompile it, and comment out the trial restrictions?</b> If I was selling a commercial .NET component, I'd be a fool to release a trial version without obfuscating it first. As with all client-side protection methods, this is only a stopgap intended to raise the difficulty bar. But it's still worth doing. I lock the front door of my house, too. Right after I activate my nuclear-powered laser attack robots.
</p>
<p>
I believe it's best to err on the side of transparency. That buys you a lot more in the long run. You'll want to leverage basic "locking the front door" efforts, such as obfuscation, to keep cracking your licensing code from being a trivial one-click operation. But don't expend a lot of additional effort on protecting your code-- <a href="http://www.harper.no/valery/PermaLink,guid,0f90cf89-2689-4b7f-8d50-84c964795f3e.aspx">all client-side protection mechanisms are vulnerable by definition</a>. Instead, keep improving and refining your code. <b>You're a lot more likely to beat would-be pirates through frequent, meaningful updates than you are by bothering your customers with increasingly onerous security measures.</b>
</p>
<p>
One alternate solution is to write code in languages that are already obfuscated*, as demonstrated in the <a href="http://www0.us.ioccc.org/main.html">International Obfuscated C Code Contest</a>.  Here are two <a href="http://www0.us.ioccc.org/years.html">winning entries</a> from 2004. Note that this is actual source code you're viewing!
</p>
<p>
<a href="http://www0.us.ioccc.org/2004/arachnid.c"><img border="0" class="at-xid-6a0120a85dcdae970b0128776fb6ad970c" height="201" src="https://blog.codinghorror.com/content/images/uploads/2005/05/6a0120a85dcdae970b0128776fb6ad970c-pi.gif" width="160"></a>
 
<a href="http://www0.us.ioccc.org/2004/omoikane.c"><img border="0" class="at-xid-6a0120a85dcdae970b0128776fb6c7970c" height="201" src="https://blog.codinghorror.com/content/images/uploads/2005/05/6a0120a85dcdae970b0128776fb6c7970c-pi.gif" width="160"></a>
</p>
<p>
Or, for ultimate obfuscation, you can opt to write all your code in <a href="http://compsoc.dur.ac.uk/whitespace/">whitespace language</a>.
</p>
<p>
* I kid! Or <a href="http://www.codinghorror.com/blog/archives/000214.html">maybe not</a>.
</p>
<p>
</p>
<p></p>
<!--kg-card-end: markdown-->
            </content>
<pubDate>2005-05-15T12:00:00.000Z</pubDate>
<guid>https://blog.codinghorror.com/obfuscating-code/</guid>
</item>
</channel>
</rss>
