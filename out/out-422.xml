<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0">
<channel>
<title>Coding Horror</title>
<description>programming and human factors</description>
<link>https://blog.codinghorror.com/</link>
<pubDate>Sun, 19 Apr 2020 00:00:01 GMT</pubDate>
<!-- other elements omitted from this example -->
<item>
<title>There Ain't No Such Thing as the Fastest Code</title>
<link>https://blog.codinghorror.com/there-aint-no-such-thing-as-the-fastest-code/</link>
<content>
                <!--kg-card-begin: markdown--><p>
I was tickled to see that James Hague chose <a href="http://www.amazon.com/exec/obidos/ASIN/0673386023/codihorr-20">The Zen of Assembly Language Programming</a> as one of <a href="http://prog21.dadgum.com/19.html">five memorable books about programming</a>. I wholeheartedly agree. Even if you <b>never plan to touch a lick of assembly code in your entire professional career</b>, this book is a fantastic and thoroughly useful read. I was a mere <i>Visual Basic</i> programmer when I found this book (along with <a href="http://www.amazon.com/exec/obidos/ASIN/1883577039/codihorr-20">The Zen of Code Optimization</a>), picked it up on a lark, and I could barely put it down. It's that good.
</p>
<p>
Abrash isn't just <a href="http://en.wikipedia.org/wiki/Michael_Abrash">a seminal figure in the software engineering community</a>, he's also one of the best technical writers you'll ever find. That's why <a href="http://www.codinghorror.com/blog/archives/000234.html">he's one of my programming heroes</a>, directly alongside Steve McConnell.
</p>
<p>
His <a href="http://www.amazon.com/exec/obidos/ASIN/1576101746/codihorr-20">Graphics Programming Black Book</a> is similarly great, and covers topics so general and wide ranging that the title becomes a bit of a misnomer. Best of all, it's <a href="http://www.byte.com/abrash/">available online for free courtesy of Byte</a>, so you can sample it yourself.
</p>
<p>
<a href="http://www.byte.com/abrash/"><img alt="Michael Abrash's Graphics Programming Black Book" border="0" class="at-xid-6a0120a85dcdae970b0120a86dc32d970b" height="475" src="https://blog.codinghorror.com/content/images/uploads/2008/02/6a0120a85dcdae970b0120a86dc32d970b-pi.png" width="380"></a>
</p>
<p>
I know what you're thinking. "This book is about graphics. And assembly language. Plus it's from, like, 1996, which is approximately 1928 in computer years. It's of no interest to me as a programmer." Admit it. You are. But you know what you're going to do? You're going to click through anyway and read some of it. Just like in college, <b>the class topic doesn't matter when the instructor is a brilliant teacher</b>. And that's exactly what Abrash is.
</p>
<p>
Abrash is a world class coder and technical writer, but he's also not shy about explaining the perils and dangers of our craft, including <b>the biggest problem of all-- the one that sits behind the keyboard</b>. Allow me to illustrate with one of my very favorite Abrash passages, from Chapter 16 of the <a href="http://www.byte.com/abrash/">Graphics Programming Black Book</a>.
</p>
<p>
</p>
<blockquote>
Not so long ago, Terje Mathisen, who I introduced earlier in this book, wrote a very fast word-counting program, and posted it on <a href="http://en.wikipedia.org/wiki/Byte_Information_Exchange">BIX</a>. When I say it was fast, I mean <i>fast</i>; this code was optimized like nobody's business. We're talking top-quality code here.
<p>
When the topic of optimizing came up in one of the BIX conferences, Terje's program was mentioned, and he posted the following message: "I challenge BIXens (and especially mabrash!) to speed it up significantly. I would consider 5 percent a good result." The clear implication was, "That code is as fast as it can possibly be."
</p>
<p>
Naturally, it wasn't; there ain't no such thing as the fastest code (TANSTATFC? I agree, it doesn't have the ring of TANSTAAFL).
</p>
<p>
[assembly language tricks and useful optimization approaches elided -- <a href="http://www.byte.com/abrash/chapters/gpbb16.pdf">see PDF</a> for full detail]
</p>
<p>
The biggest optimization barrier that Terje faced was that <b>he thought he had the fastest code possible</b>. Once he opened up the possibility that there were faster approaches, and looked beyond the specific approach that he had so carefully optimized, he was able to come up with code that was a lot faster. Consider the incongruity of Terje's willingness to consider a 5 percent speedup significant in light of his later <b>near-doubling of performance</b>.
</p>
</blockquote>
<p>
In the same chapter, Mr. Abrash relates a similar anecdote based on a word counting program. It was published as a challenge in his "Pushing the Envelope" column:
</p>
<p>
</p>
<blockquote>
That initial challenge was sparked by a column David Gerrold wrote concerning the matter of counting the number of words in a document; David turned up some pretty interesting optimization issues along the way. David did all his coding in Pascal, pointing out that while an assembly language version would probably be faster, his Pascal utility worked properly and was fast enough for him.
<p>
It wasn't, however, fast enough for me. The logical starting place for speeding up word counting would be David's original Pascal code, but I'm much more comfortable with C, [so I created] a loose approximation of David's word count program, translated to C.
</p>
</blockquote>
<p>
Mike proceeds to do what he does best-- optimize the word count program into assembly and explain along the way in an easy going, highly articulate way. His results are as follows:
</p>
<p>
</p>
<table cellpadding="4" cellspacing="4" width="450">
<tr>
<td>C conversion</td>
<td>4.6 sec</td>
</tr>
<tr>
<td>C + assembly conversion</td>
<td>2.4 sec</td>
</tr>
<tr>
<td>C + assembly conversion with lookup table</td>
<td>1.6 sec</td>
</tr>
</table>
<p>
He then posted his program as a challenge for readers of PC Techniques-- <b>can this optimized assembly word count program, from an acclaimed industry expert on assembly optimization, be made even <i>faster</i>?</b> Well, I think you can guess what happened next.
</p>
<p>
</p>
<blockquote>
So how did the entrants in this particular challenge stack up? More than one claimed a speed-up over my assembly word-counting code of more than three times. On top of the three-times speedup over the original C code that I had already realized, we're almost up to <b>an order of magnitude faster</b>. You are, of course, entitled to your own opinion, but <i>I</i> consider an order of magnitude to be significant.
<p>
Truth to tell, I didn't expect a three-times speedup; around two times was what I had in mind. Which just goes to show that any code can be made faster than you'd expect, if you think about it long enough and from many different perspectives.
</p>
</blockquote>
<p>
Like Mike said, <i>there ain't no such thing as the fastest code</i>. If you think there is, <i>you're</i> probably the barrier standing in the way of further performance, not the code itself.
</p>
<p>
</p>
<p></p>
<!--kg-card-end: markdown-->
            </content>
<pubDate>2008-02-19T12:00:00.000Z</pubDate>
<guid>https://blog.codinghorror.com/there-aint-no-such-thing-as-the-fastest-code/</guid>
</item>
</channel>
</rss>
