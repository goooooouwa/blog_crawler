<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0">
<channel>
<title>Coding Horror</title>
<description>programming and human factors</description>
<link>https://blog.codinghorror.com/</link>
<pubDate>Sun, 19 Apr 2020 00:00:01 GMT</pubDate>
<!-- other elements omitted from this example -->
<item>
<title>Understanding Model-View-Controller</title>
<link>https://blog.codinghorror.com/understanding-model-view-controller/</link>
<content>
                <!--kg-card-begin: markdown--><p>
Like everything else in software engineering, it seems, the concept of <a href="http://en.wikipedia.org/wiki/Model-view-controller">Model-View-Controller</a> was originally invented by <a href="http://en.wikipedia.org/wiki/Smalltalk">Smalltalk</a> programmers.
</p>
<p>
More specifically, it was invented by one Smalltalk programmer, Trygve Reenskaug. Trygve maintains a page that <a href="http://heim.ifi.uio.no/~trygver/themes/mvc/mvc-index.html">explains the history of MVC</a> in his own words. He arrives at these definitions in a paper he published on December 10th, 1979:
</p>
<p>
</p>
<ol>
<li>
<b>Models</b>
<p>
Models represent knowledge. A model could be a single object (rather uninteresting), or it could be some structure of objects.
</p>
<p>
There should be a one-to-one correspondence between the model and its parts on the one hand, and the represented world as perceived by the owner of the model on the other hand.
</p>
<p>
</p>
</li>
<li>
<b>Views</b>
<p>
A view is a (visual) representation of its model. It would ordinarily highlight certain attributes of the model and suppress others. It is thus acting as a <i>presentation filter</i>.
</p>
<p>
A view is attached to its model (or model part) and gets the data necessary for the presentation from the model by asking questions. It may also update the model by sending appropriate messages. All these questions and messages have to be in the terminology of the model, the view will therefore have to know the semantics of the attributes of the model it represents.
</p>
<p>
</p>
</li>
<li>
<b>Controllers</b>
<p>
A controller is the link between a user and the system. It provides the user with input by arranging for relevant views to present themselves in appropriate places on the screen. It provides means for user output by presenting the user with menus or other means of giving commands and data. The controller receives such user output, translates it into the appropriate messages and pass these messages on to one or more of the views.
</p>
</li>
</ol>
<p>
It may seem like we're <a href="http://www.codinghorror.com/blog/archives/000165.html">deep in Architecture Astronaut territory</a> now, but bear with me. The MVC concepts are a little abstract, it's true, but it's an incredibly common pattern. It is literally all around you. In fact, let me bring it back down to Earth this way: you're looking at MVC <i>right now</i>.
</p>
<p>
</p>
<table cellpadding="4" cellspacing="4">
<tr>
<td>
<b>Model</b> = HTML</td>
<td>
<b>View</b> = CSS</td>
<td>
<b>Controller</b> = Browser</td>
</tr>
<tr>
<td><a href="http://www.codinghorror.com/blog/archives/000474.html"><img alt="MVC: HTML = Model" border="0" class="at-xid-6a0120a85dcdae970b012877703fa2970c" height="276" src="https://blog.codinghorror.com/content/images/uploads/2008/05/6a0120a85dcdae970b012877703fa2970c-pi.png" width="226"></a></td>
<td>
<a href="http://www.codinghorror.com/blog/archives/000474.html"><img alt="MVC: CSS = View" border="0" class="at-xid-6a0120a85dcdae970b012877703fa6970c" height="276" src="https://blog.codinghorror.com/content/images/uploads/2008/05/6a0120a85dcdae970b012877703fa6970c-pi.png" width="226"></a>
</td>
<td>
<a href="http://www.codinghorror.com/blog/archives/000474.html"><img alt="MVC: Browser = Controller" border="0" class="at-xid-6a0120a85dcdae970b012877703faa970c" height="276" src="https://blog.codinghorror.com/content/images/uploads/2008/05/6a0120a85dcdae970b012877703faa970c-pi.png" width="226"></a>
</td>
</tr>
</table>
<p>
This ubiquitous trifecta represents MVC almost perfectly.
</p>
<p>
</p>
<ol>
<li>Model
<p>
The HTML is the "skeleton" of bedrock content. Text that communicates information to the reader.
</p>
<p>
</p>
</li>
<li>View
<p>
The CSS adds visual style to the content. It is the "skin" that we use to flesh out our skeleton and give it a particular look. We can swap in different skins via CSS without altering the original content in any way. They are relatively, but not completely, independent.
</p>
<p>
</p>
</li>
<li>Controller
<p>
The browser is responsible for combining and rendering the CSS and HTML into a set of final, manipulatible pixels on the screen. It gathers input from the user and marshals it to any JavaScript code necessary for the page to function. But here, too, we have flexibility: we can plug in a different brower and get comparable results. Some browsers might render it faster, or with more fidelity, or with more bells and whistles.
</p>
</li>
</ol>
<p>
So if you believe the web has been at all successful -- most signs I've seen point to <i>yes</i> -- then you also have to acknowledge <b>the incredible power of Model-View-Controller.</b>
</p>
<p>
It's no coincidence that many of the most popular web programming frameworks also <a href="http://en.wikipedia.org/wiki/Model-view-controller#Implementations_of_MVC_as_web-based_frameworks">encapsulate MVC principles</a>: Django, Ruby on Rails, CakePHP, Struts, and so forth.  It's also officially creeping into ASP.NET under the fledgling <a href="http://www.asp.net/mvc/">ASP.NET MVC project</a>.
</p>
<p>
Just take a gander at the project layout in a <b>sample ASP.NET MVC project</b>:
</p>
<p>
<img alt="ASP.NET MVC project organization" border="0" class="at-xid-6a0120a85dcdae970b012877703fb0970c" height="433" src="https://blog.codinghorror.com/content/images/uploads/2008/05/6a0120a85dcdae970b012877703fb0970c-pi.png" width="226">
</p>
<p>
It's <i>almost</i> self-explanatory, if you've ever built an application of any kind:
</p>
<p>
</p>
<ol>
<li>Model
<p>
The classes which are used to store and manipulate state, typically in a database of some kind.
</p>
<p>
</p>
</li>
<li>View
<p>
The user interface bits (in this case, HTML) necessary to render the model to the user.
</p>
<p>
</p>
</li>
<li>Controller
<p>
The brains of the application. The controller decides what the user's input was, how the model needs to change as a result of that input, and which resulting view should be used.
</p>
</li>
</ol>
<p>
It's beautiful in its simplicity, <a href="http://www.artima.com/lejava/articles/stringtemplate.html">as Terence Parr notes</a>:
</p>
<p>
</p>
<blockquote>
For the "MVC" of a web app, I make a direct analogy with the Smalltalk notion of MVC. The model is any of the logic or the database or any of the data itself. The view is simply how you lay the data out, how it is displayed. If you want a subset of some data, for example, my opinion is that is a responsibility of the model. The model knows how to make a subset. You should not be asking your graphics designer to filter a list according to age or some other criteria.
<p>
The controller in a web app is a bit more complicated, because it has two parts. The first part is the web server (such as a servlet container) that maps incoming HTTP URL requests to a particular handler for that request. The second part is those handlers themselves, which are in fact often called "controllers." So the C in a web app MVC includes both the web server "overlord" that routes requests to handlers and the logic of those handlers themselves, which pull the data from the database and push it into the template. This controller also receives HTTP POST requests and processes these, sometimes updating the database.
</p>
<p>
I look at a website as nothing but a graph with edges with POSTs and GETs that routes pages.
</p>
</blockquote>
<p>
Here's one quick way to test if your application has properly segregated itself between the Model, View, and Controller roles: <b>is your app skinnable?</b>
</p>
<p>
</p>
<blockquote>
My experience is that designers don't understand loops or any kind of state. They do understand templates with holes in them. Everybody understands mail merge. And if you say, "Apply the bold template to this hole," they kind of get that, too. So separating model and view addresses this very important practical problem of how to have designers work with coders.
<p>
The other problem is there is no way to do multiple site skins properly if you don't have proper separation of concerns. If you are doing code generation or sites with different skins on them, there is no way to properly make a new skin by simply copying and pasting the old skin and changing it. If you have the view and the logic together, when you make a copy of the view you copy the logic as well. That breaks one of our primary rules as developers: have only one place to change anything.
</p>
</blockquote>
<p>
<b>Skinnability cuts to the very heart of the MVC pattern.</b> If your app <i>isn't</i> "skinnable", that means you've probably gotten your model's chocolate in your view's peanut butter, quite by accident. You should refactor your code so that only the controller is responsible for poking the model data through the relatively static templates represented by the view.
</p>
<p>
The power and simplicity of properly implemented MVC is undeniable. But the first step to harnessing MVC is to understand <i>why</i> it works, both on the web, and also within your own applications.
</p>
<p>
</p>
<p></p>
<!--kg-card-end: markdown-->
            </content>
<pubDate>2008-05-05T12:00:00.000Z</pubDate>
<guid>https://blog.codinghorror.com/understanding-model-view-controller/</guid>
</item>
</channel>
</rss>
