<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0">
<channel>
<title>Coding Horror</title>
<description>programming and human factors</description>
<link>https://blog.codinghorror.com/</link>
<pubDate>Sun, 19 Apr 2020 00:00:01 GMT</pubDate>
<!-- other elements omitted from this example -->
<item>
<title>The Computer Performance Shell Game</title>
<link>https://blog.codinghorror.com/the-computer-performance-shell-game/</link>
<content>
                <!--kg-card-begin: markdown--><p>The performance of any computer is akin to a <a href="http://en.wikipedia.org/wiki/Shell_game">shell game</a>.</p>
<img alt="shell game" border="0" class="at-xid-6a0120a85dcdae970b0120a86e0db8970b" height="342" src="https://blog.codinghorror.com/content/images/uploads/2009/03/6a0120a85dcdae970b0120a86e0db8970b-pi.jpg" width="512">
<p>The <b>computer performance shell game</b>, also known as "find the bottleneck", is always played between these four resources:</p>
<ul>
<li>CPU</li>
<li>Disk</li>
<li>Network</li>
<li>Memory</li>
</ul>
<p>At any given moment, your computer is waiting for some operation to complete on one of these resources. <b>But which one: CPU, memory, disk, or network?</b> If you're interested in performance, the absolute first thing you have to do is determine which of these bottlenecks is currently impeding performance – and <i>eliminate it</i>. At which point the bottleneck often shifts to some other part of the system, far too rapidly for your eye to see. Just like a real shell game.</p>
<p>So the art of performance monitoring is, first and foremost, getting your computer to tell you what's going on in each of these areas – so you can make your best guess where the pea is right now.</p>
<p>My previous performance drug of choice was <a href="http://www.codinghorror.com/blog/archives/000393.html">Task Manager</a>, or its vastly more sophisticated bigger brother, <a href="http://www.codinghorror.com/blog/archives/000162.html">Process Explorer</a>. But now that I've discovered the <a href="http://www.winsupersite.com/showcase/winvista_ff_rmon.asp">Reliability and Performance Monitor</a>, I <i>can't stop watching it</i>. It is my crystal meth. While the previous tools were solid enough, they both had one glaring flaw. <b>They only showed CPU load and memory usage.</b> Those are frequently performance bottlenecks, to be sure, but they're only part of the story.</p>
<p>The <b>Reliability and Performance Monitoring tool</b>, while continuing the fine Microsoft product tradition of absolutely freaking horrible names, is new to Windows Vista and Windows Server 2008. And it rocks.</p>
<img alt="reliability-and-performance-monitor-overview" border="0" class="at-xid-6a0120a85dcdae970b0120a86e0dd8970b" height="173" src="https://blog.codinghorror.com/content/images/uploads/2009/03/6a0120a85dcdae970b0120a86e0dd8970b-pi.png" width="672">
<p>Right off the bat you get a nice summary of what's going on in your computer performance shell game, with an overview graph and high water marks for CPU, Disk, Network, and Memory, along with scaled numbers. Eyeball this one key set of graphs and you can usually get a pretty good idea which part of your computer is working overtime.</p>
<p>There are also collapsible detail sections for each graph. On these detail sections, bear in mind the numbers are all live, and the default sort orders tend to bring the most active things to the top. And they <i>stay</i> at the top until they're no longer using that resource, at which point they disappear. The detail sections are a quick way to drill down into each resource and see what programs and processes are monopolizing it at any given time.</p>
<p>The <b>CPU detail section</b> gives you a moving average of CPU usage, which is much saner than Task Manager's always shifting numbers. Admittedly, this section isn't radically different than taskman – and it's functionally identical to <a href="http://en.wikipedia.org/wiki/Top_(Unix)">the Unix <code>top</code> command</a>. But the moving average alone is surprisingly helpful in avoiding obsessing over rapid peaks and valleys.</p>
<img alt="Reliability and Performance Monitor, CPU detail" border="0" class="at-xid-6a0120a85dcdae970b0120a86e0df7970b" height="216" src="https://blog.codinghorror.com/content/images/uploads/2009/03/6a0120a85dcdae970b0120a86e0df7970b-pi.png" width="672">
<p>The <b>Disk detail section</b> shows which processes are reading and writing to disk, for what filenames/paths, and how long it's taking to service those requests – in real time. I generally alternate between read and write sort order here, although sometimes response time can be informative as well.</p>
<img alt="Reliability and Performance Monitor, disk detail" border="0" class="at-xid-6a0120a85dcdae970b0120a86e0e08970b" height="216" src="https://blog.codinghorror.com/content/images/uploads/2009/03/6a0120a85dcdae970b0120a86e0e08970b-pi.png" width="672">
<p>The <b>Network detail section</b> shows which processes are sending the most data over the network right now. On a public website, this gives you an at-a-glance breakdown of which IP addresses are hitting you the hardest. In fact, while checking this, I just laid down another IP ban for some random IP that was scraping the heck out of our site.</p>
<img alt="Reliability and Performance Monitor, network detail" border="0" class="at-xid-6a0120a85dcdae970b0120a86e0e17970b" height="216" src="https://blog.codinghorror.com/content/images/uploads/2009/03/6a0120a85dcdae970b0120a86e0e17970b-pi.png" width="672">
<p>The <b>Memory detail section</b> shows the five most essential metrics for memory usage in real time. Hard Faults are, of course, forced reads from disk into memory – something you want to keep a close eye on. And Working Set is the best general indicator of how much memory a process is actively using to do its thing.</p>
<img alt="Reliability and Performance Monitor, network detail" border="0" class="at-xid-6a0120a85dcdae970b0120a86e0e25970b" height="216" src="https://blog.codinghorror.com/content/images/uploads/2009/03/6a0120a85dcdae970b0120a86e0e25970b-pi.png" width="672">
<p>The computer performance shell game is nothing new; it is as old as computing itself. And it is a deeply satisfying game for <a href="http://www.codinghorror.com/blog/archives/000761.html">those of us who love this stuff</a>.</p>
<p>I <i>thought</i> I knew how to play it, until I discovered the Reliability and Performance Monitor. Now that I have a utility like this to let me suss out exactly where that performance pea is, I realize how much I was missing.</p>
<p>Now, on to <a href="http://en.wikipedia.org/wiki/Three-card_Monte">three card monte</a>. Watch my hands closely!</p>
<!--kg-card-end: markdown-->
            </content>
<pubDate>2009-03-09T13:00:00.000Z</pubDate>
<guid>https://blog.codinghorror.com/the-computer-performance-shell-game/</guid>
</item>
</channel>
</rss>
