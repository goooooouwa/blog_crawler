<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0">
<channel>
<title>Coding Horror</title>
<description>programming and human factors</description>
<link>https://blog.codinghorror.com/</link>
<pubDate>Sun, 19 Apr 2020 00:00:01 GMT</pubDate>
<!-- other elements omitted from this example -->
<item>
<title>Good Programmers Get Off Their Butts</title>
<link>https://blog.codinghorror.com/good-programmers-get-off-their-butts/</link>
<content>
                <!--kg-card-begin: markdown--><p>I searched for this citation, and <a href="https://web.archive.org/web/20050308004714/http://wesnerm.blogs.com/net_undocumented/2004/01/fire_and_motion.html">like Wes</a>, I remember reading it, but I can't remember the exact place I read it:</p>
<blockquote>
<p>This echoes another comment from a recently read blog article, the author of which I cannot recall. <b>Good programmers get off their butts.</b> Typically, programmers won't write code until they have resolved some design issues, but in the process time can go by with very little advancement in the design. Productive developers will write some code, even if the design is vague, because software development is an iterative process.</p>
</blockquote>
<p>I have lost count of the number of times I've set out to design software, then during implementation had to throw out or radically alter my design, because..</p>
<ul>
<li>I forgot something really important</li>
<li>I found another, easier approach</li>
<li>What I'm doing doesn't make sense</li>
<li>I am reinventing the wheel, and should be looking for a download</li>
<li>Hey, I don't even need to do this in the first place!</li>
</ul>
<p>In the real world, there's a tight feedback loop between the implementation and the design. When you're using Photoshop as a design tool, all things are possible. Visual Studio, unfortunately, isn't that forgiving.</p>
<p>I am not proposing a code-like-hell methodology. I am merely observing that, in my experience, <b>coding without planning is just as futile as coding with too much planning</b>. Software development is <a href="https://discourse.codinghorror.com/t/development-is-inherently-wicked/1320">a wicked problem</a>; you should never make planning decisions without some kind of code prototype to ensure that you're making informed decisions. If you plan too far ahead of the code, I <em>guarantee</em> you are doing work that will be thrown away or altered until it is unrecognizable.</p>
<p>The most destructive symptom of over-planning is the wrongheaded idea that being a Software Architect™ means drawing a lot of UML diagrams and handing them off to a group of developers in Bangalore. <b>UML is great if you don't want to do any work; you just draw pictures of what it would look like if work was actually done.</b> This is not only borderline laziness, it's also a recipe for disaster. You can't architect a real world application on a whiteboard. You must prototype it in code to gather data on the performance and design implications of the choices you are making. Otherwise you really have no idea if you're creating something that makes sense – or if it's even possible! As noted in Robert Glass' <a href="http://www.amazon.com/exec/obidos/ASIN/0321117425/codihorr-20">Facts and Fallacies of Software Engineering</a>, in software design, being hands on is mandatory:</p>
<blockquote>
Far from being a predictable, structurable, routinizable process, design – according to the findings of Curtis and Soloway (1987) – is a messy, trial-and-error thing. And remember, these findings are the result of studying top designers at work. One can imagine less than top designers using an even messier process. Probably the worst possible design approach, and yet one that is tempting to most design novices, is "easy-part-first." Although it is easy to get the design process started with this approach, it all too often leads to solutions-in-the-small that won't integrate into an overall solution-in-the-large. As a result, those solutions-in-the-small must often be discarded.
<p>It is easy to see from all of this that design is complex and iterative. (This thought is explicit in Wiegers [1996].) In fact, it is probably the most deeply intellectual activity of the software development process. It is also easy to see that the initial design solution is quite likely to be wrong. And what about optimal? Well, certainly initial design solutions will rarely be optimal. But that word raises another interesting question – is there such a thing as an optimal design solution?</p>
</blockquote>
<p>As software developers – and <em>especially</em> if we have <a href="https://blog.codinghorror.com/it-came-from-planet-architecture/">pretensions of being so-called "architects"</a> – we should always make decisions based on experience and data. And like it or not, that means <b>getting off our butts and writing code</b>.</p>
<!--kg-card-end: markdown-->
            </content>
<pubDate>2004-11-21T12:00:00.000Z</pubDate>
<guid>https://blog.codinghorror.com/good-programmers-get-off-their-butts/</guid>
</item>
</channel>
</rss>
