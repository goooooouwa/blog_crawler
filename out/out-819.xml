<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0">
<channel>
<title>Coding Horror</title>
<description>programming and human factors</description>
<link>https://blog.codinghorror.com/</link>
<pubDate>Sun, 19 Apr 2020 00:00:01 GMT</pubDate>
<!-- other elements omitted from this example -->
<item>
<title>Diseconomies of Scale and Lines of Code</title>
<link>https://blog.codinghorror.com/diseconomies-of-scale-and-lines-of-code/</link>
<content>
                <!--kg-card-begin: markdown--><p>
Steve McConnell on <a href="http://www.amazon.com/exec/obidos/ASIN/0735605351/codihorr-20">diseconomies of scale in software development</a>:
</p>
<p>
</p>
<blockquote>
<b>Project size is easily the most significant determinant of effort, cost and schedule [for a software project].</b>*
<p>
People naturally assume that a system that is 10 times as large as another system will require something like 10 times as much effort to build. But the effort for a 1,000,000 LOC system is <i>more</i> than 10 times as large as the effort for a 100,000 LOC system.
</p>
<p>
[Using software industry productivity averages], the 10,000 LOC system would require 13.5 staff months. If effort increased linearly, a 100,000 LOC system would require 135 staff months. But it actually requires 170 staff months.
</p>
</blockquote>
<p>
Here's the single most important decision you can make on your software project if you want it to be successful: <i>keep it small.</i> Small may not accomplish much, but the odds of outright failure-- a <a href="http://www.codinghorror.com/blog/archives/000588.html">disturbingly common outcome for most software projects</a>-- is low.
</p>
<p>
I don't think the inverted, non-linear relationship between size and productivity on software projects will come as a shock to anyone; the guys at 37signals have been <a href="http://37signals.com/svn/archives2/when_big_groups_really_want_to_get_things_done_they_make_the_group_smaller.php">banging</a> <a href="http://37signals.com/svn/archives2/edward_hall_the_perfect_group_size_812.php">their</a> <a href="http://37signals.com/svn/archives2/the_disease_of_giants.php">drum</a> on the virtues of small for over a year now. Isn't <a href="http://sethgodin.typepad.com/seths_blog/2005/06/small_is_the_ne.html">small the new big</a> already?
</p>
<p>
But what I really want to focus on here is <b>how you measure a project's size</b>. What's big? What's small? McConnell is using lines of code (LOC) as his go-to measurement. Here's a table that illustrates the relationship between project size and productivity:
</p>
<p>
</p>
<table width="600">
<tr>
<td>Project Size</td>
<td>Lines of code (per year)</td>
<td>COCOMO average
</td>
</tr>
<tr>
<td>10,000 LOC</td>
<td>2,000 - 25,000</td>
<td>3,200
</td>
</tr>
<tr>
<td>100,000 LOC</td>
<td>1,000 - 20,000</td>
<td>2,600
</td>
</tr>
<tr>
<td>1,000,000 LOC</td>
<td>700 - 10,000</td>
<td>2,000
</td>
</tr>
<tr>
<td>10,000,000 LOC</td>
<td>300 - 5,000</td>
<td>1,600
</td>
</tr>
</table>
<p>
Lines of code is a reasonable metric to determine project size, but it also has some problems, which are well-documented in the <a href="http://en.wikipedia.org/wiki/Source_lines_of_code">wikipedia entry on lines of code</a>:
</p>
<p>
</p>
<pre>
/* How many lines of code is this? */
for (i=0; i&lt;100; ++i) printf("hello");
</pre>
<p>
For one thing, different languages vary widely in the number of lines of code they produce. 100 lines of Perl will probably accomplish a lot more than 100 lines of C. So you have to be careful that you're really comparing apples to apples.  Furthermore, skilled developers know that the less code you write, the fewer bugs you've created-- so they naturally distrust any productivity metric that weights absolute lines of code. And does code generation count?
</p>
<p>
Even with all its problems, the LOC metric is still where you should start, according to McConnell:
</p>
<p>
</p>
<blockquote>
My personal conclusion about using lines of code for software estimation is similar to Winston Churchill's conclusion about democracy: <b>The LOC measure is a terrible way to measure software size, except that all the other ways to measure size are worse.</b> For most organizations, despite its problems, the LOC measure is the workhorse technique for measuring size of past projects and for creating early-in-the-project estimates of new projects. The LOC measure is the <i>lingua franca</i> of software estimation, and it is normally a good place to start, as long as you keep its limitations in mind.
<p>
Your environment might be different enough from the common programming environments that lines of code are not highly correlated with project size. If that's true, find something that is more proportional to effort, count that, and base your size estimates on that instead. Try to find something that's easy to count, highly correlated with effort, and meaningful for use across multiple projects.
</p>
</blockquote>
<p>
The <a href="http://en.wikipedia.org/wiki/Source_lines_of_code">wikipedia article</a> features this chart of Windows operating system size, in lines of code, over time:
</p>
<p>
</p>
<table width="600">
<tr>
<td>1993</td>
<td>Windows NT 3.1</td>
<td>6 million
</td>
</tr>
<tr>
<td>1994</td>
<td>Windows NT 3.5</td>
<td>10 million
</td>
</tr>
<tr>
<td>1996</td>
<td>Windows NT 4.0</td>
<td>16 million
</td>
</tr>
<tr>
<td>2000</td>
<td>Windows 2000</td>
<td>29 million
</td>
</tr>
<tr>
<td>2002</td>
<td>Windows XP</td>
<td>40 million
</td>
</tr>
<tr>
<td>2007</td>
<td>Windows Vista</td>
<td>~50 million
</td>
</tr>
</table>
<p>
If you're wondering how much code the average programmer produces per day, I think you might be <a href="http://blogs.msdn.com/philipsu/archive/2006/06/14/631438.aspx">asking the wrong question</a>. Lines of code is certainly a key metric for determining project size, but it's also easily manipulated and misinterpreted. It should never be the only data point used to make decisions; it's just one of many signposts on the road that helps you orient your project.
</p>
<p>
* what are the other most significant determinants? Number two is the type of software you're developing, and personnel factors is a very close third.
</p>
<p>
</p>
<p></p>
<!--kg-card-end: markdown-->
            </content>
<pubDate>2006-07-17T12:00:00.000Z</pubDate>
<guid>https://blog.codinghorror.com/diseconomies-of-scale-and-lines-of-code/</guid>
</item>
</channel>
</rss>
