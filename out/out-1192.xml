<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0">
<channel>
<title>Coding Horror</title>
<description>programming and human factors</description>
<link>https://blog.codinghorror.com/</link>
<pubDate>Sun, 19 Apr 2020 00:00:01 GMT</pubDate>
<!-- other elements omitted from this example -->
<item>
<title>Are You There, God? It's Me, Microsoft.</title>
<link>https://blog.codinghorror.com/are-you-there-god-its-me-microsoft/</link>
<content>
                <!--kg-card-begin: markdown--><p>
<img align="right" alt="Religious Wars, image (c) 1993 Steve McConnell" class="at-xid-6a0120a85dcdae970b0128776fb815970c" height="283" src="https://blog.codinghorror.com/content/images/uploads/2005/03/6a0120a85dcdae970b0128776fb815970c-pi.gif" width="247">
Although you eventually outgrow them, any developer worth his or her salt bears the scars of a thousand tiny religious wars. It's an occupational hazard, as Steve McConnell notes in <a href="http://www.amazon.com/exec/obidos/ASIN/0735619670/codihorr-20">Thou Shalt Rend Software and Religon Asunder</a>:
</p>
<p>
</p>
<blockquote>
Religion appears in software development in numerous incarnations-- as dogmatic adherence to a single design method, as unswerving belief in a specific formatting or commenting style, or as a zealous avoidance of global data. Whatever the case, it's always inappropriate.
<p>
Blind faith in one method precludes the selectivity you need if you're to find the most effective solutions to programming problems. If software development were a deterministic, algorithmic process, you could follow a rigid methodology to your solution. But software development isn't a deterministic process; it's heuristic, which means that rigid processes are inappropriate and have little hope of success. In design, for example, sometimes top-down decomposition works well. Sometimes an object-oriented approach, a bottom-up composition, or a data-structure approach works better. You have to be willing to try several approaches, knowing that some will fail and some will succeed but not knowing which ones will work until after you try them. You have to be eclectic.
</p>
</blockquote>
<p>
I think it's great that we are passionate enough about what we do to have these kinds of discussions. As long as everyone <b>retains their sense of humor</b>. However, I can't imagine the fire and brimstone that results when you mix software religion with.. that old time religion, <a href="http://www.leaveitbehind.com/home/2005/03/why_switch.html">as FellowshipChurch.com has</a>:
</p>
<p>
</p>
<blockquote>
Microsoft continues to improve in this area, and there is always a new version just around the corner that will make everything better, but this is a fact of life. Microsoft products, from the server to the development environment, will inexplicably stop working with no outside interference. Each of our development machines begs to be rebuilt after six months of use. Servers that haven't been rebooted for a couple of weeks begin to have issues. Code that has worked for months stops working for no apparent reason.
<p>
I built a number of Linux servers a couple of years ago and nine months later I had to be reminded that they existed as they hadn't been touched or rebooted since they went live.
</p>
</blockquote>
<p>
<a href="http://www.codinghorror.com/blog/sounds/could_it_be_satan.mp3">Could it be.. <i>satan?</i></a>
</p>
<p>
</p>
<p></p>
<!--kg-card-end: markdown-->
            </content>
<pubDate>2005-03-24T12:00:00.000Z</pubDate>
<guid>https://blog.codinghorror.com/are-you-there-god-its-me-microsoft/</guid>
</item>
</channel>
</rss>
