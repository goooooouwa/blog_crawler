<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0">
<channel>
<title>Coding Horror</title>
<description>programming and human factors</description>
<link>https://blog.codinghorror.com/</link>
<pubDate>Sun, 19 Apr 2020 00:00:01 GMT</pubDate>
<!-- other elements omitted from this example -->
<item>
<title>Monkeypatching For Humans</title>
<link>https://blog.codinghorror.com/monkeypatching-for-humans/</link>
<content>
                <!--kg-card-begin: markdown--><p>
Although <a href="http://www.codinghorror.com/blog/archives/000634.html">I love strings</a>, sometimes the <code>String</code> class can break your heart. For example, in C#, there is no <code>String.Left()</code> function. Fair enough; we can roll up our sleeves and write our own function lickety-split:
</p>
<p>
</p>
<pre>
public static string Left(string s, int len)
{
if (len == 0 || s.Length == 0)
return "";
else if (s.Length &lt;= len)
return s;
else
return s.Substring(0, len);
}
</pre>
<p>
And call it like so:
</p>
<p>
</p>
<pre>
var s = "Supercalifragilisticexpialidocious";
s = Left(s, 5);
</pre>
<p>
Fairly painless, right?
</p>
<p>
But with the advent of C# 3.0, there's an even better way -- <a href="http://msdn.microsoft.com/en-us/library/bb383977.aspx">extension methods</a>. With an extension method, we "extend" the <code>String</code> to add the missing function. The code is fairly similar; I'll highlight the changed parts in red.
</p>
<p>
</p>
<pre>
public static string Left(<font color="red">this</font> string s, int len)
{
if (len == 0 || s.Length == 0)
return "";
else if (s.Length &lt;= len)
return s;
else
return s.Substring(0, len);
}
</pre>
<p>
And now we can call it <b>as if this very method existed on the String class as shipped</b>:
</p>
<p>
</p>
<pre>
var s = "Supercalifragilisticexpialidocious";
s = <font color="red">s.Left(5);</font>
</pre>
<p>
Pretty slick. It's difficult not to fall in love with extension methods, as they allow you to mold classes into exactly what you think they should be. This is fairly innocuous in C#, as <b>extension methods only allow you to add new functionality to classes</b>, not override, remove, or replace anything.
</p>
<p>
But imagine if you <i>could</i>.
</p>
<p>
Well, that's exactly how it is in other, more dynamic languages such as Javascript, Python, Perl, and Ruby. Something as prosaic as C# extensions is old hat to these folks. In those languages, <i>you could redefine everything in the <code>String</code> class if you wanted to</i>. This is commonly known in dynamic language circles as <a href="http://en.wikipedia.org/wiki/Monkey_patch">monkeypatching</a>.
</p>
<p>
<img alt="monkey patching" border="0" class="at-xid-6a0120a85dcdae970b0120a86ded41970b" height="354" src="https://blog.codinghorror.com/content/images/uploads/2008/07/6a0120a85dcdae970b0120a86ded41970b-pi.jpg" width="512">
</p>
<p>
If the idea of monkeypatching scares you a little, it probably should. Can you imagine debugging code where the <code>String</code> class had subtly different behaviors from the <code>String</code> you've learned to use? Monkeypatching <a href="http://avdi.org/devblog/2008/02/23/why-monkeypatching-is-destroying-ruby/">can be incredibly dangerous in the wrong hands</a>, as Avdi Grimm notes:
</p>
<p>
</p>
<blockquote>
Monkey patching is the new black [in the Ruby community].  It's what all the hip kids are doing.  To the point that smart, experienced hackers reach for a monkey patch as their tool of first resort, even when a simpler, more traditional solution is possible.
<p>
I don't believe this situation to be sustainable.  Where I work, <b>we are already seeing subtle, difficult-to-debug problems crop up as the result of monkey patching in plugins.</b> Patches interact in unpredictable, combinatoric ways.  And by their nature, bugs caused by monkey patches  are more difficult to track down than those introduced by more traditional classes and methods.  As just one example: on one project, it was a known caveat that we could not rely on class inheritable attributes as provided by ActiveSupport.  No one knew why.  Every Model we wrote had to use awkward workarounds.  Eventually we tracked it down in a plugin that generated admin consoles.  It was overwriting <code>Class.inherited()</code>.  It took us months to find this out.
</p>
<p>
This is just going to get worse if we don't do something about it.  And the "something" is going to have to be a cultural shift, not a technical fix.  I believe it is time for experienced Ruby programmers to wean ourselves off of monkey patching, and start demonstrating more robust techniques.
</p>
</blockquote>
<p>
Try to imagine a world where <b>every programmer you know is a wannabe language designer, bent on molding the language to their whims</b>. When I close my eyes and imagine it, I have a vision of the apocalypse, a perfect, pitch-black storm of utterly incomprhensible, pathologically difficult to debug code.
</p>
<p>
I was just looking at random PHP plugin code the other day, and it was, frankly, crap. But that's because <i>most code is crap</i>. <a href="http://www.codinghorror.com/blog/archives/000099.html">Including my own</a>. It is, sadly, the statistical norm. That's why <a href="http://www.codinghorror.com/blog/archives/000824.html">sites like The Daily WTF</a> are guaranteed to have more material than they can possibly ever publish for the next millennia. (Note to self: invest in this website). I can only imagine what that PHP plugin code would have looked like, had its developer been granted the ability to redefine fundamental PHP keywords and classes at will. These are the sort of thoughts that drive me to drink <a href="http://www.amazon.com/dp/B000NY30P0/?tag=codihorr-20">Bawls</a>. And that stuff is disgusting.
</p>
<p>
You might say that PHP, sans the fundamental dynamic language ability to monkeypatch, is <a href="http://weblog.raganwald.com/2006/10/are-we-blub-programmers.html">just another crappy Blub language</a>. But there's also a ton of <a href="http://www.codinghorror.com/blog/archives/001119.html">incredibly useful PHP code out there</a>. So it seems to me that the ability to monkeypatch doesn't stop people from producing a huge volume of useful code, even in a kind of.. horrible language. Some of it is even good!
</p>
<p>
While I acknowledge the power and utility of dynamic language monkeypatching, I know enough about programmers -- myself <i>absolutely</i> included -- to know the vast majority of us have absolutely no business whatsoever re-designing a programming language. There's a reason some of the <a href="http://en.wikipedia.org/wiki/Anders_Hejlsberg">most</a> <a href="http://en.wikipedia.org/wiki/John_McCarthy_%28computer_scientist%29">deeply</a> <a href="http://en.wikipedia.org/wiki/Dennis_Ritchie">respected</a> <a href="http://en.wikipedia.org/wiki/Guido_van_Rossum">computer</a> <a href="http://en.wikipedia.org/wiki/Niklaus_Wirth">scientists</a> in the world end up as language designers.
</p>
<p>
Perhaps then, given the risks, <b>monkeypatching should mean reaching for the meta-hammer as infrequently as humanly possible</b>. This is a position that Avdi himself espouses <a href="http://weblog.raganwald.com/2008/02/1100inject.html#8589089242300871488">in a followup comment</a>:
</p>
<p>
</p>
<blockquote>
I'm afraid a lot of people have missed the actual meat of my argument -- that dynamic extension of classes is currently overused in Ruby, in ways that are:
<p>
</p>
<ul>
<li>Needless - another technique (such as a mixin, or locally extending individual objects) would have worked as well or better.
</li>
<li>Overcomplicated - the use of a monkey patch actually created more work for the author.
</li>
<li>Fragile - the solution is tightly bound to third-party internals, reducing the usefulness of the plugin or gem because it is prone to breakage.
</li>
<li>Excessively wide in scope - by hardcoding extensions to core classes, the author takes the choice to scope the change out of the plugin/gem user's hands, further limiting utility.
</li>
</ul>
<p>
My point is that there are alternatives - often alternatives which are actually easier to implement and will make your plugin or gem more useful to the user.
</p>
</blockquote>
<p>
While I enjoy the additive nature of C# extensions, even those are enough to make me a little nervous, as mild as they are. Full-blown dynamic language monkeypatching goes even further; it might even be the ultimate expression of programming power. Is there anything more pure and godlike than <b>programming your own programming language?</b>
</p>
<p>
But if wielding that power doesn't scare and humble you a little, too, then maybe you should leave the monkeypatching to the <a href="http://www.paulgraham.com/langdes.html">really smart monkeys</a>.
</p>
<p>
</p>
<p></p>
<!--kg-card-end: markdown-->
            </content>
<pubDate>2008-07-12T12:00:00.000Z</pubDate>
<guid>https://blog.codinghorror.com/monkeypatching-for-humans/</guid>
</item>
</channel>
</rss>
