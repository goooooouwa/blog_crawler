<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0">
<channel>
<title>Coding Horror</title>
<description>programming and human factors</description>
<link>https://blog.codinghorror.com/</link>
<pubDate>Sun, 19 Apr 2020 00:00:01 GMT</pubDate>
<!-- other elements omitted from this example -->
<item>
<title>Respecting Abstraction</title>
<link>https://blog.codinghorror.com/respecting-abstraction/</link>
<content>
                <!--kg-card-begin: markdown--><p>
<img align="right" alt="Dagwood Sandwich" class="at-xid-6a0120a85dcdae970b0128776faf78970c" height="300" hspace="5" src="https://blog.codinghorror.com/content/images/uploads/2005/04/6a0120a85dcdae970b0128776faf78970c-pi.jpg" vspace="5" width="216">
In a recent post, Scott Koon proposes that to be a really good .NET programmer, <a href="http://www.lazycoder.com/weblog/archives/2005/04/26/bad-developers-are-made-not-learned/">you also need to be a really good C++ programmer</a>:
</p>
<p>
</p>
<blockquote><i>
If you've spent all your life working in a GC'ed language, why would you ever need to know how memory management works, let alone virtual memory? <a href="http://weblogs.asp.net/jgalloway/archive/2005/02/16/374212.aspx">Jon also says</a> it doesn't teach you to work with a framework. What's the STL? What about MFC? ATL? Carbon? All of those things use C++ as their base language. Notice I didn't say to take a C/C++ course at a university as I'm not convinced that a CS course will teach you everything you need to know in the real world. I said to learn C/C++ first because if you understand HOW things work, you'll have a better idea of how things DON'T work. How can you identify a memory leak in your managed application if you don't know how memory leaks come about or what a memory leak is?
</i></blockquote>
<p>
The problem I have with this position is that it breaks abstraction. The .NET framework abstracts away the details of pointers and memory management by design, to make development easier. But it's also a stretch to say that .NET developers have no idea what memory leaks are-- in the world of managed code, <b>memory management is an optimization, not a requirement</b>. It's an important distinction. You should only care when it makes sense to do so, whereas in C++ you are forced to worry about the minutia of detailed memory management even for the most trivial of applications. And if you get it wrong, either your app crashes, or you're open to buffer overrun exploits.
</p>
<p>
You may also be familiar with Joel's article on the <a href="http://www.joelonsoftware.com/articles/LeakyAbstractions.html">negative effects of leaky abstractions</a>. Bram has <a href="http://www.advogato.org/person/Bram/diary.html?start=43">a compelling response</a>:
</p>
<p>
</p>
<blockquote><i>
Joel Spolsky says
<blockquote>
All non-trivial abstractions, to some degree, are leaky.
</blockquote>
This is overly dogmatic - for example, bignum classes are exactly the same regardless of the native integer multiplication. Ignoring that, this statement is essentially true, but rather inane and missing the point. Without abstractions, all our code would be completely interdependent and unmaintainable, and abstractions do a remarkable job of cleaning that up. <b>It is a testament to the power of abstraction and how much we take it for granted that such a statement can be made at all, as if we always expected to be able to write large pieces of software in a maintainable manner. </b>
</i></blockquote>
<p>
It's amazing how far <a href="http://www-2.cs.cmu.edu/People/rgs/alice-I.html">down the rabbit hole</a> you can go following the many abstractions that we routinely rely on today. Eric Sink <a href="http://biztech.ericsink.com/Abstraction_Pile.html">documents the 46 layers of abstraction</a> that his product relies on. And Eric stops before we get to the real iron; Charles Petzold's excellent book <a href="http://www.amazon.com/exec/obidos/ASIN/0735611319/codihorr-20">Code: The Hidden Language of Computer Hardware and Software</a> goes even deeper. In other words, when Joel <a href="http://www.joelonsoftware.com/articles/LeakyAbstractions.html">says</a>:
</p>
<p>
</p>
<blockquote><i>
Today, to work on CityDesk, I need to know Visual Basic, COM, ATL, C++, InnoSetup, Internet Explorer internals, regular expressions, DOM, HTML, CSS, and XML. All high level tools compared to the old K&amp;R stuff, but I still have to know the K&amp;R stuff or I'm toast.
</i></blockquote>
<p>
What he's really saying is <b>without these abstractions, we'd all be toast</b>. While no abstraction is perfect-- you may need to dip your toes into layers below the Framework from time to time-- arguing that you must have detailed knowledge of the layer under the abstraction to be competent is counterproductive. While I don't deny that knowledge of the layers is critical for troubleshooting, we should <b>respect the abstractions</b> and spend most of our efforts fixing the leaks instead of bypassing them.
</p>
<p>
</p>
<p></p>
<!--kg-card-end: markdown-->
            </content>
<pubDate>2005-04-29T12:00:00.000Z</pubDate>
<guid>https://blog.codinghorror.com/respecting-abstraction/</guid>
</item>
</channel>
</rss>
