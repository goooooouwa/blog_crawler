<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0">
<channel>
<title>Coding Horror</title>
<description>programming and human factors</description>
<link>https://blog.codinghorror.com/</link>
<pubDate>Sun, 19 Apr 2020 00:00:01 GMT</pubDate>
<!-- other elements omitted from this example -->
<item>
<title>Real-Time Raytracing</title>
<link>https://blog.codinghorror.com/real-time-raytracing/</link>
<content>
                <!--kg-card-begin: markdown--><p>
Like many programmers, my first exposure to <a href="http://en.wikipedia.org/wiki/Ray_tracing">ray tracing</a> was on my venerable <a href="http://en.wikipedia.org/wiki/Amiga">Commodore Amiga</a>. It's an iconic system demo every Amiga user has seen at some point: <a href="http://home.comcast.net/~erniew/juggler.html">behold the robot juggling silver spheres!</a>
</p>
<p>
</p>
<blockquote>
Thus begins the article in the May/June 1987 AmigaWorld in which Eric Graham explains how the Juggler was created. The program ("with full Intuition interface") promised at the end of the article was <a href="http://en.wikipedia.org/wiki/Sculpt_3D">Sculpt 3D</a> for the Amiga, released in the fall of 1987. Byte by Byte sold Amiga and then Macintosh and Windows variants of Sculpt for more than a decade.
<p>
Eric rendered the frames in a raytracer he wrote called ssg, a Sculpt precursor. The rendered images were encoded in the Amiga's HAM display mode and then assembled into a single data file using a lossless delta compression scheme similar to the method that would later be adopted as the standard in the Amiga's ANIM file format.
</p>
<p>
Eric and his wife Cathryn actively promoted raytracing on the Amiga. Cathryn wrote the Amiga Sculpt 3D user manual and compiled an electronic newsletter distributed on a series of disks. Raytracing 1.0, the earliest of these, contains both ssg and the static geometry of the juggler object, along with the Juggler image data and the player program.
</p>
<p>
<a href="http://home.comcast.net/~erniew/getstuff/juggler.avi"><img alt="Amiga juggler raytracing animation" border="0" class="at-xid-6a0120a85dcdae970b0128777032aa970c" height="200" src="https://blog.codinghorror.com/content/images/uploads/2008/03/6a0120a85dcdae970b0128777032aa970c-pi.gif" width="320"></a>
</p>
<p>
Juggler was an astounding demo in its time. I personally remember staring at it for several minutes through the front window of a local Amiga dealer, wondering how it "worked." Many people were inspired by Juggler, and by the Amiga animations that followed, to pursue a career in 3D graphics. Nothing like it could have run on any other stock personal computer in 1986.
</p>
<p>
In fact, Eric recalled recently, the Commodore legal department initially "thought it was a hoax, and that I'd done the animation on a mainframe." He sent them his renderer so that they could generate and compile the frames themselves.
</p>
</blockquote>
<p>
The juggler may seem primitive by today's standards. Maybe it is. I've been subjected to forum signature images with more frames of animation. But it was revelatory back in 1986. <b>The Amiga brought 3D raytracing graphics to the masses for the first time</b>. Ray tracing is extremely computation intensive, but hyper-realistic. It's essentially calculating the result of every individual ray of light in a scene.
</p>
<p>
<img alt="ray tracing diagram" border="0" class="at-xid-6a0120a85dcdae970b0128777032c4970c" height="325" src="https://blog.codinghorror.com/content/images/uploads/2008/03/6a0120a85dcdae970b0128777032c4970c-pi.png" width="461">
</p>
<p>
Given the <a href="http://www.codinghorror.com/blog/archives/000741.html">explosion of computing power</a> in the 22 years since Juggler was released, you might think all 3D graphics would be rendered via ray tracing by now. To a certain extent, that <i>is</i> true; <a href="http://en.wikipedia.org/wiki/List_of_films_made_involving_PhotoRealistic_RenderMan">many computer animated films</a> are rendered through ray tracing techniques, such as Pixar's <a href="http://en.wikipedia.org/wiki/PhotoRealistic_RenderMan">PhotoRealistic RenderMan</a>.
</p>
<p>
<img alt="renderman example: scene from Finding Nemo" border="0" class="at-xid-6a0120a85dcdae970b0128777032e7970c" height="324" src="https://blog.codinghorror.com/content/images/uploads/2008/03/6a0120a85dcdae970b0128777032e7970c-pi.jpg" width="500">
</p>
<p>
Pixar has <a href="http://graphics.pixar.com/">done some incredible work</a> on 3D rendering, but it's not exactly what I'd call <i>real time</i>. Courtesy of Chris Anderson, here's <a href="http://www.longtail.com/the_long_tail/2006/12/pixar_quiz.html">a little Pixar quiz</a>:
</p>
<p>
</p>
<blockquote>
On 1995 computer hardware, the average frame of Toy Story took two hours to render. A decade later on 2005 hardware, how long did it take the average frame of Cars to render?
<p>
</p>
<ol type="A">
<li>30 minutes
</li>
<li>1 hour
</li>
<li>2 hours
</li>
<li>15 hours
</li>
</ol>
<p>
Answer: D. <b>The average Cars frame took 15 hours, despite a 300x overall increase in compute power.</b> The artists have an essentially infinite appetite for detail and realism, and Pixar's resources have grown over the decade so it can afford to allocate more computers to the task, allowing each to run longer to achieve the artist's and animator's ambitions for the scenes.
</p>
</blockquote>
<p>
Surprisingly, <a href="http://www.imdb.com/title/tt0317219/">Cars</a> was the first Pixar movie to be rendered with the slower, more accurate ray tracing techniques; previous movies used mostly scanline rendering. There's <a href="http://www.cs.ucy.ac.cy/ayia-napa06/presentations/ayianapa06per.ppt">an excellent presentation from Pixar's Per Christensen</a> (ppt) describing the differences in some detail, if you're curious. And if you want to experiment with ray tracing yourself, there's always <a href="http://www.povray.org/">POV-Ray</a>, which <a href="http://hof.povray.org/">produces some impressive results</a> as well.
</p>
<p>
Movies, of course, don't have to be rendered in real time. But even with the freedom to take as much time as necessary per frame, ray tracing is often too expensive. Imagine the difficulty, then, of <b>shoehorning ray tracing into real time 3D engines</b>. <a href="http://www.codinghorror.com/blog/archives/000732.html">Modern GPUs are impressive pieces of silicon</a>, but they cheat <i>mightily</i> when it comes to rendering a 3D scene. They have to, otherwise they'd never be able to generate the 30 or 60 frames per second necessary to provide the illusion of an interactive world.
</p>
<p>
Of course, this doesn't stop people from trying. The most impressive real time ray tracing attempt I've seen is from Daniel Pohl and his <a href="http://www.openrt.de/">OpenRT real-time ray tracing project</a>. Daniel has done some fascinating proof of concept work with <a href="http://www.pcper.com/article.php?aid=334&amp;type=expert">Quake 3</a> and <a href="http://www.pcper.com/article.php?aid=334&amp;type=expert">Quake 4</a>.
</p>
<p>
<a href="http://www.pcper.com/article.php?aid=334&amp;type=expert&amp;pid=2"><img alt="quake 3, raytraced in real time" border="0" class="at-xid-6a0120a85dcdae970b012877703300970c" height="480" src="https://blog.codinghorror.com/content/images/uploads/2008/03/6a0120a85dcdae970b012877703300970c-pi.jpg" width="480"></a>
</p>
<p>
But performance remains a problem, even on the latest and greatest hardware:
</p>
<p>
</p>
<blockquote>
So why don't we see raytracing right now in games? The problem is still performance. Rendering all these effects through the CPU is not as fast as using special purpose hardware like current graphic cards for the rasterization algorithm. But the evolution of CPUs is fast. Q3RT speed has increased by more than a factor of 4 since 2004. Intel's new quad core is out and the efficiency using the same CPU clock rate is about 30% higher.
<p>
One big advantage of raytracing is that it is perfect for parallelization. As explained in the introduction, a ray is shot through the 3D scene for every pixel. If you render an image with 640x480 pixels, you have about 300,000 rays. Each of them can be calculated independently of the others. This means the image could be split up into four parts and every core of a quad-core CPU can calculate the color values of the image without waiting on any of the other cores for intermediate results. Therefore the scaling of performance with the number of cores in Quake 4: Ray traced with OpenRT on Intel's quad-core CPU is great. The following benchmarks were taken at a resolution of 256x256 pixels on the Quake 4 map "Over the Edge (Q4DM7)".
</p>
<p>
</p>
<table cellpadding="4" cellspacing="4" width="400px">
<tr>
<td>4 cores</td>
<td>16.9 fps</td>
<td>3.84x scaling</td>
</tr>
<tr>
<td>2 cores</td>
<td>8.6 fps</td>
<td>1.96x scaling</td>
</tr>
<tr>
<td>1 core</td>
<td>4.4 fps</td>
<td>1x scaling</td>
</tr>
</table>
</blockquote>
<p>
It's <a href="http://www.codinghorror.com/blog/archives/000942.html">difficult to find much software that scales beyond two cores</a>. So the emergence of a many-core future is a boon to ray tracing algorithms, which scale nearly <i>perfectly</i>.
</p>
<p>
The dimensions of the original juggler are 320 x 200. That's roughly the same number of pixels as the 256 x 256 Quake 4 benchmark presented above. <b>It's possible we could render the ray traced Amiga juggler today in real time at close to 30 fps-- but <i>barely</i>.</b> Despite many hyperbolic marketing claims of "rendering Toy Story in real time", real time ray tracing remains something of a holy grail in practice-- considering Toy Story was <a href="http://en.wikipedia.org/wiki/Computer-generated_imagery">rendered at 1536 x 922</a>. Who knows what we'll be able to render in the next 20 years?
</p>
<p>
</p>
<p></p>
<!--kg-card-end: markdown-->
            </content>
<pubDate>2008-03-10T13:00:00.000Z</pubDate>
<guid>https://blog.codinghorror.com/real-time-raytracing/</guid>
</item>
</channel>
</rss>
