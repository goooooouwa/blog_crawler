<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0">
<channel>
<title>Coding Horror</title>
<description>programming and human factors</description>
<link>https://blog.codinghorror.com/</link>
<pubDate>Sun, 19 Apr 2020 00:00:01 GMT</pubDate>
<!-- other elements omitted from this example -->
<item>
<title>Why Isn't My Encryption.. Encrypting?</title>
<link>https://blog.codinghorror.com/why-isnt-my-encryption-encrypting/</link>
<content>
                <!--kg-card-begin: markdown--><p>
It's as true in life as it is in client-server programming: the only secret that can't be compromised is the one you never revealed.
</p>
<p>
But sometimes, it's unavoidable. If you <i>must</i> send a secret down to the client, you can encrypt it. The most common form of encryption is <a href="http://en.wikipedia.org/wiki/Symmetric-key_algorithm">symmetric encryption</a>, where the same key is used to both encrypt and decrypt. Most languages have relatively easy to use libraries in place for symmetric encryption. Here's how we were doing it in .NET:
</p>
<p>
</p>
<pre>
public static string Encrypt(string toEncrypt, string key, bool useHashing)
{
byte[] keyArray = UTF8Encoding.UTF8.GetBytes(key);
byte[] toEncryptArray = UTF8Encoding.UTF8.GetBytes(toEncrypt);
if (useHashing)
keyArray = new MD5CryptoServiceProvider().ComputeHash(keyArray);
var tdes = new TripleDESCryptoServiceProvider()
{ Key = keyArray, Mode = CipherMode.ECB, Padding = PaddingMode.PKCS7 };
ICryptoTransform cTransform = tdes.CreateEncryptor();
byte[] resultArray = cTransform.TransformFinalBlock(
toEncryptArray, 0, toEncryptArray.Length);
return Convert.ToBase64String(resultArray, 0, resultArray.Length);
}
</pre>
<p>
This is how our symmetric encryption function works:
</p>
<p>
</p>
<ol>
<li>We start with a secret string we want to protect. Let's say it is "password123".
</li>
<li>We pick a key. Let's use the key "key-m4st3r"
</li>
<li>Before encrypting, we'll prefix our secret with a salt to <a href="http://www.codinghorror.com/blog/archives/000949.html">prevent dictionary attacks</a>. Let's call our salt "NaCl".
</li>
</ol>
<p>
We'd call the function like so:
</p>
<p>
</p>
<pre>
Encrypt("NaCl" + "password123", "key-m4ast3r", true);
</pre>
<p>
The output is a base64 encoded string of the <a href="http://en.wikipedia.org/wiki/Triple_DES">TripleDES encrypted</a> byte data. <b>This encrypted data can now be sent to the client without any reasonable risk that the secret string will be revealed</b>. There's always <i>unreasonable</i> risk, of the silent black government helicopter sort, but for all practical purposes there's no way someone could discover that your password is "password123" unless your key is revealed.
</p>
<p>
In our case, we were using this <code>Encrypt()</code> method to experiment with <b>storing some state data in web pages related to the login process</b>. We thought it was secure, because the data was encrypted. Sure it's encrypted! It says <code>Encrypt()</code> right there in the method name, right?
</p>
<p>
Wrong.
</p>
<p>
There's a bug in that code. A bug that makes our encrypted state data vulnerable. Do you see it? My coding mistakes, <a href="http://www.pantherkut.com/wp-content/uploads/2007/05/my_pokemons.jpg">let me show you them!</a>
</p>
<p>
</p>
<pre>
string key = "SuperSecretKey";
Debug.WriteLine(
Encrypt("try some different" +
"<font color="red">00000000000000000000000000000000</font>",
key, true).Base64ToHex());
Debug.WriteLine(
Encrypt("salts" +
"<font color="red">00000000000000000000000000000000</font>",
key, true).Base64ToHex());
3908024fc33b55c3
4e885c8946b80735
704cbe2a41d25f21
<font color="red">81bb6d726bd35152</font>
<font color="red">81bb6d726bd35152</font>
<font color="red">81bb6d726bd35152</font>
1367f10f2584ace3
4ae7661295a98e46
<font color="red">81bb6d726bd35152</font>
<font color="red">81bb6d726bd35152</font>
<font color="red">81bb6d726bd35152</font>
4ee5d23b3b5e3eb4
</pre>
<p>
(I'm using strings with multiples of 8 here to make the Base64 conversions easier.)
</p>
<p>
Do you see the mistake now? It's a short trip from here to unlimited data tampering, particularly since the state data from the login process contained user entered strings. An attacker could simply submit the form as many times as she likes, chop out the encrypted attack values from the middle, and insert them into the next encrypted request -- <b>which will happily decrypt and be processed as if our code had sent it down!</b>
</p>
<p>
The culprit is this line of code:
</p>
<p>
</p>
<pre>
{ Key = keyArray, <font color="red">Mode = CipherMode.ECB</font>, Padding = PaddingMode.PKCS7 }
</pre>
<p>
Which, much to our embarrassment, is an <i>incredibly</i> <a href="http://msdn.microsoft.com/en-us/library/system.security.cryptography.ciphermode.aspx">stupid parameter</a> to use in symmetric encryption:
</p>
<p>
</p>
<blockquote>
The Electronic Codebook (ECB) mode encrypts each block individually. This means that any blocks of plain text that are identical and are in the same message, or in a different message encrypted with the same key, will be transformed into identical cipher text blocks. If the plain text to be encrypted contains substantial repetition, it is feasible for the cipher text to be broken one block at a time. Also, it is possible for an active adversary to substitute and exchange individual blocks without detection.
</blockquote>
<p>
It's fairly standard for symmetric encryption algorithms to use feedback from the previous block to seed the next block. I honestly did not realize that it was <i>possible</i> to pick a cipher mode that did not do some kind of block chaining! <code>CipherMode.ECB</code>? More like <code>CipherMode.Fail</code>!
</p>
<p>
So, what have we learned?
</p>
<p>
</p>
<ol>
<li>
<b>If it doesn't <i>have</i> to be sent to the client, then don't!</b> Secrets sent to the client can potentially be tampered with and compromised in various ways that aren't easy to see or even predict. In our case, we can store login state on the server and avoid transmitting any of that state to the client altogether.<br><br>
</li>
<li>
<b>It isn't encryption until you've taken the time to fully understand the concepts behind the encryption code</b>. Specifically, we didn't notice that our encryption function was using a highly questionable <code>CipherMode</code> that allowed block level substitution of the encrypted data.
</li>
</ol>
<p>
Luckily, this was a somewhat experimental page on the site, so we were able to revert back to our standard server-side approach rather quickly once the exploit was discovered. I'm no <a href="http://www.schneier.com/">Bruce Schneier</a>, but I have <a href="http://www.codeproject.com/KB/security/SimpleEncryption.aspx">a reasonable grasp of encryption concepts</a>. And I <i>still</i> completely missed this problem.
</p>
<p>
So the next time you sit down to write some encryption code, consider the above two points carefully. Otherwise, like us, you'll be left wondering <b>why your encryption isn't... <i>encrypting</i></b>.
</p>
<p>
(Thanks to Daniel LeCheminant for his assistance in discovering this issue.)
</p>
<p>
</p>
<p></p>
<!--kg-card-end: markdown-->
            </content>
<pubDate>2009-05-17T12:00:00.000Z</pubDate>
<guid>https://blog.codinghorror.com/why-isnt-my-encryption-encrypting/</guid>
</item>
</channel>
</rss>
