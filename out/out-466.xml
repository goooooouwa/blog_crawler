<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0">
<channel>
<title>Coding Horror</title>
<description>programming and human factors</description>
<link>https://blog.codinghorror.com/</link>
<pubDate>Sun, 19 Apr 2020 00:00:01 GMT</pubDate>
<!-- other elements omitted from this example -->
<item>
<title>The Danger of Naïveté</title>
<link>https://blog.codinghorror.com/the-danger-of-naivete/</link>
<content>
                <!--kg-card-begin: markdown--><p>In my <a href="http://www.codinghorror.com/blog/archives/001008.html?r=31644">previous post on shuffling</a>, I glossed over something very important. The very first thing that came to mind for a shuffle algorithm is this:</p>
<pre>for (int i = 0; i &lt; cards.Length; i++)
{
  int n = rand.Next(cards.Length);
  Swap(ref cards[i], ref cards[n]);
}
</pre>
<p>It's a nice, simple solution to the shuffling problem:</p>
<ol>
<li>Loop through each card in the deck. </li>
<li>Swap the current card with another randomly chosen card. </li>
</ol>
<p>At first blush, this seems like a perfectly reasonable way to shuffle. It's simple, it's straightforward, and the output looks correct. It's the very <em>definition</em> of a <a href="http://en.wikipedia.org/wiki/Na%C3%AFve_algorithm">naïve algorithm</a>:</p>
<blockquote>A naïve algorithm is a very simple solution to a problem. It is meant to describe a suboptimal algorithm compared to a "clever" (but less simple) algorithm. Naïve algorithms usually consume larger amounts of resources (time, space, memory accesses, ...), but are simple to devise and implement.
<p>An example of a naïve algorithm is bubble sort, which is only a few lines long and easy to understand, but has a O(n<sup>2</sup>) time complexity. A more "clever" algorithm is quicksort, which, although being considerably more complicated than bubble sort, has a O(n log n) average complexity.</p>
</blockquote>
<p>But there's a deep, dark problem with this naïve shuffling algorithm, a problem that most programmers won't see. <strong>Do you see it?</strong> Heck, I had the problem explained to me and I <em>still</em> didn't see it.</p>
<p>Watch what happens when I use this naïve shuffling algorithm to shuffle a three-card deck 600,000 times. There are 3! or 6 possible combinations in that deck. If the shuffle is working properly, we should see each combination represented around 100,000 times.</p>
<p><img class="at-xid-6a0120a85dcdae970b0120a86da1f3970b " src="https://blog.codinghorror.com/content/images/uploads/2007/12/6a0120a85dcdae970b0120a86da1f3970b-pi.png" border="0" alt="naive shuffle on a 3 card deck, 600k iterations" width="440" height="273"></p>
<p>As you can see, 231, 213, and 132 are over-represented, and the other three possibilities are under-represented. <strong>The naïve shuffle algorithm is biased and fundamentally broken.</strong> Moreover, the bias isn't immediately obvious; you'd have to shuffle at least a few thousand times to see real statistical evidence that things aren't working correctly. It's a subtle thing.</p>
<p>Usually, naïve algorithms aren't <em>wrong</em> -- just oversimplified and inefficient. The danger, in this case, is rather severe. A casual programmer would implement the naïve shuffle, run it a few times, see reasonably correct results, and move on to other things. Once it gets checked in, this code is a landmine waiting to explode.</p>
<p>Let's take a look at the correct <a href="http://en.wikipedia.org/wiki/Knuth_shuffle">Knuth-Fisher-Yates shuffle algorithm</a>.</p>
<pre>for (int i = cards.Length - 1; i &gt; 0; i--)
{
  int n = rand.Next(i + 1);
  Swap(ref cards[i], ref cards[n]);
}
</pre>
<p>Do you see the difference? I missed it the first time. Compare the swaps for a 3 card deck:</p>
<table cellspacing="4" cellpadding="4" width="500">
<tbody>
<tr>
<td><strong>Naïve shuffle</strong></td>
<td><strong>Knuth-Fisher-Yates shuffle</strong></td>
</tr>
<tr>
<td valign="top">
<pre>rand.Next(3);
rand.Next(3);
rand.Next(3);
</pre>
</td>
<td valign="top">
<pre>rand.Next(3);
rand.Next(2);
</pre>
</td>
</tr>
</tbody>
</table>
<p>The naive shuffle results in 3<sup>3</sup> (27) possible deck combinations. That's odd, because the mathematics tell us that there are really only 3! or 6 possible combinations of a 3 card deck. In the KFY shuffle, we start with an initial order, swap from the third position with any of the three cards, then swap again from the second position with the remaining two cards.</p>
<p><img class="at-xid-6a0120a85dcdae970b0120a86da211970b " src="https://blog.codinghorror.com/content/images/uploads/2007/12/6a0120a85dcdae970b0120a86da211970b-pi.png" border="0" alt="Knuth-Fisher-Yates shuffle combinations diagram" width="667" height="410"></p>
<p>The KFY shuffle produces <em>exactly</em> 3 * 2 = 6 combinations, as pictured above. Based on your experience shuffling physical cards, you might think the more shuffling that goes on, the more random the deck becomes. But <strong>more shuffling results in <em>worse</em>, not better, results</strong>. That's where the naïve algorithm goes horribly wrong. Let's compare all possible permutations of a 3 card deck for each algorithm:</p>
<table cellspacing="4" cellpadding="4" width="100%">
<tbody>
<tr>
<td valign="top">Naïve shuffle</td>
<td valign="top">Knuth-Fisher-Yates shuffle</td>
</tr>
<tr>
<td valign="top">
<table>
<tbody>
<tr>
<td valign="top">123<br> 123<br> 123<br> 123</td>
<td valign="top">132<br> 132<br> 132<br> 132<br> 132</td>
<td valign="top">213<br> 213<br> 213<br> 213<br> 213</td>
<td valign="top">231<br> 231<br> 231<br> 231<br> 231</td>
<td valign="top">312<br> 312<br> 312<br> 312</td>
<td valign="top">321<br> 321<br> 321<br> 321</td>
</tr>
</tbody>
</table>
</td>
<td valign="top">
<table>
<tbody>
<tr>
<td>123</td>
<td>132</td>
<td>213</td>
<td>231</td>
<td>312</td>
<td>321</td>
</tr>
</tbody>
</table>
</td>
</tr>
</tbody>
</table>
<p>You can plainly see how some of the deck combinations appear unevenly in the 27 results of the naïve algorithm. Stated mathematically, <strong>27 is not evenly divisible by six</strong>.</p>
<p>Enough theory. Let's see more results. How about a four card deck, shuffled 600,000 times?</p>
<p><img class="at-xid-6a0120a85dcdae970b0120a86da22f970b " src="https://blog.codinghorror.com/content/images/uploads/2007/12/6a0120a85dcdae970b0120a86da22f970b-pi.png" border="0" alt="Naive vs. Knuth shuffle, 4 card deck, 600k iterations" width="463" height="522"></p>
<p>600,000 divided by 24 is 25,000; that's almost exactly what we see right down the line for every possible combination of cards with the KFY shuffle algorithm. The naïve algorithm, in comparison, is all over the map.</p>
<p>It gets worse with larger decks. Here's the same comparison for a six card deck.</p>
<p><img src="https://blog.codinghorror.com/content/images/uploads/2007/12/6a0120a85dcdae970b0120a86da24b970b-pi.png" border="0" alt="Naive vs. Knuth shuffle, 6 card deck, 600k iterations" width="465" height="275"></p>
<p>With a 6 card deck, the differences between the two algorithms grow even larger. The math, yet again, explains why.</p>
<pre>6! = 720
6<sup>6</sup> = 46,656
</pre>
<p>With 46,656 paths to only 720 real world outputs, it's inevitable that some of those paths will be severely over-represented or under-represented in the output. And are they ever. If you shipped a real card game with a naïve shuffle, you'd have some serious exploits to deal with.</p>
<p>I know this may seem like remedial math to some of you, but I found this result strikingly counterintuitive. I had a very difficult time understanding why the naïve shuffle algorithm, which is barely different from the KFY shuffle algorithm, produces such terribly incorrect results in practice. It's a minute difference in the code, but a profound difference in results. Tracing through all the permutations and processing the statistics helped me understand <em>why</em> it was wrong.</p>
<p>Naïve implementations are often preferred to complex ones. Simplicity is a virtue. It's better to be simple, slow, and understandable than complex, fast, and difficult to grasp. Or at least it <em>usually</em> is. Sometimes, as we've seen here with our shuffling example, the simplicity of the naïve implementation can mislead. <strong>It is possible for the code to be both simple and wrong</strong>. I suppose the real lesson lies in testing. No matter how simple your code may be, there's no substitute for testing it to make sure it's actually doing what you think it is.</p>
<!--kg-card-end: markdown-->
            </content>
<pubDate>2007-12-07T12:00:00.000Z</pubDate>
<guid>https://blog.codinghorror.com/the-danger-of-naivete/</guid>
</item>
</channel>
</rss>
