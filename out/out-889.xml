<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0">
<channel>
<title>Coding Horror</title>
<description>programming and human factors</description>
<link>https://blog.codinghorror.com/</link>
<pubDate>Sun, 19 Apr 2020 00:00:01 GMT</pubDate>
<!-- other elements omitted from this example -->
<item>
<title>UML, Circuit Diagrams, and God's Rules</title>
<link>https://blog.codinghorror.com/uml-circuit-diagrams-and-gods-rules/</link>
<content>
                <!--kg-card-begin: markdown--><p>
Very few software engineers use <a href="http://www.phruby.com/stencildownload.html">UML symbols</a> to design software, but electrical engineers regularly use circuit symbols to design electronics:
</p>
<p>
<img alt="Circuit elements" border="0" class="at-xid-6a0120a85dcdae970b0120a86d5d92970b" height="260" src="https://blog.codinghorror.com/content/images/uploads/2006/04/6a0120a85dcdae970b0120a86d5d92970b-pi.png" width="400">
</p>
<p>
<a href="http://www.kpsec.freeuk.com/symbol.htm">Circuit symbols</a> are constructed into <a href="http://en.wikipedia.org/wiki/Circuit_diagram">circuit diagrams</a>-- the <b>the visual language of electricity</b>:
</p>
<p>
<img alt="a circuit diagram" border="0" class="at-xid-6a0120a85dcdae970b0120a86d5daa970b" height="356" src="https://blog.codinghorror.com/content/images/uploads/2006/04/6a0120a85dcdae970b0120a86d5daa970b-pi.png" width="600">
</p>
<p>
If circuit diagrams are a standard, universally understood way to talk about electronics, <b>why doesn't UML enjoy the same currency for software development?</b>
</p>
<p>
Well, one obvious difference is that software, unlike electricity, isn't subject to God's laws.* And <a href="http://www.codinghorror.com/blog/archives/000298.html">God didn't invent x86</a>. Software development is far less amenable to formal diagrams because, well, it's something <i>we just made up</i>. And we keep changing the rules all the time. As Brooks points out in <a href="http://www.amazon.com/exec/obidos/ASIN/0201835959/codihorr-20">The Mythical Man-Month</a>, software developers are essentially <a href="http://www.ercb.com/feature/feature.0001.html">playing the role of God</a>:
</p>
<p>
</p>
<blockquote>
Why is programming fun? What delights may its practioner expect as his reward?
<p>
First is the sheer joy of making things. As the child delights in his mud pie, so the adult enjoys building things, especially things of his own design. I think this delight must be an image of God's delight in making things, a delight shown in the distinctiveness of each leaf and each snowflake.
</p>
<p>
Second is the pleasure of making things that are useful to other people. Deep within, we want others to use our work and to find it helpful. In this respect the programming system is not essentially different from the child's first clay pencil holder "for Daddy's office."
</p>
<p>
Third is the fascination of fashioning complex puzzle-like objects of interlocking moving parts and watching them work in subtle cycles, playing out the consequences of principles built in from the beginning. The programmed computer has all the fascination of the pinball machine or the jukebox mechanism, carried to the ultimate.
</p>
<p>
Fourth is the joy of always learning, which springs from the nonrepeating nature of the task. In one way or another the problem is ever new, and its solver learns something: sometimes practical, sometimes theoretical, and sometimes both.
</p>
<p>
<b>Finally, there is the delight of working in such a tractable medium. The programmer, like the poet, works only slightly removed from pure thought-stuff. He builds his castles in the air, from air, creating by exertion of the imagination. Few media of creation are so flexible, so easy to polish and rework, so readily capable of realizing grand conceptual structures.</b> (As we shall see later, this tractability has its own problems.)
</p>
<p>
Yet the program construct, unlike the poet's words, is real in the sense that it moves and works, producing visible outputs separately from the construct itself. It prints results, draws pictures, produces sounds, moves arms. The magic of myth and legend has come true in our time. One types the correct incantation on a keyboard, and a display screen comes to life, showing things that never were nor could be.
</p>
<p>
Programming then is fun because it gratifies creative longings built deep within us and delights sensibilities we have in common with all men.
</p>
</blockquote>
<p>
Software developers do not have a monopoly on creativity. A clever circuit is no less imaginative than a clever algorithm. But software development is a "tractable medium." If we decide the speed of light is not to our liking, <i>we just change it</i>. Imagine the difficulty an electrical engineer would have working on your circuit diagram if, on that diagram, you had changed something fundamental, like the conductivity of copper.
</p>
<p>
But even with the helpful constraint of God's rules, <b>circuit diagrams are still idealized representations of the final product.</b> You need a <a href="http://en.wikipedia.org/wiki/Printed_circuit">printed circuit board</a> to implement the circuit diagram-- and the translation from circuit digram into PCB  typically invoves a lot of real-world compromises.
</p>
<p>
This is not to say that formal software diagramming systems like UML aren't useful in software engineering. They can be. But they'll never be as useful as circuit diagrams are to electrical engineers.
</p>
<p>
* Or <a href="http://www.venganza.org/">the deity of your choice</a>.
</p>
<p>
</p>
<p></p>
<!--kg-card-end: markdown-->
            </content>
<pubDate>2006-04-14T12:00:00.000Z</pubDate>
<guid>https://blog.codinghorror.com/uml-circuit-diagrams-and-gods-rules/</guid>
</item>
</channel>
</rss>
