<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0">
<channel>
<title>Coding Horror</title>
<description>programming and human factors</description>
<link>https://blog.codinghorror.com/</link>
<pubDate>Sun, 19 Apr 2020 00:00:01 GMT</pubDate>
<!-- other elements omitted from this example -->
<item>
<title>What's Worse Than Crashing?</title>
<link>https://blog.codinghorror.com/whats-worse-than-crashing/</link>
<content>
                <!--kg-card-begin: markdown--><p>
Here's an interesting thought question from Mike Stall: <a href="http://blogs.msdn.com/jmstall/archive/2007/07/26/there-are-things-worse-than-crashing.aspx">what's worse than crashing?</a>
</p>
<p>
Mike provides the following list of crash scenarios, in order from best to worst:
</p>
<p>
</p>
<ol>
<li>Application works as expected and never crashes.
</li>
<li>Application crashes due to rare bugs that nobody notices or cares about.
</li>
<li>Application crashes due to a commonly encountered bug.
</li>
<li>Application deadlocks and stops responding due to a common bug.
</li>
<li>Application crashes long after the original bug.
</li>
<li>
<b>Application causes data loss and/or corruption.</b>
</li>
</ol>
<p>
Mike points out that there's a natural tension between...
</p>
<p>
</p>
<ul>
<li>failing <i>immediately</i> when your program encounters a problem, eg "fail fast"
</li>
<li>attempting to recover from the failure state and proceed normally
</li>
</ul>
<p>
The philosophy behind "fail fast" is best explained in <a href="http://www.martinfowler.com/ieeeSoftware/failFast.pdf">Jim Shore's article</a> (pdf).
</p>
<p>
</p>
<blockquote>
Some people recommend making your software robust by working around problems automatically. This results in the software "failing slowly." The program continues working right after an error but fails in strange ways later on. A system that fails fast does exactly the opposite: when a problem occurs, it fails immediately and visibly. Failing fast is a nonintuitive technique: "failing immediately and visibly" sounds like it would make your software more
fragile, but it actually makes it more robust. Bugs are easier to find and fix, so fewer go into production.
</blockquote>
<p>
Fail fast is reasonable advice-- if you're a developer. What could possibly be easier than <a href="http://www.codinghorror.com/blog/archives/000676.html">calling everything to a screeching halt</a> the minute you get a byte of data you don't like? Computers are spectacularly unforgiving, so it's only natural for developers to reflect that masochism directly back on users.
</p>
<p>
But from the user's perspective, failing fast isn't helpful. To them, it's just another <a href="http://www.codinghorror.com/blog/archives/000114.html">meaningless error dialog</a> preventing them from getting their work done. The best software never pesters users with meaningless, trivial errors-- it's <a href="http://www.codinghorror.com/blog/archives/000550.html">more considerate than that</a>. Unfortunately, <b>attempting to help the user by fixing the error could make things worse by leading to subtle and catastrophic failures down the road.</b> As you work your way down Mike's list, the pain grows exponentially. For both developers <i>and</i> users. Troubleshooting #5 is a brutal death march, and by the time you get to #6-- you've lost or corrupted user data-- you'll be lucky to have any users <i>left</i> to fix bugs for.
</p>
<p>
What's interesting to me is that despite causing more than my share of software crashes and hardware bluescreens, I've <i>never</i> lost data, or had my data corrupted. You'd figure Murphy's Law would force the worst possible outcome at least once a year, but it's exceedingly rare in my experience. Maybe this is an encouraging sign for the current state of software engineering. Or maybe I've just been lucky.
</p>
<p>
So what can we, as software developers, do about this? If we adopt a "fail as often and as obnoxiously as possible" strategy, we've clearly failed our users. But if we corrupt or lose our users' data through misguided attempts to prevent error messages-- if we fail to treat our users' data as sacrosanct-- we've <i>also</i> failed our users. You have to do both at once:
</p>
<p>
</p>
<ol>
<li>If you <i>can</i> safely fix the problem, you should. Take responsibility for your program. Don't slouch through the easy way out by placing the burden for dealing with every problem squarely on your users.
</li>
<li>If you <i>can't</i> safely fix the problem, always err on the side of protecting the user's data. Protecting the user's data is a sacred trust. If you harm that basic contract of trust between the user and your program, you're hurting not only your credibility-- but the credibility of the entire software industry as a whole. Once they've been burned by data loss or corruption, users don't soon forgive.
</li>
</ol>
<p>
The guiding principle here, as always, should be to <b>respect your users</b>. Do the right thing.
</p>
<p>
</p>
<p>
</p>
<p></p>
<!--kg-card-end: markdown-->
            </content>
<pubDate>2007-08-02T12:00:00.000Z</pubDate>
<guid>https://blog.codinghorror.com/whats-worse-than-crashing/</guid>
</item>
</channel>
</rss>
