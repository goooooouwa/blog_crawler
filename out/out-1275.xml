<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0">
<channel>
<title>Coding Horror</title>
<description>programming and human factors</description>
<link>https://blog.codinghorror.com/</link>
<pubDate>Sun, 19 Apr 2020 00:00:01 GMT</pubDate>
<!-- other elements omitted from this example -->
<item>
<title>Is DoEvents Evil?</title>
<link>https://blog.codinghorror.com/is-doevents-evil/</link>
<content>
                <!--kg-card-begin: markdown--><p>
It's an old VB developer trick, but it also works quite well in .NET: <b>to present responsive WinForms interfaces, do most of your heavy lifting in the first Paint event, rather than in the Load event.</b> I've seen many naive WinForm developers perform database queries and other heavyweight operations in the Form Load event, which absolutely kills perceived performance-- the form doesn't even display until all the work is done! It's much better to render part of the form first so the user gets immediate visual feedback, beyond an hourglass cursor, that stuff is happening.
</p>
<p>
The easiest way to deliver a semi-responsive interface is to attach an IsFirstPaint boolean to the paint event, and move the intensive part of the work you're doing on Load into Paint. However, for this to work, you still need to yield a bit to give the form time to paint some of its elements-- that means putting a little bit of <b>DoEvents spackle</b> in there, prior to going off and doing a bunch of work.
</p>
<p>
Now, I like the effort/results ratio that DoEvents and IsFirstPaint delivers, but <b>I've never really been comfortable with DoEvents in the brave new world of .NET.</b> It seems like.. old-school Win3x cooperative multitasking. I'm not the only developer to question the meaning of DoEvents in .NET, as <a href="http://msdn.microsoft.com/chats/transcripts/vstudio/vstudio_112503.aspx">this MSDN threading chat illustrates</a>:
</p>
<blockquote>
<i>
Q: What is the reason for maintaining DoEvents in the .NET framework? Why was it not limited to an assembly in the Microsoft.VisualBasic namespace? What is the need for DoEvents when there is proper support for multi-threaded applications?
</i><p>
A: Jason (Microsoft) DoEvenets is a holdover from VB 5.x, but it is still useful in the .NET Framework world. If you have a loop that runs for a long time, it is often easier to call DoEvents than to refactor your loop to use true .NET threading.
</p>
<p>
Q: Why is DoEvents in the BCL namespace?
</p>
<p>
A: Glenn (Microsoft) Threading is difficult, and should be avoided if there's an easier way. If all you need to do is yield on your UI thread, DoEvents is perfect.
</p>
<p>
<b>Q: DoEvents is evil?</b>
</p>
<p>
A: Glenn (Microsoft) Yielding on the UI thread is a legitimate Windows programming practice. It always has been. DoEvents makes it easy, because the situations in which you need to use it are simple.
</p>
</blockquote>
<p>
Or, <a href="http://dacris.com/blog/archive/2004/05/29/155.aspx">as Dan Tohatan puts it</a>:
</p>
<p>
</p>
<blockquote>
<i>
<b>Application.DoEvents() - The call of the devil.</b>
</i><p>
DoEvents messes up the normal flow of your application. If I recall correctly, DoEvents is asynchronous which means it terminates before the application has actually processed any outstanding events, so if you're using it in a procedure with many sequential statements, calling DoEvents causes a huge disturbance whenever it's called. Basically, if you find yourself needing to call DoEvents anywhere, think about starting another thread instead, or using asynchronous delegates.
</p>
<p>
Imagine this if you will: You have a button on your form that, when clicked, does some complex processing. During the complex processing it also intermittently calls DoEvents to keep the application's user interface "responsive" -- not the best method, I would have used async delegates, but we're talking about a mediocre programmer here. Anyhow, the user sees the application still responding and no indication that there's some processing going on. So the user clicks that button again WHILE the processing is going on! <b>The button responds to the event and starts another processing thread but it isn't actually a thread here</b>, I hope you get what I'm saying. So, like I said earlier, DoEvents screws up the flow of the application too easily.
</p>
</blockquote>
<p>
Of course, DoEvents and IsFirstPaint are only partial solutions to make the forms <i>look</i> like they load faster. Never underestimate the power of <b>perceived performance</b>, but the actual interface is still unresponsive. If you want a fully reponsive interface with background processing, <a href="http://weblogs.asp.net/dphill/archive/2004/07/14/183503.aspx">the correct way to do it is with threading and Control.Invoke</a>. A lot of armchair developers like to conveniently forget this, but <b>threading is hard</b>. Dangerous, even. It's not a coding burden you take on lightly. When things start happening in asynchronous, indeterminate order instead of the deterministic 1-2-3 order you'd expect.. things get absurdly difficult really quickly, as noted in <a href="http://weblogs.asp.net/rosherove/archive/2003/05/06/6554.aspx">this Roy Osherove blog post</a>:
</p>
<p>
</p>
<blockquote>
<i>
Beware - I've spent quite a lot of time on this problem. We are building a client application fetching information from a server (using SOAP) in the background, and displaying the information in the windows UI when it arrives. Unfortunately it arrives in another thread. On top of this we have implemented a cache the UI components should be reading from. <b>The problem is that it is insufficient to call Control.Invoke() when changing information in, for example, a listbox. We also need to make sure the underlying data to be displayed does not change while the UI thread reads it.</b> And simple synchronization is not enough as this will only give atomic access to a single element, when we need to block the entire array while updating the control.
</i><p>
The best solution I've found until now is to model an UI thread and background threads as two separate processes (implemented as .NET threads) that only communicates through messages and has NO shared memory. The messages are modeled through a homebuild "mailbox" interface. The modeled is inspired by the language Erlang.
</p>
</blockquote>
<p>
You've never truly debugged an app until you've struggled with an obscure threading issue. Threading is a manly approach for tough guys, and it will put hair on your chest-- but you may not have any left on your head when you're done.
</p>
<p>
I agree that DoEvents is not exactly great programming practice, but <b>even Microsoft recommends using it in lieu of hard-core threading for simple problems</b>. So it's something of a tradeoff. Easier WinForms threading is coming in .NET 2.0, but in the meantime, I'd look into the <a href="http://weblogs.asp.net/rosherove/articles/BackgroundWorker.aspx">backgroundworker code samples</a>.
</p>
<p>
</p>
<p></p>
<!--kg-card-end: markdown-->
            </content>
<pubDate>2004-12-18T12:00:00.000Z</pubDate>
<guid>https://blog.codinghorror.com/is-doevents-evil/</guid>
</item>
</channel>
</rss>
