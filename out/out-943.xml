<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0">
<channel>
<title>Coding Horror</title>
<description>programming and human factors</description>
<link>https://blog.codinghorror.com/</link>
<pubDate>Sun, 19 Apr 2020 00:00:01 GMT</pubDate>
<!-- other elements omitted from this example -->
<item>
<title>The Day Performance Didn't Matter Any More</title>
<link>https://blog.codinghorror.com/the-day-performance-didnt-matter-any-more/</link>
<content>
                <!--kg-card-begin: markdown--><p>OSNews published a <a href="http://osnews.com/story.php?news_id=5602&amp;page=3">nine-language performance roundup</a> in early 2004. The results are summarized here:</p>
<table border="0" cellpadding="4" cellspacing="4">
<tr>
<td align="right"></td>
<td align="right"><b>int</b></td>
<td align="right"><b>long</b></td>
<td align="right"><b>double</b></td>
<td align="right"><b>trig</b></td>
<td align="right"><b>I/O</b></td>
<td align="right"></td>
</tr>
<tr>
<td align="right">Visual C++</td>
<td align="right">9.6</td>
<td align="right">18.8</td>
<td align="right">6.4</td>
<td align="right">3.5</td>
<td align="right">10.5</td>
<td align="right" style="color: maroon">48.8</td>
</tr>
<tr>
<td align="right">Visual C#</td>
<td align="right">9.7</td>
<td align="right">23.9</td>
<td align="right">17.7</td>
<td align="right">4.1</td>
<td align="right">9.9</td>
<td align="right" style="color: maroon">65.3</td>
</tr>
<tr>
<td align="right">gcc C</td>
<td align="right">9.8</td>
<td align="right">28.8</td>
<td align="right">9.5</td>
<td align="right">14.9</td>
<td align="right">10.0</td>
<td align="right" style="color: maroon">73.0</td>
</tr>
<tr>
<td align="right">Visual Basic</td>
<td align="right">9.8</td>
<td align="right">23.7</td>
<td align="right">17.7</td>
<td align="right">4.1</td>
<td align="right">30.7</td>
<td align="right" style="color: maroon">85.9</td>
</tr>
<tr>
<td align="right">Visual J#</td>
<td align="right">9.6</td>
<td align="right">23.9</td>
<td align="right">17.5</td>
<td align="right">4.2</td>
<td align="right">35.1</td>
<td align="right" style="color: maroon">90.4</td>
</tr>
<tr>
<td align="right">Java 1.3.1</td>
<td align="right">14.5</td>
<td align="right">29.6</td>
<td align="right">19.0</td>
<td align="right">22.1</td>
<td align="right">12.3</td>
<td align="right" style="color: maroon">97.6</td>
</tr>
<tr>
<td align="right">Java 1.4.2</td>
<td align="right">9.3</td>
<td align="right">20.2</td>
<td align="right">6.5</td>
<td align="right">57.1</td>
<td align="right">10.1</td>
<td align="right" style="color: maroon">103.1</td>
</tr>
<tr>
<td align="right">Python/Psyco</td>
<td align="right">29.7</td>
<td align="right">615.4</td>
<td align="right">100.4</td>
<td align="right">13.1</td>
<td align="right">10.5</td>
<td align="right" style="color: maroon">769.1</td>
</tr>
<tr>
<td align="right">Python</td>
<td align="right">322.4</td>
<td align="right">891.9</td>
<td align="right">405.7</td>
<td align="right">47.1</td>
<td align="right">11.9</td>
<td align="right" style="color: maroon">1679.0</td>
</tr>
</table>
<p>It's not a very practical benchmark, but it does tell us a few things. It's no surprise that C++ is at the head of the pack. But the others aren't terribly far behind. What I find really interesting, though, is how <b>most of the languages clump together in the middle</b>. There's no significant performance difference between Java and .NET if you throw out the weirdly anomalous trig results.</p>
<p>However, there is one language definitely bringing up the rear –  <a href="http://en.wikipedia.org/wiki/Python_programming_language">Python</a>. That's because it's an <a href="http://en.wikipedia.org/wiki/Interpreted_language">interpreted language</a>. This is explained in <a href="http://www.amazon.com/exec/obidos/ASIN/0735619670/codihorr-20">Code Complete</a>:</p>
<blockquote>Interpreted languages tend to exact significant performance penalties because they must process each programming-language instruction before creating and executing machine code. In the performance benchmarking I performed for this chapter and chapter 26, I observed these approximate relationships in performance among different languages:
<table cellpadding="4" cellspacing="4" width="500">
<tr>
<td>
<strong>Language</strong>
</td>
<td>
<strong>Type of Language</strong>
</td>
<td>
<strong>Execution Time Relative to C++</strong>
</td>
</tr>
<tr>
<td>
C++</td>
<td>
Compiled</td>
<td>
1:1</td>
</tr>
<tr>
<td>
Visual Basic</td>
<td>
Compiled</td>
<td>
1:1</td>
</tr>
<tr>
<td>
C#</td>
<td>
Compiled</td>
<td>
1:1</td>
</tr>
<tr>
<td>
Java</td>
<td>
Byte code</td>
<td>
1.5:1</td>
</tr>
<tr>
<td style="color: red">
PHP</td>
<td style="color: red">
Interpreted</td>
<td style="color: red">
&gt; 100:1</td>
</tr>
<tr>
<td style="color: red">
Python</td>
<td style="color: red">
Interpreted</td>
<td style="color: red">
&gt; 100:1</td>
</tr>
</table>
</blockquote>
<p>Clearly, the performance penalty for interpreted languages is extreme. How extreme? If you have to ask, <i>you probably can't afford it.</i></p>
<p>One of the biggest stigmas for early Visual Basic developers was that our code wasn't compiled. It was interpreted. Interpreted executables were yet another reason so-called<br>
"professional" developers didn't take VB seriously. It was too slow. This finally changed when we got <a href="http://msdn.microsoft.com/library/default.asp?url=/library/en-us/vbcon98/html/vbconcompiledvsinterpretedapplications.asp">compiled executables</a> in 1997 with VB 5.</p>
<p>The most commonly used interpreted language today, however, is JavaScript. And <a href="http://www.paulgraham.com/web20.html">JavaScript is the very backbone of Web 2.0</a>. How is this feasible if JavaScript is a hundred times slower than Java? Consider this <a href="http://web.archive.org/web/20060630033935/http://www.geocities.com/SiliconValley/7116/jv_bench.html">ancient 1996 JavaScript benchmark page</a><br>
:</p>
<table cellpadding="4" cellspacing="0" width="275">
<tr>
<td></td>
<td style="text-align: right">
<strong>1996</strong>
</td>
<td style="text-align: right">
<strong>
2006</strong>
</td>
<td>
</td>
</tr>
<tr>
<td>
primes</td>
<td style="text-align: right">
0.15</td>
<td style="text-align: right">
0.02</td>
<td style="color: maroon; text-align: right;">
8x</td>
</tr>
<tr>
<td>
pgap</td>
<td style="text-align: right">
3.13</td>
<td style="text-align: right">
0.06</td>
<td style="color: maroon; text-align: right">
52x</td>
</tr>
<tr>
<td>
sieve</td>
<td style="text-align: right">
5.05</td>
<td style="text-align: right">
0.02</td>
<td style="color: maroon; text-align: right">
252x</td>
</tr>
<tr>
<td>
fib(20)</td>
<td style="text-align: right">
2.15</td>
<td style="text-align: right">
0.03</td>
<td style="color: maroon; text-align: right">
72x</td>
</tr>
<tr>
<td>
tak</td>
<td style="text-align: right">
10.44</td>
<td style="text-align: right">
0.08</td>
<td style="color: maroon; text-align: right">
131x</td>
</tr>
<tr>
<td>
mb100</td>
<td style="text-align: right">
8.4</td>
<td style="text-align: right">
0.2</td>
<td style="color: maroon; text-align: right">
42x</td>
</tr>
</table>
<p>In ten years, <strong>JavaScript performance has improved a hundredfold</strong>. But so what, right? Computers get faster every year. Well, our computers are now so fast that –  with very few exceptions –  <em>we don't care how much interpreted code costs any more.</em></p>
<p><strong></strong>What many pundits don't realize is that <strong>the viability of interpreted JavaScript for mainstream applications is a relatively recent development</strong>. Consider <a href="http://web.archive.org/web/20060223030711/http://kazdan.com/current/technology/javabenchmark.html">this JavaScript benchmark</a> of "ridiculously long algorithms and looping statements". The top three results are all of 2003 vintage:</p>
<table border="0" cellpadding="4" cellspacing="4">
<tr>
<td style="width: 100px">
AMD 1900+</td>
<td style="width: 100px">
1.6 GHz</td>
<td style="width: 100px">
12.25 sec</td>
</tr>
<tr>
<td style="width: 100px">
P4 Mobile</td>
<td style="width: 100px">
2.2 GHz</td>
<td style="width: 100px">
15.48 sec</td>
</tr>
<tr>
<td style="width: 100px">
P4 Celeron</td>
<td style="width: 100px">
1.4 GHz</td>
<td style="width: 100px">
17.43 sec</td>
</tr>
</table>
<p>The slowest computer I own, a 1.2 GHz Pentium M laptop purchased in 2003, completes this test in 13.64 seconds. The one I'm currently typing on completes it in around 7 seconds. So even in the <em>last three years</em>, we've almost doubled the speed of JavaScript.</p>
<p>I don't expect this trend of doubling performance to continue. <strong>I think JavaScript is about as fast as it can get now without some kind of really advanced dynamic compilation scheme</strong>. If you <a href="http://www.24fun.com/downloadcenter/benchjs/benchjs.html">browse the results of BenchJS</a>, a more recent JavaScript test suite, I think you'll agree that they've plateaued. We might reduce that from 6 seconds to 4 seconds over the next two years, but that's minor compared to the 100x speedup we've already had.</p>
<!--kg-card-end: markdown-->
            </content>
<pubDate>2006-02-07T12:00:00.000Z</pubDate>
<guid>https://blog.codinghorror.com/the-day-performance-didnt-matter-any-more/</guid>
</item>
</channel>
</rss>
