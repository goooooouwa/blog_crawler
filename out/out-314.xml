<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0">
<channel>
<title>Coding Horror</title>
<description>programming and human factors</description>
<link>https://blog.codinghorror.com/</link>
<pubDate>Sun, 19 Apr 2020 00:00:01 GMT</pubDate>
<!-- other elements omitted from this example -->
<item>
<title>Preventing CSRF and XSRF Attacks</title>
<link>https://blog.codinghorror.com/preventing-csrf-and-xsrf-attacks/</link>
<content>
                <!--kg-card-begin: markdown--><p>
In <a href="http://www.codinghorror.com/blog/archives/001171.html">Cross-Site Request Forgeries and You</a> I urged developers <b>to take a close look at possible CSRF / XSRF vulnerabilities on their own websites</b>. They're the worst kind of vulnerability -- very easy to exploit by attackers, yet not so intuitively easy to understand for software developers, at least until you've been bitten by one.
</p>
<p>
On the <a href="http://freedom-to-tinker.com/blog/wzeller/popular-websites-vulnerable-cross-site-request-forgery-attacks">Freedom to Tinker blog</a>, Bill Zeller offers one of the best, most concise explanation of XSRF that I've read to date:
</p>
<p>
</p>
<blockquote>
CSRF vulnerabilities occur when a website allows an authenticated user to perform a sensitive action but does not verify that the user herself is invoking that action. <b>The key to understanding CSRF attacks is to recognize that websites typically don't verify that a request came from an authorized user. Instead they verify only that the request came from the <i>browser</i> of an authorized user.</b> Because browsers run code sent by multiple sites, there is a danger that one site will (unbeknownst to the user) send a request to a second site, and the second site will mistakenly think that the user authorized the request.
</blockquote>
<p>
That's the key element to understanding XSRF. <b>Attackers are gambling that users have a validated login cookie for your website already stored in their browser.</b> All they need to do is get that browser to make a request to your website on their behalf. If they can either:
</p>
<p>
</p>
<ol>
<li>Convince your users to click on a HTML page they've constructed
</li>
<li>Insert arbitrary HTML in a target website that your users visit
</li>
</ol>
<p>
The XSRF game is afoot. Not too difficult, is it?
</p>
<p>
Bill Zeller and Ed Felten also <a href="http://freedom-to-tinker.com/blog/wzeller/popular-websites-vulnerable-cross-site-request-forgery-attacks">identified new XSRF vulnerabilities in four major websites</a> less than two weeks ago:
</p>
<p>
</p>
<ol>
<li>ING Direct
<br><br>
<i>We discovered CSRF vulnerabilities in ING's site that allowed an attacker to open additional accounts on behalf of a user and transfer funds from a user's account to the attacker's account.</i><br>
<br>
</li>
<li>YouTube
<br><br>
<i>We discovered CSRF vulnerabilities in nearly every action a user can perform on YouTube.</i><br><br>
</li>
<li>MetaFilter
<br><br>
<i>We discovered a CSRF vulnerability in MetaFilter that allowed an attacker to take control of a user's account.</i><br><br>
</li>
<li>The New York Times
<br><br>
<i>We discovered a CSRF vulnerability in NYTimes.com that makes user email addresses available to an attacker. If you are a NYTimes.com member, abitrary sites can use this attack to determine your email address and use it to send spam or to identify you.</i><br>
</li>
</ol>
<p>
If major public facing websites are falling prey to these serious XSRF exploits, how confident do you feel that <i>you</i> haven't made the same mistakes? Consider carefully. I'm saying this as a developer who has <i>already</i> made these same mistakes on his own website. <b>I'm just as guilty as anyone.</b>
</p>
<p>
It's our job to make sure future developers don't repeat the same stupid mistakes we made -- at least not without a fight. The <a href="http://freedom-to-tinker.com/sites/default/files/csrf.pdf">Felten and Zeller paper</a> (pdf) recommends the "double-submitted cookie" method to prevent XSRF:
</p>
<p>
</p>
<blockquote>
When a user visits a site, the site should generate a (cryptographically strong) pseudorandom value and set it as a cookie on the user's machine. <b>The site should require every form submission to include this pseudorandom value as a form value and also as a cookie value.</b> When a POST request is sent to the
site, the request should only be considered valid if the form value and the cookie value are the same. When an attacker submits a form on behalf of a user, he can only modify the values of the form. An attacker cannot read any data sent from the server or modify cookie values, <a href="http://developer.mozilla.org/en/Same_origin_policy_for_JavaScript">per the same-origin policy</a>. This means that while an attacker can send any value he wants with the form, he will be unable to modify or read the value stored in the cookie. Since the cookie value and the form value must be the same, the attacker will be unable to successfully submit a form unless he is able to guess the pseudorandom value.
</blockquote>
<p>
The advantage of this approach is that it requires no server state; you simply set the cookie value once, then every HTTP POST checks to ensure that one of the submitted &lt;input&gt; values contains the exact same cookie value. Any difference between the two means a possible XSRF attack.
</p>
<p>
An even stronger, albeit more complex, prevention method is to leverage server state -- <b>to generate (and track, with timeout) a unique random key for every single HTML FORM you send down to the client.</b> We use a variant of this method on Stack Overflow with great success. That's why with every &lt;form&gt; you'll see the following:
</p>
<p>
</p>
<pre>
&lt;input id="fkey" name="fkey" type="hidden" value="df8652852f139" /&gt;
</pre>
<p>
If you want to audit a website for XSRF vulnerabilities, start by asking this simple question about every single HTML form you can find: <b>"where's the XSRF value?"</b>
</p>
<p>
</p>
<p></p>
<!--kg-card-end: markdown-->
            </content>
<pubDate>2008-10-14T12:00:00.000Z</pubDate>
<guid>https://blog.codinghorror.com/preventing-csrf-and-xsrf-attacks/</guid>
</item>
</channel>
</rss>
