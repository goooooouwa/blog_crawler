<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0">
<channel>
<title>Coding Horror</title>
<description>programming and human factors</description>
<link>https://blog.codinghorror.com/</link>
<pubDate>Sun, 19 Apr 2020 00:00:01 GMT</pubDate>
<!-- other elements omitted from this example -->
<item>
<title>Brute Force Key Attacks Are for Dummies</title>
<link>https://blog.codinghorror.com/brute-force-key-attacks-are-for-dummies/</link>
<content>
                <!--kg-card-begin: markdown--><p>
Cory Doctorow recently <a href="http://www.boingboing.net/2006/07/10/analogy_explains_str.html">linked</a> to this <a href="http://www.interesting-people.org/archives/interesting-people/200607/msg00058.html">fascinating email</a> from <a href="http://www.merrymeet.com/jon/">Jon Callas</a>, the <a href="http://www.pgp.com/library/ctocorner/index.html">CTO of PGP corporation</a>. In it, Jon describes <b>the impossibility of brute force attacks on modern cryptography</b>:
</p>
<p>
</p>
<blockquote>
Modern cryptographic systems are essentially unbreakable, particularly if an adversary is restricted to intercepts. We have argued for, designed, and built systems with 128 bits of security precisely because they are essentially unbreakable. It is very easy to underestimate the power of exponentials. 2^128 is a very big number. Burt Kaliski first came up with this characterization, and if he had a nickel for every time I tell it, he could buy a latte or three.
<p>
Imagine a computer that is the size of a grain of sand that can test keys against some encrypted data. Also imagine that it can test a key in the amount of time it takes light to cross it. <b>Then consider a cluster of these computers, so many that if you covered the earth with them, they would cover the whole planet to the height of 1 meter. The cluster of computers would crack a 128-bit key on average in 1,000 years.</b>
</p>
<p>
If you want to brute-force a key, it literally takes a planet-ful of computers. And of course, there are always 256-bit keys, if you worry about the possibility that government has a spare planet that they want to devote to key-cracking.
</p>
</blockquote>
<p>
Each additonal bit doubles the number of keys you have to test in a brute force attack, so by the time you get to 128 or 256 bits, you have a staggeringly large number of potential keys to test. The classic illustration of this <a href="http://en.wikipedia.org/wiki/Exponential_growth#Rice_on_a_chessboard">exponential growth</a> is the fable of the mathematician, the king, and the chess board:
</p>
<p>
</p>
<blockquote>
There is an old Persian legend about a clever courtier who presented a beautiful
chessboard to his king and requested that the king give him in return 1 grain of rice for the first square on the board, 2 grains of rice for the second square, 4 grains for the third, and so forth. The king readily agreed and ordered rice to be brought from his stores. By the fortieth square a million million rice grains had to be brought from the storerooms. The king's entire rice supply was exhausted long before he reached the sixty-fourth square. Exponential increase is deceptive because it generates immense numbers very quickly.
</blockquote>
<p>
By the time you get to that 32nd chessboard square, you're facing a very large number indeed.
</p>
<p>
<img alt="chessboard illustration of exponential growth" border="0" class="at-xid-6a0120a85dcdae970b0120a86d6288970b" height="320" src="https://blog.codinghorror.com/content/images/uploads/2006/07/6a0120a85dcdae970b0120a86d6288970b-pi.png" width="320">
</p>
<p>
However, 2^32 isn't necessarily a very large set of keys when you're performing a brute force attack with a <b>worldwide distributed network of computers</b>. Such as the <a href="http://www.distributed.net/rc5/">RC5 distributed computing project</a>. Here's what they've done so far:
</p>
<ul>
<li>a <b>56-bit</b> key was <a href="http://stats.distributed.net/projects.php?project_id=3">cracked in 250 days</a>.
</li>
<li>a <b>64-bit</b> key was <a href="http://stats.distributed.net/projects.php?project_id=5">cracked in 1,757 days</a>.
</li>
<li>a <b>72-bit</b> key is still being cracked; 1,316 days so far with 379,906 days remaining.
</li>
</ul>
<p>
The earliest 56-bit challenge, which ended in 1997, tested keys at a rate of 1.6 million per second. The ongoing 72-bit challenge is currently testing keys at the rate of 139.2 million per second. We're testing keys 88 times faster than we were 10 years ago, through natural increases in computing power and additional computers added to the distributed computing network.
</p>
<p>
And yet the RC5-72 project <b>still has 1,040 years to go before they test the entire keyspace</b>. Remember, that's for a lousy 72-bit key! If we want to double the amount of time the brute force attack will take, all we need to do is tack on one teeny, tiny little bit to our key. 73-bit key? 2,080 years. 74-bit key? 4,160 years.
</p>
<p>
It's painfully clear that a brute force attack on even a 128 bit key is a fool's errand. Even if you're using a planet covered with computers that crack keys at the speed of light.
</p>
<p>
If you're a smart attacker, <b>you already know that brute force key attacks are strictly for dummies</b> with no grasp of math or time. There are so many other vulnerabilities that are much, much easier to attack:
</p>
<p>
</p>
<ul>
<li>Rootkits
</li>
<li>Social engineering
</li>
<li>Keyloggers
</li>
<li>Obtain the private key file and attack the password on it
</li>
</ul>
<p>
Of course, beyond ruling out brute force attacks, I'm barely scratching the surface here. Jon Callas' Black Hat conference presentation <a href="http://www.blackhat.com/presentations/bh-europe-05/bh-eu-05-callas-up.pdf">Hacking PGP</a> (pdf) goes into much more detail, if you're interested.
</p>
<p>
</p>
<p></p>
<!--kg-card-end: markdown-->
            </content>
<pubDate>2006-07-10T12:00:00.000Z</pubDate>
<guid>https://blog.codinghorror.com/brute-force-key-attacks-are-for-dummies/</guid>
</item>
</channel>
</rss>
