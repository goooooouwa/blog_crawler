<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0">
<channel>
<title>Coding Horror</title>
<description>programming and human factors</description>
<link>https://blog.codinghorror.com/</link>
<pubDate>Sun, 19 Apr 2020 00:00:01 GMT</pubDate>
<!-- other elements omitted from this example -->
<item>
<title>The Infinite Version</title>
<link>https://blog.codinghorror.com/the-infinite-version/</link>
<content>
                <!--kg-card-begin: markdown--><p>
One of the things I like most about Google's Chrome web browser is <a href="http://www.codinghorror.com/blog/2010/09/go-that-way-really-fast.html">how often it is updated</a>. But now that Chrome has rocketed through <a href="http://en.wikipedia.org/wiki/Google_Chrome#Release_history">eleven versions in two and a half years</a>, the thrill of seeing that version number increment has largely worn off. It seems they've picked off all the low hanging fruit at this point and are mostly polishing. The highlights from <b>Version 11</b>, the current release of Chrome?
</p>
<p>
</p>
<blockquote>
HTML5 Speech Input API. Updated icon.
</blockquote>
<p>
Exciting, eh? Though there was no shortage of hand-wringing over the new icon, <a href="http://www.google.com/search?q=new+google+chrome+icon+sucks">of course</a>.
</p>
<p>
Chrome's version number has been changing so rapidly lately that every time someone opens a Chrome bug on a Stack Exchange site, I have to check my version against theirs just to make sure we're still talking about the same software. And once -- I swear I am not making this up -- <i>the version incremented while I was checking the version</i>.
</p>
<p>
<a href="http://twitter.com/#!/codinghorror/status/64432690597871616">
<img alt="another nanosecond, another Chrome version." title="another nanosecond, another Chrome version." src="https://blog.codinghorror.com/content/images/uploads/2011/05/6a0120a85dcdae970b014e889ba13c970d-800wi.png" border="0">
</a>
</p>
<p>
That was the day I officially stopped caring what version Chrome is. I mean, I care in the sense that sometimes <a href="http://www.codinghorror.com/blog/2007/02/whats-in-a-version-number-anyway.html">I need to check its dogtags in battle</a>, but as a regular user of Chrome, I no longer think of myself as using <i>a specific version</i> of Chrome, I just â€¦ use Chrome. Whatever the latest version is, I have it automagically.
</p>
<p>
For the longest time, web browsers have been strongly associated with specific versions. The very mention of Internet Explorer 6 or Netscape 4.77 should send a shiver down the spine of any self-respecting geek. And for good reason! Who can forget what a breakout hit Firefox 3 was, or the epochs that Internet Explorer 7, 8 and 9 represent in Microsoft history. But Chrome? <b>Chrome is so fluid that it has transcended software versioning altogether.</b>
</p>
<p>
<img alt="Chrome-infinite-version" title="Chrome-infinite-version" src="https://blog.codinghorror.com/content/images/uploads/2011/05/6a0120a85dcdae970b0154327b11c0970c-800wi.png" border="0">
</p>
<p>
This fluidity is difficult to achieve for client software that runs on millions of PCs, Macs, and other devices. Google put an extreme amount of engineering effort into making the Chrome auto-update process "just work". They've <a href="http://blog.chromium.org/2009/07/smaller-is-faster-and-safer-too.html">optimized the heck out of the update process</a>.
</p>
<p>
</p>
<blockquote>
Rather then push put a whole new 10MB update [for each version], we send out a diff that takes the previous version of Google Chrome and generates the new version. We tried several binary diff algorithms and have been using bsdiff up until now. We are big fans of <a href="http://www.daemonology.net/bsdiff/">bsdiff</a> - it is small and worked better than anything else we tried.
<p>
But bsdiff was still producing diffs that were bigger than we felt were necessary. So we wrote a new diff algorithm that knows more about the kind of data we are pushing - large files containing compiled executables. Here are the sizes for the recent 190.1 -&gt; 190.4 update on the developer channel:
</p>
<p>
</p>
<ul>
<li>Full update: 10 megabytes
</li>
<li>bsdiff update: 704 kilobytes
</li>
<li>Courgette update: 78 kilobytes
</li>
</ul>
<p>
The small size in combination with Google Chrome's silent update means we can update as often as necessary to keep users safe.
</p>
</blockquote>
<p>
Google's <a href="http://dev.chromium.org/developers/design-documents/software-updates-courgette">Courgette</a> -- the French word for Zucchini, oddly enough -- is an amazing bit of software optimization, capable of producing uncannily small diffs of binary executables. To achieve this, it has to know intimate details about the source code:
</p>
<p>
</p>
<blockquote>
The problem with compiled applications is that even a small source code change causes a disproportional number of byte level changes.  When you add a few lines of code, for example, a range check to prevent a buffer overrun, all the subsequent code gets moved to make room for the new instructions.  The compiled code is full of internal references where some instruction or datum contains the address (or offset) of another instruction or datum.  It only takes a few source changes before almost all of these internal pointers have a different value, and there are a lot of them - roughly half a million in a program the size of chrome.dll.
<p>
The source code does not have this problem because all the entities in the source are symbolic. Functions don't get committed to a specific address until very late in the compilation process, during assembly or linking.  If we could step backwards a little and make the internal pointers symbolic again, could we get smaller updates?
</p>
</blockquote>
<p>
Since the version updates are relatively small, they can be downloaded in the background. But even Google hasn't figured out how to install an update while the browser is running. Yes, there are little alert icons to let you know your browser is out of date, and you eventually do get nagged if you are woefully behind, but <b>updating <i>always</i> requires the browser to restart</b>.
</p>
<p>
<a href="http://www.flickr.com/photos/factoryjoe/4841343705/"><img alt="Please-restart-google-chrome" title="Please-restart-google-chrome" src="https://blog.codinghorror.com/content/images/uploads/2011/05/6a0120a85dcdae970b01538ea83cb9970b-800wi.png" border="0"></a>
</p>
<p>
Web applications have it far easier, but they have version delivery problems, too. Consider WordPress, one of the largest and most popular webapps on the planet. We run WordPress on multiple blogs and even have <a href="http://wordpress.stackexchange.com/">our own WordPress community</a>. WordPress doesn't auto-update to each new version, but it makes it as painless as I've seen for a webapp. Click the update link on the dashboard and WordPress (and its add-ons) update to the latest version all by themselves. There might be the briefest of interruptions in service for visitors to your WordPress site, but then you're back in business with the latest update.
</p>
<p>
<img alt="Wordpress-update" title="Wordpress-update" src="https://blog.codinghorror.com/content/images/uploads/2011/05/6a0120a85dcdae970b014e889bd9cc970d-800wi.png" border="0">
</p>
<p>
<b>WordPress needs everyone to update to the latest versions regularly</b> for the same reasons Google Chrome does -- security, performance, and stability. An internet full of old, unpatched WordPress or Chrome installations is no less dangerous than an internet full of old, unpatched Windows XP machines.
</p>
<p>
These are both relatively seamless update processes. But they're nowhere near as seamless as they <i>should</i> be. <b>One click updates that require notification and restart aren't good enough.</b> To achieve the infinite version, we software engineers have to go a lot deeper.
</p>
<p>
<a href="http://twitter.com/#!/jilliancyork/status/50024539610034176">
<img alt="Twitter-google-docs-infinite-version" title="Twitter-google-docs-infinite-version" src="https://blog.codinghorror.com/content/images/uploads/2011/05/6a0120a85dcdae970b01538ea8419e970b-800wi.png" border="0"></a>
</p>
<p>
Somehow, we have to be able to automatically update software while it is running without interrupting the user at all. <b>Not <i>if</i> -- but <i>when</i> -- the infinite version arrives</b>, our users probably won't even know. Or care. And that's how we'll know we've achieved our goal.
</p>
<p>
<!--kg-card-end: markdown-->
            </p></content>
<pubDate>2011-05-23T03:36:57.000Z</pubDate>
<guid>https://blog.codinghorror.com/the-infinite-version/</guid>
</item>
</channel>
</rss>
