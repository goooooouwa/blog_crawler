<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0">
<channel>
<title>Coding Horror</title>
<description>programming and human factors</description>
<link>https://blog.codinghorror.com/</link>
<pubDate>Sun, 19 Apr 2020 00:00:01 GMT</pubDate>
<!-- other elements omitted from this example -->
<item>
<title>The Sad Tragedy of Micro-Optimization Theater</title>
<link>https://blog.codinghorror.com/the-sad-tragedy-of-micro-optimization-theater/</link>
<content>
                <!--kg-card-begin: markdown--><p>
I'll just come right out and say it: <a href="http://www.codinghorror.com/blog/archives/000634.html">I love strings</a>. As far as I'm concerned, there isn't a problem that I can't solve with a string and <a href="http://www.codinghorror.com/blog/archives/000245.html">perhaps a regular expression or two</a>. But maybe that's just my <a href="http://steve-yegge.blogspot.com/2006/03/math-for-programmers.html">lack of math skills</a> talking.
</p>
<p>
In all seriousness, though, the type of programming we do on <a href="http://stackoverflow.com">Stack Overflow</a> is intimately tied to strings. We're constantly building them, merging them, processing them, or dumping them out to a HTTP stream. Sometimes I even give them relaxing massages. Now, if you've worked with strings at all, you know that this is code you desperately want to avoid writing:
</p>
<p>
</p>
<pre>
static string Shlemiel()
{
string result = "";
for (int i = 0; i &lt; 314159; i++)
{
result += getStringData(i);
}
return result;
}
</pre>
<p>
In most garbage collected languages, strings are immutable: when you add two strings, the contents of both are copied. As you keep adding to <code>result</code> in this loop, more and more memory is allocated each time. This leads directly to <a href="http://www.yafla.com/dforbes/String_Concatenation_and_Immutable_Strings_Speeding_Spidermonkey/">awful quadradic n<sup>2</sup> performance</a>, or as Joel likes to call it, <a href="http://www.joelonsoftware.com/articles/fog0000000319.html">Shlemiel the painter performance</a>.
</p>
<p>
</p>
<blockquote>
Who is Shlemiel? He's the guy in this joke:
<p>
Shlemiel gets a job as a street painter, painting the dotted lines down the middle of the road. On the first day he takes a can of paint out to the road and finishes 300 yards of the road. "That's pretty good!" says his boss, "you're a fast worker!" and pays him a kopeck.
</p>
<p>
The next day Shlemiel only gets 150 yards done. "Well, that's not nearly as good as yesterday, but you're still a fast worker. 150 yards is respectable," and pays him a kopeck.
</p>
<p>
The next day Shlemiel paints 30 yards of the road. "Only 30!" shouts his boss. "That's unacceptable! On the first day you did ten times that much work! What's going on?"
</p>
<p>
"I can't help it," says Shlemiel. "Every day I get farther and farther away from the paint can!"
</p>
</blockquote>
<p>
This is a softball question. You all knew that. <b><i>Every</i> decent programmer knows that string concatenation, while fine in small doses, is deadly poison in loops.</b>
</p>
<p>
But what if you're doing nothing but small bits of string concatenation, dozens to hundreds of times -- as in most web apps? Then you might develop a nagging doubt, as I did, that lots of little Shlemiels could possibly be as bad as one <i>giant</i> Shlemiel.
</p>
<p>
Let's say we wanted to build this HTML fragment:
</p>
<p>
</p>
<pre>
&lt;div class="user-action-time"&gt;stuff&lt;/div&gt;
&lt;div class="user-gravatar32"&gt;stuff&lt;/div&gt;
&lt;div class="user-details"&gt;stuff&lt;br/&gt;stuff&lt;/div&gt;
</pre>
<p>
Which might appear on a given Stack Overflow page anywhere from one to sixty times. And we're serving up hundreds of thousands of these pages per day.
</p>
<p>
Not so clear-cut, now, is it?
</p>
<p>
So, which of these methods of forming the above string do you think is fastest over a hundred thousand iterations?
</p>
<p>
<b>1: Simple Concatenation</b>
</p>
<p>
</p>
<pre>
string s =
@"&lt;div class=""user-action-time""&gt;" <font color="red">+ st() + st()</font> + @"&lt;/div&gt;
&lt;div class=""user-gravatar32""&gt;" + st() + @"&lt;/div&gt;
&lt;div class=""user-details""&gt;" + st() + "&lt;br/&gt;" + st() + "&lt;/div&gt;";
return s;
</pre>
<p>
<b>2: String.Format</b>
</p>
<p>
</p>
<pre>
string s =
@"&lt;div class=""user-action-time""&gt;{0}{1}&lt;/div&gt;
&lt;div class=""user-gravatar32""&gt;{2}&lt;/div&gt;
&lt;div class=""user-details""&gt;{3}&lt;br/&gt;{4}&lt;/div&gt;";
return String.<font color="red">Format</font>(s, st(), st(), st(), st(), st());
</pre>
<p>
<b>3: string.Concat</b>
</p>
<p>
</p>
<pre>
string s =
string.<font color="red">Concat</font>(@"&lt;div class=""user-action-time""&gt;", st(), st(),
@"&lt;/div&gt;&lt;div class=""user-gravatar32""&gt;", st(),
@"&lt;/div&gt;&lt;div class=""user-details""&gt;", st(), "&lt;br/&gt;",
st(), "&lt;/div&gt;");
return s;
</pre>
<p>
<b>4: String.Replace</b>
</p>
<pre>
string s =
@"&lt;div class=""user-action-time""&gt;{s1}{s2}&lt;/div&gt;
&lt;div class=""user-gravatar32""&gt;{s3}&lt;/div&gt;
&lt;div class=""user-details""&gt;{s4}&lt;br/&gt;{s5}&lt;/div&gt;";
s = s.<font color="red">Replace</font>("{s1}", st()).Replace("{s2}", st()).
Replace("{s3}", st()).Replace("{s4}", st()).
Replace("{s5}", st());
return s;
</pre>
<p>
<b>5: StringBuilder</b>
</p>
<p>
</p>
<pre>
var sb = new <font color="red">StringBuilder(256)</font>;
sb.Append(@"&lt;div class=""user-action-time""&gt;");
sb.Append(st());
sb.Append(st());
sb.Append(@"&lt;/div&gt;&lt;div class=""user-gravatar32""&gt;");
sb.Append(st());
sb.Append(@"&lt;/div&gt;&lt;div class=""user-details""&gt;");
sb.Append(st());
sb.Append("&lt;br/&gt;");
sb.Append(st());
sb.Append("&lt;/div&gt;");
return sb.ToString();
</pre>
<p>
Take your itchy little trigger finger off that compile key and <i>think</i> about this for a minute. Which one of these methods will be faster?
</p>
<p>
Got an answer? Great!
</p>
<p>
And.. drumroll please.. the correct answer:
</p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<h1>It. Just. Doesn't. Matter!</h1>
<p>
We already know none of these operations will be performed in a loop, so we can rule out brutally poor performance characteristics of naive string concatenation. All that's left is micro-optimization, and the minute you begin worrying about tiny little optimizations, <a href="http://www.codinghorror.com/blog/archives/000185.html">you've already gone down the wrong path</a>.
</p>
<p>
Oh, you don't believe me? Sadly, I didn't believe it myself, which is why I got drawn into this in the first place. Here are my results -- for 100,000 iterations, on a dual core 3.5 GHz Core 2 Duo.
</p>
<p>
</p>
<table cellpadding="4" cellspacing="4" width="350">
<tr>
<td><b>1: Simple Concatenation</b></td>
<td>606 ms</td>
</tr>
<tr>
<td><b>2: String.Format</b></td>
<td>665 ms</td>
</tr>
<tr>
<td><b>3: string.Concat</b></td>
<td>587 ms</td>
</tr>
<tr>
<td><b>4: String.Replace</b></td>
<td>979 ms</td>
</tr>
<tr>
<td><b>5: StringBuilder</b></td>
<td>588 ms</td>
</tr>
</table>
<p>
Even if we went from the <i>worst</i> performing technique to the best one, we would have saved a lousy 391 milliseconds over a hundred thousand iterations. Not the sort of thing that I'd throw a victory party over. I guess I figured out that using <code>.Replace</code> is best avoided, but even that has some readability benefits that might outweigh the miniscule cost.
</p>
<p>
Now, you might very well ask which of these techniques has the lowest <b>memory usage</b>, <a href="http://blogs.msdn.com/ricom/archive/2004/03/12/88715.aspx">as Rico Mariani did</a>. I didn't get a chance to run these against <code>CLRProfiler</code> to see if there was a clear winner in that regard. It's a valid point, but I doubt the results would change much. In my experience, techniques that abuse memory also tend to take a lot of clock time. Memory allocations are fast on modern PCs, but they're far from free.
</p>
<p>
Opinions vary on just <a href="http://blog.briandicroce.com/2008/02/04/stringbuilder-vs-string-performance-in-net/">how many strings you have to concatenate</a> before you should start worrying about performance. The general consensus is <b>around 10</b>. But you'll also read crazy stuff, like this:
</p>
<p>
</p>
<blockquote>
<b>Don't use += concatenating ever.</b> Too many changes are taking place behind the scene, which aren't obvious from my code in the first place. I advise you to use String.Concat() explicitly with any overload (2 strings, 3 strings, string array). This will clearly show what your code does without any surprises, while allowing yourself to keep a check on the efficiency.
</blockquote>
<p>
Never? Ever? Never ever ever? Not even once? Not even if <i>it doesn't matter?</i> Any time you see "don't ever do X", alarm bells should be going off. Like they hopefully are right now.
</p>
<p>
Yes, you should avoid the obvious beginner mistakes of string concatenation, the stuff every programmer learns their first year on the job. But after that, you should be more worried about the maintainability and readability of your code than its performance. And that is perhaps the most tragic thing about letting yourself get sucked into micro-optimization theater  -- <b>it distracts you from your real goal: writing better code.</b>
</p>
<p>
</p>
<p></p>
<!--kg-card-end: markdown-->
            </content>
<pubDate>2009-01-29T12:00:00.000Z</pubDate>
<guid>https://blog.codinghorror.com/the-sad-tragedy-of-micro-optimization-theater/</guid>
</item>
</channel>
</rss>
