<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0">
<channel>
<title>Coding Horror</title>
<description>programming and human factors</description>
<link>https://blog.codinghorror.com/</link>
<pubDate>Sun, 19 Apr 2020 00:00:01 GMT</pubDate>
<!-- other elements omitted from this example -->
<item>
<title>Fifty Years of Software Development</title>
<link>https://blog.codinghorror.com/fifty-years-of-software-development/</link>
<content>
                <!--kg-card-begin: markdown--><p>
O'Reilly's <a href="http://www.oreilly.com/pub/a/oreilly/news/languageposter_0504.html%0A">History of Programming Languages poster</a> is fascinating reading.
</p>
<p>
<a href="http://www.oreilly.com/pub/a/oreilly/news/languageposter_0504.html%0A"><img alt="Detail from O'Reilly History of Programming Languages poster" border="0" class="at-xid-6a0120a85dcdae970b0128776fe9ec970c" height="354" src="https://blog.codinghorror.com/content/images/uploads/2006/09/6a0120a85dcdae970b0128776fe9ec970c-pi.png" width="498"></a>
</p>
<p>
If you trace programming languages back to their origins, you'll find that <b>we've been at this programming stuff a long, long time.</b> </p>
<p>
</p>
<ul>
<li>
<a href="http://en.wikipedia.org/wiki/Fortran">Fortran</a> (1954)
</li>
<li>
<a href="http://en.wikipedia.org/wiki/COBOL">Cobol</a> (1959)
</li>
<li>
<a href="http://en.wikipedia.org/wiki/Lisp_programming_language">Lisp</a> (1958)
</li>
<li>
<a href="http://en.wikipedia.org/wiki/BASIC_programming_language">Basic</a> (1964)
</li>
<li>
<a href="http://en.wikipedia.org/wiki/Forth_programming_language">Forth</a> (1970)
</li>
<li>
<a href="http://en.wikipedia.org/wiki/Pascal_programming_language">Pascal</a> (1970)
</li>
<li>
<a href="http://en.wikipedia.org/wiki/Smalltalk">SmallTalk</a> (1971)
</li>
<li>
<a href="http://en.wikipedia.org/wiki/C_programming_language">C</a> (1971)
</li>
</ul>
<p>
C is roughly as old as I am; FORTRAN is as old as my parents. But what about the new kids on the block? the TIOBE software <a href="http://www.tiobe.com/tpci.htm%0A">TCPI metrics</a> page provides some data on language popularity going back to the year 2001. Consider the tender age of many of the newest, hippest programming languages:
</p>
<p>
</p>
<ul>
<li>
<a href="http://en.wikipedia.org/wiki/Perl">Perl</a> (1987)
</li>
<li>
<a href="http://en.wikipedia.org/wiki/Python_programming_language">Python</a> (1991)
</li>
<li>
<a href="http://en.wikipedia.org/wiki/Erlang_programming_language">Erlang</a> (1991)
</li>
<li>
<a href="http://en.wikipedia.org/wiki/Ruby_programming_language">Ruby</a> (1993)
</li>
<li>
<a href="http://en.wikipedia.org/wiki/Java_programming_language">Java</a> (1995)
</li>
<li>
<a href="http://en.wikipedia.org/wiki/JavaScript">JavaScript</a> (1995)
</li>
<li>
<a href="http://en.wikipedia.org/wiki/PHP">PHP</a> (1995)
</li>
</ul>
<p>
Ruby is barely a teenager. JavaScript hasn't even hit its teens yet.
</p>
<p>
Now correlate the ages of those modern languages with the publication dates of a few books that represent current thinking in <a href="http://www.codinghorror.com/blog/archives/000643.html">modern software development</a>:
</p>
<p>
</p>
<table>
<tr>
<td>1994</td>
<td>
<a href="http://www.amazon.com/exec/obidos/ASIN/0805353402/codihorr-20">Object-Oriented Design</a> (Booch)
</td>
</tr>
<tr>
<td>1995</td>
<td>
<a href="http://www.amazon.com/exec/obidos/ASIN/0201633612/codihorr-20">Design Patterns</a> (GoF)
</td>
</tr>
<tr>
<td>1997</td>
<td>
<a href="http://www.amazon.com/exec/obidos/ASIN/0321193687/codihorr-20">UML Distilled</a> (Fowler)
</td>
</tr>
<tr>
<td>1999</td>
<td>
<a href="http://www.amazon.com/exec/obidos/ASIN/0321278658/codihorr-20">Extreme Programming Explained</a> (Beck)
</td>
</tr>
<tr>
<td>1999</td>
<td>
<a href="http://www.amazon.com/exec/obidos/ASIN/0201485672/codihorr-20">Refactoring</a> (Fowler)
</td>
</tr>
<tr>
<td>2001</td>
<td>
<a href="http://www.agilealliance.org/">Agile Alliance</a> is formed
</td>
</tr>
</table>
<p>
Modern software development is a recent development. Even though we collectively have over fifty years of experience under our belt, <b>the profession of software development is still very much in its infancy.</b>
</p>
<p>
Consider source control as an example. Source control is the absolute bedrock of software engineering. <b>I believe that source control was not widely prevalent until 1999</b>. Here's why:
</p>
<ol>
<li>Although <a href="http://en.wikipedia.org/wiki/Concurrent_Versions_System">CVS</a> has been around since the late eighties, it was widely popularized through <a href="http://www.sourceforge.org/">SourceForge</a>, which didn't exist until the year 2000.
</li>
<li>Microsoft's SourceSafe was available starting in the mid-90's but didn't hit mainstream acceptance until it was bundled as a part of Visual Studio 6.0 Enterprise in 1998.
</li>
</ol>
<p>
Clearly, source control existed before the year 1999. Why did it take so long for this essential tool of software engineering to filter down to the mainstream? The answer lies in the <a href="http://www.cs.cmu.edu/~Compose/ftp/shaw-fin-etaps.pdf">Redwine-Riddle maturation model</a> (pdf):
</p>
<p>
</p>
<blockquote>
Redwine and Riddle reviewed a number of software technologies to see how they develop and propagate. <b>They found that it typically takes 15-20 years for a technology to evolve from concept formulation to the point where it's ready for popularization.</b>
<p>
They identify six typical phases:
</p>
<ul>
<li>Basic research. Investigate basic ideas and concepts, put initial structure on
the problem, frame critical research questions.
</li>
<li>Concept formulation. Circulate ideas informally, develop a research community, converge on a compatible set of ideas, publish solutions to specific subproblems.
</li>
<li>Development and extension. Make preliminary use of the technology, clarify
underlying ideas, generalize the approach.
</li>
<li>Internal enhancement and exploration. Extend approach to another domain,
use technology for real problems, stabilize technology, develop training materials, show value in results.
</li>
<li>External enhancement and exploration. Similar to internal, but involving a
broader community of people who weren't developers, show substantial evidence
of value and applicability.
</li>
<li>Popularization. Develop production-quality, supported versions of the technology, commercialize and market technology, expand user community.
</li>
</ul>
Redwine and Riddle presented timelines for several software technologies as they progressed through these phases up until the mid-1980s. I presented a similar analysis for the maturation of software architecture in the 1990s.
</blockquote>
<p>
CVS was <a href="http://groups.google.com/groups?:mod.sources.*&amp;ie=UTF-8&amp;c2coff=1&amp;safe=off&amp;selm=122%40mirror.UUCP&amp;rnum=2">released in 1986</a>. It took another fifteen years for CVS usage to become mainstream, <i>exactly as predicted by Redwine-Riddle</i>.
</p>
<p>
The model Redwine-Riddle proposed in 1980 is very much alive today. Mark Dominus, in <a href="http://newbabe.pobox.com/~mjd/blog/prog/design-patterns.html">Design Patterns of 1972</a>, reaches back nearly thirty-five years to illustrate <b>how we're still struggling to evolve our programming languages today</b>:
</p>
<p>
</p>
<blockquote>
Had the "Design Patterns" movement been popular in 1960, its goal would have been to train programmers to recognize situations in which the "subroutine" pattern was applicable, and to implement it habitually when necessary. While this would have been a great improvement over not using subroutines at all, it would have been vastly inferior to what really happened, which was that the "subroutine" pattern was codified and embedded into subsequent languages.
Identification of patterns is an important driver of progress in programming languages. As in all programming, the idea is to notice when the same solution is appearing repeatedly in different contexts and to understand the commonalities. This is admirable and valuable. The problem with the "Design Patterns" movement is the use to which the patterns are put afterward: programmers are trained to identify and apply the patterns when possible. Instead, the patterns should be used as signposts to the failures of the programming language. As in all programming, the identification of commonalities should be followed by an abstraction step in which the common parts are merged into a single solution.
<p>
Multiple implementations of the same idea are almost always a mistake in programming. The correct place to implement a common solution to a recurring design problem is in the programming language, if that is possible.
</p>
<p>
The stance of the "Design Patterns" movement seems to be that it is somehow inevitable that programmers will need to implement Visitors, Abstract Factories, Decorators, and Faades. But these are no more inevitable than the need to implement Subroutine Calls or Object-Oriented Classes in the source language. These patterns should be seen as defects or missing features in Java and C++. <b>The best response to identification of these patterns is to ask what defects in those languages cause the patterns to be necessary, and how the languages might provide better support for solving these kinds of problems.</b>
</p>
</blockquote>
<p>
I do think the pace of change in software development is quickening, thanks to exponential increases in communication over the last fifty years-- television, satellites, cellular phones, and of course the internet. As software developers, we've grown accustomed to computer hardware doubling in speed every 18 months. What we haven't been able to cope with so well is <b>how long it takes for the human beings to catch up with the hardware</b>.
</p>
<p>
</p>
<p></p>
<!--kg-card-end: markdown-->
            </content>
<pubDate>2006-09-20T12:00:00.000Z</pubDate>
<guid>https://blog.codinghorror.com/fifty-years-of-software-development/</guid>
</item>
</channel>
</rss>
