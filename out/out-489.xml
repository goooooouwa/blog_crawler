<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0">
<channel>
<title>Coding Horror</title>
<description>programming and human factors</description>
<link>https://blog.codinghorror.com/</link>
<pubDate>Sun, 19 Apr 2020 00:00:01 GMT</pubDate>
<!-- other elements omitted from this example -->
<item>
<title>Embracing Languages Inside Languages</title>
<link>https://blog.codinghorror.com/embracing-languages-inside-languages/</link>
<content>
                <!--kg-card-begin: markdown--><p>
Martin Fowler <a href="http://www.martinfowler.com/bliki/FluentInterface.html">loosely defines a fluent interface</a> thusly: "The more the use of the API has that language like flow, the more fluent it is." If you detect a whiff of skepticism here, you're right: I've never seen this work. <a href="http://www.codinghorror.com/blog/archives/000672.html">Computer languages aren't human languages</a>.
</p>
<p>
</p>
<p>
Let's look at a concrete example <a href="http://flimflan.com/blog/ReadableRegularExpressions.aspx">from Joshua Flanagan</a>. Here's how we define a regular expression in the standard way:
</p>
<p>
</p>
<pre>
&lt;divs*class="game"s*id="(?&lt;gameID&gt;d+)-game"(?&lt;content&gt;.*?)
&lt;!--gameStatuss*=s*(?&lt;gameState&gt;d+)--&gt;
</pre>
<p>
Here's how we'd define that same regular expression in Joshua's fluent interface.
</p>
<p>
</p>
<pre>
Pattern findGamesPattern = Pattern.With.Literal(@"&lt;div")
.WhiteSpace.Repeat.ZeroOrMore
.Literal(@"class=""game""").WhiteSpace.Repeat.ZeroOrMore.Literal(@"id=""")
.NamedGroup("gameId", Pattern.With.Digit.Repeat.OneOrMore)
.Literal(@"-game""")
.NamedGroup("content", Pattern.With.Anything.Repeat.Lazy.ZeroOrMore)
.Literal(@"&lt;!--gameStatus")
.WhiteSpace.Repeat.ZeroOrMore.Literal("=").WhiteSpace.Repeat.ZeroOrMore
.NamedGroup("gameState", Pattern.With.Digit.Repeat.OneOrMore)
.Literal("--&gt;");
</pre>
<p>
So <b>we're replacing a nice, succinct one line regular expression with ten lines of objects, methods, and named enumerations.</b> This is progress?
</p>
<p>
I'll grant you that I am probably unusually familiar with regular expressions, even by developer standards. There's a reason they have a reputation for being dense and inscrutable. I've definitely <a href="http://www.codinghorror.com/blog/archives/000214.html">seen some incredibly bad regular expressions</a> in my day. But in my professional opinion, that regex was a well written one. I had no problem reading it. Adding a ton of hyper-dense object wrappers to that regex makes it <i>harder</i> for me to understand what it does.
</p>
<p>
The new syntax Joshua invented is great, but it's specific to his implementation. Although it may seem like a good idea to use these kinds of training wheels to "learn" regular expressions, I'd argue that you aren't learning them at all. And that's a shame, because regular expression syntax is a mini-language of its own. Once you learn it, you can use it anywhere; it works (<a href="http://www.regular-expressions.info/refext.html">almost</a>) the same in every environment.
</p>
<p>
The <a href="http://www.subsonicproject.com">Subsonic project</a> attempts to do something similar for SQL. Consider this SQL query:
</p>
<p>
</p>
<pre>
SELECT * from Customers WHERE Country = "USA"
ORDER BY CompanyName
</pre>
<p>
Here's how we would express that same SQL query in SubSonic's fluent interface:
</p>
<p>
</p>
<pre>
CustomerCollection c = new CustomerCollection();
c.Where(Customer.Columns.Country, "USA");
c.OrderByAsc(Customer.Columns.CompanyName);
c.Load();
</pre>
<p>
I've mentioned before that <a href="http://www.codinghorror.com/blog/archives/000617.html">I'm no fan of object-oriented rendering</a> when a simple string will suffice. That's exactly the reaction I had here; why in the world would I want to use four lines of code instead of one? This seems like a particularly egregious example. <b>The SQL is harder to write and more difficult to understand when it's wrapped in all that proprietary SubSonic object noise.</b> Furthermore, if you don't learn the underlying SQL-- and how databases work-- you're in serious trouble as a software developer.
</p>
<p>
But I can see the rationale behind these types of database code generation tools:
</p>
<p>
</p>
<ol>
<li>They "solve" <a href="http://www.codinghorror.com/blog/archives/000621.html">the object-relational mapping problem</a> for you (and if you believe that, I have a bridge you might be interested in)
</li>
<li>you get intellisense
</li>
<li>your database is strongly typed
</li>
<li>the compiler now "understands" the database, or at least the generated classes that represent the database.
</li>
</ol>
<p>
I definitely sympathize with the desire to produce less code, and that's the whole point of database code generation tools. Personally, I would argue that most of these benefits could be realized with smarter IDEs that actually understood native SQL strings (or regular expressions), rather than relying on a slew of generated code and complicated, proprietary object syntax.
</p>
<p>
But let's take a step back and think about what's <i>really</i> happening here. In both cases, <b>we are embedding one language inside another</b>. SQL is a language. Regular expressions are a language. Wrapping those languages inside a bunch of mega-verbose fluent interface ObjectJunk-- just so we can pretend we're writing code in our primary language-- is a <i>total cop-out</i>. Fluent interface object wrappers feel like a nasty hack to me.
</p>
<p>
Why can't we embrace the language-inside-a-language paradigm, rather than running and hiding from it? These domain specific languages exist because they are optimized for processing strings and data efficiently. Avoiding them is counterproductive.
</p>
<p>
Perhaps the ultimate solution is to <b>redefine the underlying language to incorporate the features of another language</b>.
</p>
<p>
Consider how Perl integrates the regular expression language:
</p>
<p>
</p>
<pre>
while (my $line = &lt;IN&gt;) {
while ( $line =~ /(Romeo|Juliet|Mercutio|Tybalt|Friar w+)/g ) {
my $character = $1;
++$counts{ $character };
}
}
</pre>
<p>
Here's how C# 3.0, with <a href="http://en.wikipedia.org/wiki/Language_Integrated_Query">LINQ</a>, integrates the SQL language:
</p>
<p>
</p>
<pre>
var c = from Customer in Customers
where Customer.Country == "USA"
orderby Customer.CompanyName
select Customer;
</pre>
<p>
Note the conspicuous lack of ObjectJunk. No explosion at the parens and periods factory. No MassivelyLongTextEnumerations to deal with. There's nothing but code that <i>looks like exactly what it does</i>. And that's a beautiful thing. </p>
<p>
<b>Embrace the idea of languages inside languages</b>. In The Land of Strings, we speak regular expressions. In The Land of Data, we speak SQL. Oh sure, you can pretend those languages don't exist, and hide out in the <a href="http://steve-yegge.blogspot.com/2006/03/execution-in-kingdom-of-nouns.html">Kingdom of Nouns</a>-- but you're only cheating yourself out of a deeper understanding of how things <i>really</i> work in those other places. Fluent interface object wrappers may seem like a helpful convenience, but they're actually an ugly hack, and a terrible substitute for true language integration.
</p>
<p>
</p>
<p></p>
<!--kg-card-end: markdown-->
            </content>
<pubDate>2007-10-30T13:00:00.000Z</pubDate>
<guid>https://blog.codinghorror.com/embracing-languages-inside-languages/</guid>
</item>
</channel>
</rss>
