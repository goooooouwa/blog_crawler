<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0">
<channel>
<title>Coding Horror</title>
<description>programming and human factors</description>
<link>https://blog.codinghorror.com/</link>
<pubDate>Sun, 19 Apr 2020 00:00:01 GMT</pubDate>
<!-- other elements omitted from this example -->
<item>
<title>Beyond RAID</title>
<link>https://blog.codinghorror.com/beyond-raid/</link>
<content>
                <!--kg-card-begin: markdown--><p>
I've always been <a href="http://www.codinghorror.com/blog/archives/000335.html">leery of RAID on the desktop</a>. But on the server, RAID is <a href="http://en.wikipedia.org/wiki/RAID">a definite must</a>:
</p>
<p>
</p>
<blockquote>
"RAID" is now used as an umbrella term for computer data storage schemes that can divide and replicate data among multiple hard disk drives. The different schemes/architectures are named by the word RAID followed by a number, as in RAID 0, RAID 1, etc. <b>RAID's various designs all involve two key design goals: increased data reliability or increased input/output performance.</b> When multiple physical disks are set up to use RAID technology, they are said to be in a RAID array. This array distributes data across multiple disks, but the array is seen by the computer user and operating system as one single disk.
</blockquote>
<p>
I hadn't worked much at all with RAID, as I felt the benefits did not outweigh the risks on the desktop machines I usually build. But the rules are different in the datacenter; the <a href="http://blog.stackoverflow.com/category/server/">servers I built for Stack Overflow</a> <i>all</i> use various forms of RAID, from RAID 1 to RAID 6 to RAID 10. While working with these servers, I was surprised to discover there are now umpteen zillion numbered variants of RAID -- but they all appear to be based on a few basic, standard forms:
</p>
<p>
<b>RAID 0: Striping</b>
</p>
<p>
Data is striped across (n) drives, which improves performance almost linearly with the number of drives, but at a steep cost in fault tolerance; a failure of any single striped drive renders the entire array unreadable.
</p>
<p>
<img alt="raid-0-diagram.png" class="at-xid-6a0120a85dcdae970b012877707aff970c" height="202" src="https://blog.codinghorror.com/content/images/uploads/2009/05/6a0120a85dcdae970b012877707aff970c-pi.png" width="295">
</p>
<p>
<b>RAID 1: Mirroring</b>
</p>
<p>
Data is written across (n) drives, which offers near-perfect redundancy at a slight performance decrease when writing -- and at the cost of half your overall storage. As long as one drive in the mirror array survives, no data is lost.
</p>
<p>
<img alt="raid-1-diagram.png" class="at-xid-6a0120a85dcdae970b012877707b15970c" height="203" src="https://blog.codinghorror.com/content/images/uploads/2009/05/6a0120a85dcdae970b012877707b15970c-pi.png" width="300">
</p>
<p>
<b>Raid 5: Parity</b>
</p>
<p>
Data is written across (n) drives with a <a href="http://en.wikipedia.org/wiki/Parity_bit">parity block</a>. The array can tolerate one drive failure, at the cost of one drive in storage. There may be a serious performance penalty when writing (as parity and blocks are calculated), and when the array is rebuilding.
</p>
<p>
<img alt="raid-5-diagram.png" class="at-xid-6a0120a85dcdae970b012877707b2c970c" height="202" src="https://blog.codinghorror.com/content/images/uploads/2009/05/6a0120a85dcdae970b012877707b2c970c-pi.png" width="450">
</p>
<p>
<b>Raid 6: Dual Parity</b>
</p>
<p>
Data is written across (n) drives with two <a href="http://en.wikipedia.org/wiki/Parity_bit">parity blocks</a>. The array can tolerate two drive failures, at the cost of two drives in storage. There may be a serious performance penalty when writing (as parity and blocks are calculated), and when the array is rebuilding.
</p>
<p>
<img alt="raid-6-diagram.png" class="at-xid-6a0120a85dcdae970b012877707b37970c" height="204" src="https://blog.codinghorror.com/content/images/uploads/2009/05/6a0120a85dcdae970b012877707b37970c-pi.png" width="600">
</p>
<p>
(yes, there are other forms of RAID, but they are rarely implemented or used as far as I can tell.)
</p>
<p>
It's also possible to generate so-called <b>RAID 10</b> or <b>RAID 50</b> arrays by <a href="http://en.wikipedia.org/wiki/Nested_RAID_levels">nesting these RAID levels together</a>. If you take four hard drives, stripe the two pairs, then mirror the two striped arrays -- why, you just created yourself a magical RAID 10 concoction! What's <i>particularly</i> magical about RAID 10 is that it inherits the strengths of both of its parents: mirroring provides excellent redundancy, and striping provides excellent speed. Some would say that <a href="http://weblogs.sqlteam.com/billg/archive/2007/06/18/RAID-10-vs.-RAID-5-Performance.aspx">RAID 10 is so good it completely obviates any need for RAID 5</a>, and I for one agree with them.
</p>
<p>
This was all fascinating new territory to me; I knew about RAID in theory but had never spent hands-on time with it. The above is sufficient as a primer, but I recommend <a href="http://en.wikipedia.org/wiki/RAID">reading through the wikipedia entry on RAID</a> for more depth.
</p>
<p>
It's worth mentioning here that <b><a href="http://www.google.com/search?q=raid+is+not+a+backup">RAID is in no way a substitute for a sane backup regimen</a></b>, but rather a way to offer improved uptime and survivability for your existing systems. Hard drives are cheap and getting cheaper every day -- why not use a whole slew of the things to get better performance <i>and</i> better reliability for your servers? That's always been the point of Redundant Array of Inexpensive Disks, as far as I'm concerned. I guess Sun agrees; check out <a href="http://techreport.com/discussions.x/13849">this monster</a>:
</p>
<p>
<a href="http://techreport.com/discussions.x/13849"><img alt="sun-x4500-top.jpg" border="0" class="at-xid-6a0120a85dcdae970b012877707b4e970c" height="416" src="https://blog.codinghorror.com/content/images/uploads/2009/05/6a0120a85dcdae970b012877707b4e970c-pi.jpg" width="407"></a>
</p>
<p>
That's right, 48 commodity SATA drives in a massive array, courtesy of the <a href="http://www.sun.com/servers/x64/x4500/">Sun Sunfire X4500</a>. It also uses a new RAID system <a href="http://blogs.sun.com/bonwick/entry/raid_z">dubbed RAID-Z</a>:
</p>
<p>
</p>
<blockquote>
RAID-Z is a data/parity scheme like RAID-5, but it uses dynamic stripe width. Every block is its own RAID-Z stripe, regardless of blocksize. This means that every RAID-Z write is a full-stripe write. This, when combined with the copy-on-write transactional semantics of ZFS, completely eliminates the RAID write hole. RAID-Z is also faster than traditional RAID because it never has to do read-modify-write.
<p>
But far more important, going through the metadata means that ZFS can validate every block against its 256-bit checksum as it goes. Traditional RAID products can't do this; they simply XOR the data together blindly.
</p>
<p>
Which brings us to the coolest thing about RAID-Z: self-healing data. In addition to handling whole-disk failure, RAID-Z can also detect and correct silent data corruption. Whenever you read a RAID-Z block, ZFS compares it against its checksum. If the data disks didn't return the right answer, ZFS reads the parity and then does combinatorial reconstruction to figure out which disk returned bad data. It then repairs the damaged disk and returns good data to the application. ZFS also reports the incident through Solaris FMA so that the system administrator knows that one of the disks is silently failing.
</p>
<p>
Finally, note that RAID-Z doesn't require any special hardware. It doesn't need NVRAM for correctness, and it doesn't need write buffering for good performance. With RAID-Z, ZFS makes good on the original RAID promise: it provides fast, reliable storage using cheap, commodity disks.
</p>
</blockquote>
<p>
Pardon the pun, but I'm not sure if it makes traditional hardware RAID <i>redundant</i>, necessarily. Even so, there are certainly fantastic, truly next-generation ideas in ZFS. There's a great <a href="http://queue.acm.org/detail.cfm?id=1317400">ACM interview with the creators of ZFS</a> that drills down into much more detail. Hard drives may be (mostly) dumb hunks of spinning rust, but it's downright amazing what you can do when you get a whole bunch of them working together.
</p>
<p>
</p>
<p></p>
<!--kg-card-end: markdown-->
            </content>
<pubDate>2009-05-26T12:00:00.000Z</pubDate>
<guid>https://blog.codinghorror.com/beyond-raid/</guid>
</item>
</channel>
</rss>
