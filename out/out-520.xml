<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0">
<channel>
<title>Coding Horror</title>
<description>programming and human factors</description>
<link>https://blog.codinghorror.com/</link>
<pubDate>Sun, 19 Apr 2020 00:00:01 GMT</pubDate>
<!-- other elements omitted from this example -->
<item>
<title>Classic Computer Science Puzzles</title>
<link>https://blog.codinghorror.com/classic-computer-science-puzzles/</link>
<content>
                <!--kg-card-begin: markdown--><p>
Software developers do have a proclivity for puzzles. Perhaps that's why     books like <a href="http://www.amazon.com/exec/obidos/ASIN/0394534913/codihorr-20">
To Mock a Mockingbird</a> exist. It's a collection of logic puzzles which is considered an introduction to <a href="http://users.bigpond.net.au/d.keenan/Lambda/">
lambda calculus</a>, one of the core concepts of <a href="http://en.wikipedia.org/wiki/Lisp_programming_language">
Lisp</a>.
</p>
<p><a href="http://www.amazon.com/exec/obidos/ASIN/0394534913/codihorr-20"><img alt="To Mock a Mockingbird" border="0" class="at-xid-6a0120a85dcdae970b0120a86daaa8970b" height="240" src="https://blog.codinghorror.com/content/images/uploads/2007/09/6a0120a85dcdae970b0120a86daaa8970b-pi.png" width="156"></a></p>
<p>
Such puzzle questions are <a href="http://www.codinghorror.com/blog/archives/000628.html">
<em>de rigueur</em> for many programming interviews</a>, though they're
often abused. There is a downside to thinking of programming languages as solutions
to arbitrarily difficult abstract mathematical puzzles. That's probably why Lisp has <a href="http://damienkatz.net/2007/01/the_volkswagen.html">
a rich reputation for being powerful but simultaneously dense and impenetrable</a>.</p>
<p>
I prefer to think of
programming languages as utilitarian tools for <strong>real world problems</strong>.
They let me accomplish pragmatic (and often
prosaic) goals. PHP is about as unsexy
a language as you'll ever find, but does that matter when it's the technology driving the current Boardwalk
and Park Place of the web world? I'm not a fan of puzzle questions in interviews;
I'd rather have potential developers <a href="http://www.codinghorror.com/blog/archives/000226.html">
give me a presentation</a> or <a href="http://www.codinghorror.com/blog/archives/000781.html">
write a reasonably useful program</a> in the real development environment
they'll be using on the job. Solve all the puzzles you want, but the only one we're
getting <em>paid </em>to solve is the customer's problem.</p>
<p>
That said, <strong>many fundamental computer science concepts can be summarized
well in puzzle form</strong>, which aids tremendously in teaching and learning these key
concepts. Here's a quick list of the <strong>classic computer science puzzles</strong>
that I remember from my university days:</p>
<table cellpadding="12" cellspacing="12" width="100%">
<tr>
<td valign="top">
<a href="http://en.wikipedia.org/wiki/Dining_philosophers_problem">Dining Philosophers</a><br>
<strong>
Concurrency and Deadlocks</strong><br>
<img alt="dining philosophers problem" border="0" class="at-xid-6a0120a85dcdae970b0120a86daac7970b" height="133" src="https://blog.codinghorror.com/content/images/uploads/2007/09/6a0120a85dcdae970b0120a86daac7970b-pi.png" width="240">
</td>
<td valign="middle">
Five philosophers sit around a circular table. In front of each philosopher is a
large plate of rice. The philosophers alternate their time between eating and thinking.
There is one chopstick between each philosopher, to their immediate right and left.
In order to eat, a given philosopher needs to use both chopsticks. How can you ensure
all the philosophers can eat reliably without starving to death?</td>
</tr>
<tr>
<td valign="top">
<a href="http://en.wikipedia.org/wiki/Travelling_salesman_problem">Travelling Salesman</a><br>
<strong>P=NP</strong><br>
<img alt="travelling salesman problem" border="0" class="at-xid-6a0120a85dcdae970b0120a86daae3970b" height="119" src="https://blog.codinghorror.com/content/images/uploads/2007/09/6a0120a85dcdae970b0120a86daae3970b-pi.png" width="300">
</td>
<td valign="middle">
A salesperson has a route of cities that make up his or her beat. What's the most efficient
sales route that visits each city exactly once, and then returns to the
home city?</td>
</tr>
<tr>
<td valign="top">
<a href="http://en.wikipedia.org/wiki/Eight_queens_puzzle">Eight Queens</a><br>
<strong>
Algorithm Design<br>
</strong>
<img alt="eight-queens.png" border="0" class="at-xid-6a0120a85dcdae970b0120a86dab02970b" height="109" src="https://blog.codinghorror.com/content/images/uploads/2007/09/6a0120a85dcdae970b0120a86dab02970b-pi.png" width="215">
</td>
<td valign="middle">
Given eight queens on a standard 8 x 8 chessboard, how many unique positions-- exclusive of rotations and mirror images-- can those eight queens occupy without attacking each other?</td>
</tr>
<tr>
<td valign="top">
<a href="http://en.wikipedia.org/wiki/Two_Generals%27_Problem">Two Generals</a><br>
<strong>
Communication Protocols</strong><br>
<img alt="two generals problem" border="0" height="91" src="http://www.codinghorror.com/blog/images/two-generals-problem.png" width="292">
</td>
<td valign="middle">
Two armies, each led by a general, are preparing to attack a city. The armies are
encamped outside the city on two mountains separated by a large valley. In order
to capture the city, the generals must attack at exactly the same time. The only
way for the generals to communicate is by sending messengers through the valley.
Unfortunately, the valley is occupied by the city's defenders, so there's a chance
any given messenger will be captured. Each general has no way of knowing if their
messenger arrived. How do the generals coordinate their attack?</td>
</tr>
<tr>
<td valign="top">
<a href="http://en.wikipedia.org/wiki/Tower_of_Hanoi">Towers of Hanoi</a><br>
<strong>
Recursion<br>
</strong>
<img alt="towers-of-hanoi.png" border="0" class="at-xid-6a0120a85dcdae970b0120a86dab15970b" height="162" src="https://blog.codinghorror.com/content/images/uploads/2007/09/6a0120a85dcdae970b0120a86dab15970b-pi.png" width="300">
</td>
<td valign="middle">
You have a stack of discs, from largest to smallest, that slide on to the first
peg of a three peg board. Your goal is to move the entire stack of discs from the
first peg to the third peg. However, you can only move the topmost disc of any peg,
and smaller discs must always be placed on larger discs. How many moves will it
take?Â </td>
</tr>
</table>
<p></p>
<p>
I consider this the "greatest hits" of classic computer science puzzles. But I'm
sure I've forgotten a few. Are there any other puzzles I've missed that express fundamental computer
science concepts, the type that would be taught in a typical undergraduate computer
science course?</p>
<p><script type="text/javascript">google_ad_client = &quot;pub-6424649804324178&quot;;google_ad_slot = &quot;8324348970&quot;;google_ad_width = 728;google_ad_height = 90;</script><script src="http://pagead2.googlesyndication.com/pagead/show_ads.js" type="text/javascript"></script>
</p>
<p></p>
<p></p>
<!--kg-card-end: markdown-->
            </content>
<pubDate>2007-09-12T12:00:00.000Z</pubDate>
<guid>https://blog.codinghorror.com/classic-computer-science-puzzles/</guid>
</item>
</channel>
</rss>
