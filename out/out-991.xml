<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0">
<channel>
<title>Coding Horror</title>
<description>programming and human factors</description>
<link>https://blog.codinghorror.com/</link>
<pubDate>Sun, 19 Apr 2020 00:00:01 GMT</pubDate>
<!-- other elements omitted from this example -->
<item>
<title>A Stopwatch Class for .NET 1.1</title>
<link>https://blog.codinghorror.com/a-stopwatch-class-for-net-11/</link>
<content>
                <!--kg-card-begin: markdown--><p>
The first rule of performance testing is to measure, then measure again, then measure one more time just to be sure. NET 2.0 adds a handy <a href="http://msdn2.microsoft.com/en-us/library/system.diagnostics.stopwatch.aspx">Diagnostics.Stopwatch</a> which is perfect for this kind of ad-hoc precision timing.
</p>
<p>
A year ago I created a Stopwatch class which was eerily similar to the one that Microsoft ended up shipping in .NET 2.0. I went ahead and <b>made the minor modifications necessary to make my Stopwatch class identical to Microsoft's</b>. This way you can use the object in .NET 1.1 and port your code as-is to .NET 2.0 with only a namespace change.
</p>
<p>
</p>
<pre language="c#">
using System;
/// &lt;summary&gt;
/// Provides a set of methods and properties that you can use to accurately
/// measure elapsed time.
/// &lt;/summary&gt;
public class Stopwatch
{
[System.Runtime.InteropServices.DllImport("Kernel32")]
static extern bool QueryPerformanceCounter(out long @ref);
[System.Runtime.InteropServices.DllImport("Kernel32")]
static extern bool QueryPerformanceFrequency(out long @ref);
private long _Start = 0;
private long _Elapsed = 0;
private bool _IsRunning = false;
/// &lt;summary&gt;
/// the current performance-counter frequency, in counts per second
/// &lt;/summary&gt;
readonly private long _CounterFrequency;
public Stopwatch()
{
/// prelinks all win32 api calls so there's less performance hit when called
System.Runtime.InteropServices.Marshal.PrelinkAll(typeof(Stopwatch));
if (QueryPerformanceFrequency(out _CounterFrequency) == false)
{
throw new Exception("High resolution timers are not available on this CPU");
}
}
/// &lt;summary&gt;
/// Starts, or resumes, measuring elapsed time for an interval.
/// &lt;/summary&gt;
public void Start()
{
if (_IsRunning) this.Stop();
_Start = this.CurrentTime;
_IsRunning = true;
}
/// &lt;summary&gt;
/// Stops measuring elapsed time for an interval.
/// &lt;/summary&gt;
public void Stop()
{
if (!_IsRunning) return;
_Elapsed += this.CurrentTime - _Start;
_Start = 0;
_IsRunning = false;
}
/// &lt;summary&gt;
/// Stops time interval measurement and resets elapsed time span to zero.
/// &lt;/summary&gt;
public void Reset()
{
if (_IsRunning) this.Stop();
_Elapsed = 0;
}
/// &lt;summary&gt;
/// retrieves the current value of the high-resolution performance counter.
/// &lt;/summary&gt;
private long CurrentTime
{
get
{
long l = 0;
QueryPerformanceCounter(out l);
return l;
}
}
/// &lt;summary&gt;
/// Indicates whether the Stopwatch timer is running.
/// &lt;/summary&gt;
public bool IsRunning
{
get { return (_IsRunning); }
}
/// &lt;summary&gt;
/// Gets the total elapsed time measured by the current instance.
/// &lt;/summary&gt;
public TimeSpan Elapsed
{
get { return new TimeSpan(this.ElapsedTicks); }
}
/// &lt;summary&gt;
/// Gets the total elapsed time measured by the current instance, in milliseconds
/// &lt;/summary&gt;
public long ElapsedMilliseconds
{
get
{
if (_Elapsed == 0) return 0;
return (long)(((double)_Elapsed / _CounterFrequency) * 1000);
}
}
/// &lt;summary&gt;
/// Gets the total elapsed time measured by the current instance, in timer ticks
/// &lt;/summary&gt;
public long ElapsedTicks
{
get
{
return (long)(this.ElapsedMilliseconds * TimeSpan.TicksPerMillisecond);
}
}
}
</pre>
<p>
Did you ever wonder <b>how the QueryPerformance* Win32 API functions work their magic</b> and provide accurate near-nanosecond timing results? There's some <a href="http://www.mattwalsh.com/twiki/bin/view/Main/HighFrequencyCounterInC">interesting trivia about these functions</a> on Matt Walsh's wiki.
</p>
<p>
</p>
<p></p>
<!--kg-card-end: markdown-->
            </content>
<pubDate>2005-12-06T12:00:00.000Z</pubDate>
<guid>https://blog.codinghorror.com/a-stopwatch-class-for-net-11/</guid>
</item>
</channel>
</rss>
