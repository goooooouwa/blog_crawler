<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0">
<channel>
<title>Coding Horror</title>
<description>programming and human factors</description>
<link>https://blog.codinghorror.com/</link>
<pubDate>Sun, 19 Apr 2020 00:00:01 GMT</pubDate>
<!-- other elements omitted from this example -->
<item>
<title>The Build Server: Your Project's Heart Monitor</title>
<link>https://blog.codinghorror.com/the-build-server-your-projects-heart-monitor/</link>
<content>
                <!--kg-card-begin: markdown--><p>
Although I've been <a href="http://www.codinghorror.com/blog/archives/000149.html">dismissive of build servers</a> in the past, I've increasingly come to believe that <b>the build server is critical-- it's the heart monitor of your software project</b>. It can tell you when your project is healthy, and it can give you advance warning when your project is about to flatline.
</p>
<p>
<img alt="a heart monitor" border="0" class="at-xid-6a0120a85dcdae970b0120a86d70a7970b" height="170" src="https://blog.codinghorror.com/content/images/uploads/2006/10/6a0120a85dcdae970b0120a86d70a7970b-pi.jpg" width="247">
</p>
<p>
You should start out with a simple pulse-- <b>whether or not your project builds, and how often you're building it</b>. The build server can be so much more, though. The Zutubi article <a href="http://zutubi.com/products/pulse/articles/buildenlightenment/">The Path to Build Enlightenment</a> provides a great overview of what a build server can do for your project:
</p>
<p>
</p>
<ul>
<li>
<b>Machine independence</b><p>
Let's get past "It runs on my machine" first. The build server retrieves everything from source control, and builds on a machine untainted by developer dependencies. It forces an integration point for all the developers working on the project, in a neutral, indifferent way. You can hate your co-workers, but it's irrational to hate the build server.
</p>
<p>
</p>
</li>
<li>
<b>Scripted Builds</b><p>
Your build process is now clearly defined by a script and under source control. You might say it's almost.. self-documenting. Isn't that the way it should be?
</p>
<p>
</p>
</li>
<li>
<b>Scripted tests</b><p>
Sure, maybe all the code compiles. But does the software actually <i>work</i>? The build server is a logical place to integrate some basic tests to see if your product is doing what it's supposed to do. Mere compilation is not enough. The more tests you accrete into the build over time, the better the feedback is from the build, and the more valuable it will be to your project. It's a positive reinforcement cycle.
</p>
<p>
</p>
</li>
<li>
<b>Daily and Weekly builds</b><p>
Once you have the build server set up, you'll establish a rhythm for your project, where you're building regularly. When something breaks, you'll know, and quickly. A solid heartbeat from the build server leads to a confident development team.
</p>
<p>
</p>
</li>
<li>
<b>Continuous Integration</b><p>
This is the holy grail of build server integration-- doing a complete build every time something is checked into source control. Once you've gotten your feet wet with weekly and daily builds, it's the next logical step. It also forces you to keep your test and build times reasonable so things can proceed quickly.
</p>
<p>
</p>
</li>
<li>
<b>Automated releases</b><p>
The build server automates all the drudge work associated with releasing software. It..
</p>
<p>
</p>
<ol>
<li>labels the source code with the build number
</li>
<li>creates a uniquely named drop folder for that particular build
</li>
<li>tags the binaries with the build number in the file metadata
</li>
<li>creates installation packages and installers
</li>
<li>publishes the installs to websites, FTP sites, or file paths
</li>
</ol>
</li>
<p>
A well-designed, fully-automated build process makes it trivially easy for anyone to get a particular release, or to go back in time to a previous release. And it's less work for you when the build machine does it.
</p>
<p>
</p>
<li>
<b>Building in multiple environments</b><p>
For advanced projects only. If you have to test your code against 10 different languages, or different variants of an operating system, consider integrating those tests into the build process. It's painful, but so is that much ad-hoc testing.
</p>
<p>
</p>
</li>
<li>
<b>Static and Dynamic Analysis</b><p>
There's an entire universe of analysis tools that you can run on your code during the build to produce the <a href="http://www.codinghorror.com/blog/archives/000681.html">wall of metrics</a>. FxCop, nDepends, LibCheck, and so forth. There are lots of metrics, and only you and your team can decide what's important to you. But some of these metrics are really clutch. At the very least, <a href="http://research.microsoft.com/research/pubs/view.aspx?type=Publication&amp;id=1359">you'll want to know how much code churn</a> you have for each build.
</p>
<p>
</p>
</li>
</ul>
<p>
If you don't have a build server on your project, what are you waiting for?
</p>
<p>
</p>
<p></p>
<!--kg-card-end: markdown-->
            </content>
<pubDate>2006-10-26T12:00:00.000Z</pubDate>
<guid>https://blog.codinghorror.com/the-build-server-your-projects-heart-monitor/</guid>
</item>
</channel>
</rss>
