<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0">
<channel>
<title>Coding Horror</title>
<description>programming and human factors</description>
<link>https://blog.codinghorror.com/</link>
<pubDate>Sun, 19 Apr 2020 00:00:01 GMT</pubDate>
<!-- other elements omitted from this example -->
<item>
<title>Bridges, Software Engineering, and God</title>
<link>https://blog.codinghorror.com/bridges-software-engineering-and-god/</link>
<content>
                <!--kg-card-begin: markdown--><p>
Based on the number of times I've seen the comparison come up in my career, you might think that bridge building and software development were related in some way:
</p>
<p>
</p>
<blockquote><i>
[..] <a href="http://www.bae.ncsu.edu/people/faculty/cfabrams/">my Dad</a>, who is a "real" engineer, is out visiting for a few days. We got talking tonight about the essence of real engineering and attempted to understand if software development is approaching the level of say mechanical or chemical engineering in terms of maturity of the field. (<a href="http://blogs.msdn.com/brada/archive/2005/03/07/389182.aspx">Brad Abrams</a>)
</i></blockquote>
<p>
</p>
<blockquote><i>
[..] building software is an immature engineering discipline, which most notably shows in our lack of ability to make true black boxes. "Classical" engineering, like building bridges, dams, and other structures, has mastered the art of specifying components to such a degree that they can be described with only a few parameters. In the art of software engineering, we do not have this down yet. (<a href="http://www.leune.org/blog/kees/2005-04-21_SoftwareEngineering">Kees Leune</a>)
</i></blockquote>
<p>
</p>
<blockquote><i>
"Our standards have inappropriately been lowered by our daily experience," said Ken Jacobs, Oracle's vice president of product strategy. "We have to bring software engineering the kind of maturity we have in building bridges and buildings. We don't expect buildings to fall down every day."
</i></blockquote>
<p>
I find these discussions extremely frustrating, because <b>I don't think bridge building has anything in common with software development.</b>* It's a specious comparison. Software development is only like bridge building if you're building a bridge on the planet Jupiter, out of newly invented materials, using construction equipment that didn't exist five years ago.
</p>
<p>
<a href="http://www.integer-software.co.uk/software-in-action/butterfly-bridge.htm"><img alt="Butterfly Bridge" border="0" class="at-xid-6a0120a85dcdae970b0128776fb600970c" height="305" src="https://blog.codinghorror.com/content/images/uploads/2005/05/6a0120a85dcdae970b0128776fb600970c-pi.jpg" width="443"></a>
</p>
<p>
Traditional bridge-building engineering disciplines are based on God's rules-- physics. Rules that have been absolute and unchanging for the last million years. Software "engineering", however, is based on whatever some random bunch of guys thought was a good idea in the early 1980's. We don't have the luxury of working within a known universe. <b>God didn't invent x86.</b> That makes the comparison with traditional engineering disciplines tenuous at best. More than half of everything I know will be obsolete in ten years; can any civil engineer say that?
</p>
<p>
In <a href="http://www.geocities.com/tablizer/science.htm">"Computer Science" is Not Science and "Software Engineering" is Not Engineering</a>, B. Jacobs proposes that software is more like math:
</p>
<p>
</p>
<blockquote>
So, if physical engineering is applied science, but software design does not follow the same pattern, then what is software design? <b>Perhaps it is math. Math is not inherently bound to the physical world.</b> Some contentiously argue that it is bound because it may not necessarily be valid in hypothetical or real alternative universe(s) that have rules stranger than we can envision, but for practical purposes we can generally consider it independent of the known laws of physics, nature, biology, etc.
<p>
The most useful thing about math is that it can create nearly boundless models. These models may reflect the known laws of nature, or laws that the mathematician makes up. Math has the magical property of being able to create alternative universes with alternative realities. The only rule is that these models must have an internal consistency: they can't contradict their own rules. (Well, maybe they can, but they are generally much less useful if they do, like a program that always crashes.)
</p>
<p>
Software is a lot like math, and perhaps software is math <a href="http://en.wikipedia.org/wiki/The_Cruelty_of_Really_Teaching_Computer_Science">according to some definitions</a>. The fact that we can use software to create alternative realities is manifested in the gaming world. Games provide entertainment by creating virtual realities to reflect actual reality to varying degrees but bend reality in hopefully interesting ways. A popular example is <a href="http://thesims.ea.com/us/">The Sims</a>, a game that simulates social interaction in society, not just physical movements found in typical "action" games.
</p>
</blockquote>
<p>
The hypothesis that software is mathematics is certainly more credible. But like Rory, <a href="http://neopoleon.com/blog/posts/13166.aspx">I'm not even convinced that math and software are all that similar</a>:
</p>
<p>
</p>
<blockquote>
When I was growing up, I remember hearing people say things like, "If you like computer programming, then you'll love math." I always thought that these people were absolutely nuts. While there is something intrinsically similar about certain types of math and computer programming, the two are different in many more ways than they are similar.
<p>
With math, and I'm not talking about the crazy number-theory math philosophy "Do numbers really exist?" side of things, but with the applied stuff, there are correct answers. You're either correct or you're incorrect.
</p>
<p>
With coding, the best you can hope for is to do something well. With so many different ways to effect a single outcome, it's up to some very right-brained sensibilities to determine if you've met your goal, as there isn't anybody (except [another more experienced developer]) who can tell you if you're right or not.
</p>
<p>
If you ignore your right brain, and I'm talking generally about abstraction and aesthetics, then you can slap some code together that might work, but it also might be one hell of a maintenance nightmare. If you focus only on the right brain, you might have something that works, but is so utterly inefficient and personalized that you're the only person on Earth who could make sense of the code and maintain it.
</p>
</blockquote>
<p>
Unlike math, software can't be objectively, formally verified to be correct. Or even good, for that matter.
</p>
<p>
Software development is unquestionably a profession, but <b>I don't think we can learn as much from the fields of mathematics or traditional engineering as is so often assumed.</b> However, we do have a lot to learn from ourselves. Disseminating best practices to other developers is our biggest challenge, not adapting processes from unrelated industries. I recommend reading through this <a href="http://www.itconversations.com/transcripts/82/transcript82-1.html">recent interview with Steve McConnell</a> for his thoughts on how much the field of software development has advanced in the last 10 years-- and how to keep advancing.
</p>
<p>
* However, it is fun to <a href="http://www.chroniclogic.com/index.htm?pontifex2.htm">build bridges in software!</a>
</p>
<p>
</p>
<p></p>
<!--kg-card-end: markdown-->
            </content>
<pubDate>2005-05-22T12:00:00.000Z</pubDate>
<guid>https://blog.codinghorror.com/bridges-software-engineering-and-god/</guid>
</item>
</channel>
</rss>
