<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0">
<channel>
<title>Coding Horror</title>
<description>programming and human factors</description>
<link>https://blog.codinghorror.com/</link>
<pubDate>Sun, 19 Apr 2020 00:00:01 GMT</pubDate>
<!-- other elements omitted from this example -->
<item>
<title>Perfmon Gone Wild</title>
<link>https://blog.codinghorror.com/perfmon-gone-wild/</link>
<content>
                <!--kg-card-begin: markdown--><p>
When diagnosing server performance problems, the first tool I turn to is the <a href="http://www.codinghorror.com/blog/archives/000162.html">humble Task Manager</a>. That's usually enough to get a rough idea of where we are in the bottleneck shell game: is it CPU, Disk, Network or Memory?
</p>
<p>
But sometimes you need to dig into performance a little deeper. Then it's time to drag out Performance Monitor. I always resist doing this for as long as I can because using perfmon is like trying to sip from a fire hose: there are a zillion performance counters that produce veritable mountains of data. The .NET framework has <a href="http://msdn.microsoft.com/library/default.asp?url=/library/en-us/cpgenref/html/gngrfperformancecounters.asp">probably a hundred .NET-specific performance counters</a>, and that's just a tiny fraction of the <a href="http://www.microsoft.com/technet/prodtechnol/windowsserver2003/library/DepKit/3fb01419-b1ab-4f52-a9f8-09d5ebeb9ef2.mspx">available operating system performance counters</a>. It's downright overwhelming. Where to begin?
</p>
<p>
Microsoft provides a helpful <a href="http://www.microsoft.com/downloads/details.aspx?FamilyID=31FCCD98-C3A1-4644-9622-FAA046D69214&amp;displaylang=en">performance monitor wizard</a> which walks you through the process of setting up a perfmon trace with default counters. Per the Wizard, that's the following:
</p>
<p>
</p>
<pre>
Cache*
Memory*
Network Interface(*)*
Objects*
Paging File(*)*
Physical Disk(*)*
Process(*)*
Processor(*)*
Redirector*
Server Work Queues(*)*
Server*
System*
</pre>
<p>
Once created, the trace can be stopped, started or modified via the <b>Computer Management / System Tools / Performance Logs and Alerts / Counter Logs</b> interface. Here's what the default wizard-produced trace looks like:
</p>
<p>
<img alt="perfmon, or modern art?" border="0" class="at-xid-6a0120a85dcdae970b0128776fb146970c" height="542" src="https://blog.codinghorror.com/content/images/uploads/2005/08/6a0120a85dcdae970b0128776fb146970c-pi.gif" width="819">
</p>
<p>
It's perfmon gone wild!
</p>
<p>
This is way, way, WAY too much information. Let's see if we can narrow it down to some key performance counters:
</p>
<p>
</p>
<ul>
<li>
<b>Processor(_Total)% Processor Time</b><br>
The percentage of elapsed time that the processor spends to execute a non-Idle thread. <a href="http://www.microsoft.com/resources/documentation/Windows/2000/server/reskit/en-us/Default.asp?url=/resources/documentation/Windows/2000/server/reskit/en-us/core/fned_ana_jzel.asp">(more)</a>
</li>
<li>
<b>Processor(_Total)Interrupts/sec</b><br>
An indirect indicator of the activity of hardware devices that generate interrupts, such as the system clock, the mouse, disk drivers, data communication lines, network interface cards, and other peripheral devices. <a href="http://www.microsoft.com/resources/documentation/Windows/2000/server/reskit/en-us/Default.asp?url=/resources/documentation/Windows/2000/server/reskit/en-us/core/fned_ana_jzel.asp">(more)</a>
</li>
<li>
<b>SystemProcessor Queue Length</b><br>
The number of non-running ready threads in the processor queue. There is a single queue for processor time even on computers with multiple processors. If a computer has multiple processors, you need to divide this value by the number of processors servicing the workload. A sustained processor queue of less than 10 threads per processor is normally acceptable, depending on workload. <a href="http://www.microsoft.com/resources/documentation/Windows/2000/server/reskit/en-us/Default.asp?url=/resources/documentation/Windows/2000/server/reskit/en-us/core/fned_ana_jzel.asp">(more)</a>
</li>
<li>
<b>MemoryAvailable Bytes</b><br>
The amount of physical memory, in bytes, available to processes running on the computer. Calculated by adding the amount of space on the Zeroed, Free, and Standby memory lists. <a href="http://www.microsoft.com/resources/documentation/Windows/2000/server/reskit/en-us/Default.asp?url=/resources/documentation/Windows/2000/server/reskit/en-us/core/fned_ana_jzel.asp">(more)</a>
</li>
<li>
<b>Process(All_processes)Working Set</b><br>
The set of recently touched memory pages for all processes. If free memory in the computer is above a threshold, pages are left in the Working Set of a process even if they are not in use.  When free memory falls below a threshold, pages are trimmed from Working Sets. If they are needed they will then be soft-faulted back into the Working Set before leaving main memory. <a href="http://www.microsoft.com/resources/documentation/Windows/2000/server/reskit/en-us/Default.asp?url=/resources/documentation/Windows/2000/server/reskit/en-us/core/fned_ana_jzel.asp">(more)</a>
</li>
<li>
<b>MemoryPages/sec</b><br>
The rate at which pages are read from or written to disk to resolve hard page faults. This is a primary indicator of the kinds of faults that cause system-wide delays. It includes pages retrieved to satisfy faults in the file system cache. <a href="http://www.microsoft.com/resources/documentation/Windows/2000/server/reskit/en-us/Default.asp?url=/resources/documentation/Windows/2000/server/reskit/en-us/core/fned_ana_jzel.asp">(more)</a>
</li>
<li>
<b>PhysicalDisk% Disk Time</b><br>
The percentage of elapsed time that the selected disk drive was busy servicing read or write requests. <a href="http://www.microsoft.com/resources/documentation/Windows/2000/server/reskit/en-us/Default.asp?url=/resources/documentation/Windows/2000/server/reskit/en-us/core/fned_ana_jzel.asp">(more)</a>
</li>
<li>
<b>PhysicalDiskCurrent Disk Queue Length</b><br>
The number of requests outstanding on the disk at the time the performance data is collected. Requests experience delays proportional to the length of this queue minus the number of spindles on the disks. For good performance, this difference should average less than two. <a href="http://www.microsoft.com/resources/documentation/Windows/2000/server/reskit/en-us/Default.asp?url=/resources/documentation/Windows/2000/server/reskit/en-us/core/fned_ana_jzel.asp">(more)</a>
</li>
<li>
<b>ServerBytes Received/sec</b><br>
The number of bytes the server has received from the network.
</li>
<li>
<b>ServerBytes Transmitted/sec</b><br>
The number of bytes the server has sent on the network.
</li>
</ul>
<p>
Those counters should be enough to give you a general sense of whether you're dealing with a disk, memory, CPU, or network bottleneck-- without being too overwhelming.
</p>
<p>
If you need to capture more performance counters than this, I suggest switching the counter log to CSV output via the properties dialog. Then download Microsoft's excellent <a href="http://www.microsoft.com/downloads/details.aspx?FamilyID=890cd06b-abf8-4c25-91b2-f8d975cf8c07&amp;displaylang=en">LogParser tool</a>. Now you can slice, dice, and even graph the data however you like using a relatively simple SQL-like syntax.
</p>
<p>
</p>
<p></p>
<!--kg-card-end: markdown-->
            </content>
<pubDate>2005-08-10T12:00:00.000Z</pubDate>
<guid>https://blog.codinghorror.com/perfmon-gone-wild/</guid>
</item>
</channel>
</rss>
