<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0">
<channel>
<title>Coding Horror</title>
<description>programming and human factors</description>
<link>https://blog.codinghorror.com/</link>
<pubDate>Sun, 19 Apr 2020 00:00:01 GMT</pubDate>
<!-- other elements omitted from this example -->
<item>
<title>Pressing the Software Turbo Button</title>
<link>https://blog.codinghorror.com/pressing-the-software-turbo-button/</link>
<content>
                <!--kg-card-begin: markdown--><p>
Does anyone remember <a href="http://www.pcguide.com/ref/case/switchTurbo-c.html">the Turbo Button</a> from older IBM PC models?
</p>
<p>
</p>
<blockquote>
A leftover from machines of five to ten years ago, the turbo switch still remains on many cases, even though it serves no purpose.
<p>
In the early days of the PC, there was only IBM, and there were only a handful of different speeds a PC could run at. Early software was written by programmers who believed they were writing it to run on a machine of a specific speed. When newer, faster machines would come out, some of this software (especially games) would stop working properly because it would run too fast. Turning off the "turbo" function of the PC (which meant anything that made it run faster than an IBM of a particular era) would make the machine run slower so this software would work. In essence, it was a "compatibility mode" feature, to slow down the machine for older software.
</p>
<p>
<img alt="IBM PC compatible with turbo button" border="0" class="at-xid-6a0120a85dcdae970b0120a86def7d970b" height="298" src="https://blog.codinghorror.com/content/images/uploads/2008/12/6a0120a85dcdae970b0120a86def7d970b-pi.jpg" width="400">
</p>
<p>
Now there are dozens of different combinations of processor types and speeds. Software cannot rely on knowing the speed of the machine, so most programs use speed-detection algorithms. The turbo button no longer serves any useful purpose. On many motherboards there either isn't anywhere to connect it, or there is a place but the motherboard does nothing when you press the button. The best use for this button is to never touch it, or use it for some other purpose. Some older machines will still slow down when the button is pressed, and if you press it by accident your machine will lose performance. It can be surprisingly hard to track down the problem; the front of the machine is the last place anyone appears to notice anything.
</p>
</blockquote>
<p>
I, too, remember the Turbo Button, although by the time I got heavily into PCs in the early 1990's it was already well in decline. <b>The strange thing about a turbo button is that you'd pretty much <i>always want it on</i></b>; there's almost no situation where you'd want to keep some power in reserve for that extra "oomph" required by, say, a particularly intensive Lotus 1-2-3 spreadsheet. You wanted your PC to run at full tilt, maximum possible speed, all the time.
</p>
<p>
I think this hardware philosophy is also true of software, and it applies at both ends of software development:
</p>
<p>
</p>
<ul>
<li>Developers need <a href="http://www.codinghorror.com/blog/archives/000666.html">fast machines to be productive</a>.
</li>
<li>Agile software development practices work best when you <a href="http://www.codinghorror.com/blog/archives/000788.html">iterate rapidly</a>.
</li>
<li>Users <a href="http://www.codinghorror.com/blog/archives/000722.html">prefer software that's responsive</a>.
</li>
</ul>
<p>
Whether you're a coder or a user, performance is a <i>hugely</i> important feature, <a href="http://thecodist.com/article/turbo_productivity_in_programming_is_the_only_thing%0A">as the codist notes</a>:
</p>
<p>
</p>
<blockquote>
In my first job at a defense contractor, I met a couple guys (I thought they were old but they were probably my age now!) who had been writing code since the late 50's and then writing batch applications on an IBM mainframe. Since they could only compile/run once per day (and get the printouts the next day) they would work on 6-8 projects at the same time and weren't concerned when these projects might take years to complete. After two weeks on this I was ready to go insane and got switched to working on a supermini which at least had a realtime operating system. I could write code, compile it and run it at the same time. The only drawback was we had 7 people sharing one terminal at the start. Suggestions that each programmer get a terminal were laughed at initially. Being productive in such a limited time was really hard.
<p>
After a couple years I switched to working on PCs (which were just out) and having my own "computer" was wonderful. Working in Pascal and assembly still wasn't fast yet but at least I had my own space.
</p>
<p>
Then I got Turbo Pascal and life was forever changed. I could write, compile and debug applications virtually instantly and my need for speed has never looked back. Even on the compared-to-today crappy hardware I never really found another environment as fast until I started using PHP this year (which of course has no compilation).
</p>
<p>
Later when I started Mac coding in C we started off with a dreadful C compiler/linker that took 20 minutes to do its thing. When Think-C came out it was almost a Turbo moment again. Eventually it began to get slower and slower and we swtich to Metrowerks Codewarrior which was fast but the applications were getting so big that it still took 30-60 seconds to build sometimes.
</p>
<p>
When I moved to Java in 1998 compiling and linking still took a fairly long time until the IDEs (and the JVM) began to catch up to the hardware. <b>Still nothing was ever as instant as Turbo had been, despite the hardware being 100x faster.</b>
</p>
</blockquote>
<p>
I'm a speed freak too. As far as I'm concerned, everything on a PC should happen instantaneously. Or at least as close to instantaneous as the laws of physics will allow. Simply doing everything <i>faster</i>, all other things being equal, will allow you to get more done. I'm not alone in this; Fred Brooks made a similar observation <a href="http://www.codinghorror.com/blog/archives/000026.html">way back in The Mythical Man-Month</a>:
</p>
<p>
</p>
<blockquote>
There is not yet much evidence available on the true fruitfulness of such apparently powerful tools. There is a widespread recognition that debugging is the hard and slow part of system programming, and slow turnaround is the bane of debugging. So the logic of interactive programming seems inexorable.
<p>
Further, we hear good testimonies from many who have built little systems or parts of systems in this way. The only numbers I have seen for effects on programming of large systems were reported by John Harr of Bell Labs. [..] <b>Harr's data suggest that an interactive facility at least doubles productivity in system programming.</b>
</p>
</blockquote>
<p>
Never underestimate the power of <b>pressing the software turbo button</b>. What's keeping you from going as fast as you can? As a user? As a software developer?
</p>
<p>
</p>
<p></p>
<!--kg-card-end: markdown-->
            </content>
<pubDate>2008-12-23T12:00:00.000Z</pubDate>
<guid>https://blog.codinghorror.com/pressing-the-software-turbo-button/</guid>
</item>
</channel>
</rss>
