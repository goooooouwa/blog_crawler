<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0">
<channel>
<title>Coding Horror</title>
<description>programming and human factors</description>
<link>https://blog.codinghorror.com/</link>
<pubDate>Sun, 19 Apr 2020 00:00:01 GMT</pubDate>
<!-- other elements omitted from this example -->
<item>
<title>How Should We Teach Computer Science?</title>
<link>https://blog.codinghorror.com/how-should-we-teach-computer-science/</link>
<content>
                <!--kg-card-begin: markdown--><p>
<a href="http://www.cs.toronto.edu/~gvwilson">Greg Wilson</a> recently emailed me the following question:
</p>
<p>
</p>
<blockquote>
I'm teaching a software engineering class to third-year students at the University of Toronto starting in January, and would like to include at least one hour on deployment --- <b>[deployment] never came up in any of my classes, and it's glossed over pretty quickly in most software engineering textbooks</b>, but I have learned the hard way that it's often as big a challenge as getting the application written in the first place.
</blockquote>
<p>
Deployment is a huge hurdle. It's a challenge even for the best software development teams, and it's incredibly important: if users can't get past the install step, none of the code you've written matters! And yet, as Greg notes, existing software engineering textbooks give this crucial topic only cursory treatment. Along the same lines, a few weeks ago, a younger coworker noted to me in passing that <b>he never learned anything about source control</b> in any of his computer science classes. How could that be? Source control is the very <a href="http://www.codinghorror.com/blog/archives/000643.html">bedrock of software engineering</a>.
</p>
<p>
If we aren't teaching fundamental software engineering skills like deployment and source control in college today, we're <b>teaching computer science the wrong way</b>. What good is learning to write code in the abstract if you can't work on that code as a team in a controlled environment, and you can't deploy the resulting software? As so many computer science graduates belatedly figure out after landing their first real programming job, it isn't any good at all.
</p>
<p>
Today's computer science students should <b>develop software under conditions as close as possible to the real world</b>, or the best available approximation thereof. Every line of code should be written under source control at all times. This is not negotiable. When it's time to deploy the code, try deploying to a commercial shared web host, and discovering everything that entails. If it's an executable, create a standalone installer package that users have to download, install, and then have some mechanism to file bug reports when they inevitably can't get it to work. Students should personally follow up on each bug filed for the software they've written.
</p>
<p>
Will this be painful? Boy, oh boy, will it ever. It'll be <i>excruciating</i>. Students will hate it. They'll begin to question why anyone in their right mind would want to write software.
</p>
<p>
Welcome to the real world.
</p>
<p>
After I wrote my response to Greg, Joel Spolsky posted an <a href="http://www.joelonsoftware.com/items/2008/01/08.html">entry on computer science education</a> that, at least to my eye, seemed hauntingly similar to the advice I offered:
</p>
<p>
</p>
<blockquote>
I think the solution would be to create a programming-intensive BFA in Software Development -- a Julliard for programmers. Such a program would consist of a practical studio requirement developing significant works of software on teams with very experienced teachers, with a sprinkling of liberal arts classes for balance.
<p>
When I said BFA, Bachelor of Fine Arts, I meant it: software development is an art, and the existing Computer Science education, where you're expected to learn a few things about NP completeness and Quicksort is singularly inadequate to training students how to develop software.
</p>
<p>
Imagine instead an undergraduate curriculum that consists of 1/3 liberal arts, and 2/3 software development work. The teachers are experienced software developers from industry. The studio operates like a software company. You might be able to <b>major in Game Development and work on a significant game title, for example, and that's how you spend most of your time, just like a film student spends a lot of time actually making films and the dance students spend most of their time dancing.</b>
</p>
</blockquote>
<p>
This is not to say that computer science programs should neglect theory. Fundamental concepts such as algorithms and data structures are still important. My algorithms class was my favorite and by <i>far</i> the most useful class I ever took for my own computer science degree. But teaching these things at the <i>expense</i> of neglecting more prosaic real world software engineering skills-- skills that you'll desperately need as a practicing software developer-- is a colossal mistake. It's what Steve Yegge was alluding to in his <a href="http://steve-yegge.blogspot.com/2006/07/wizard-school.html">fantastical Wizard School essay</a>.. I think.
</p>
<p>
There is the concern that all those highfalutin' computer science degrees could degenerate into little more than vocational school programs, something Joel mentioned in his <a href="http://www.joelonsoftware.com/items/2007/12/03.html">excellent Yale address</a>:
</p>
<p>
</p>
<blockquote>
At Ivy League institutions, everything is Unix, functional programming, and theoretical stuff about state machines. As you move down the chain to less and less selective schools Java starts to appear. Move even lower and you literally start to see classes in topics like Microsoft Visual Studio 2005 101, three credits. By the time you get to the 2 year institutions, you see the same kind of SQL-Server-in-21-days "certification" courses you see advertised on the weekends on cable TV. Isn't it time to start your career in (different voice) Java Enterprise Beans!
</blockquote>
<p>
You can have it both ways. That's why I'm so gung-ho for internships. College CS classes tend to be so dry and academic that you <i>must</i> spend your summers working in industry, otherwise you won't have the crucial software engineering skills you'll need to survive once you graduate. Unimportant little things like, say, source control and deployment and learning to deal with users.  I constantly harp on internships whenever I meet college students pursuing a computer science degree. It's for your own good.
</p>
<p>
It does strike me as a bit unfair to force students to rely on internships to complete their education in computer science. Or, perhaps, something even worse. "Want to learn computer science? No college necessary! Just download some ISO images and found your own social networking startup!" Unleashing the naked greed of the TechCrunch crowd on tender young programming minds seems downright cruel.
</p>
<p>
So <b>how should we teach computer science?</b> The more cynical among us might say <a href="http://www.codinghorror.com/blog/archives/000635.html">you can't</a>. I think that's a cop-out. If students want to prepare themselves for a career in software development, they need to shed the theory and spend a significant portion of their time creating software with all the warty, prickly, unglamorous bits included. Half of software engineering is pain mitigation. If you aren't cursing your web hosting provider every week, fighting with your source control system every day, deciphering angry bug reports from your users every hour-- you aren't being taught computer science.
</p>
<p>
</p>
<p></p>
<!--kg-card-end: markdown-->
            </content>
<pubDate>2008-01-12T12:00:00.000Z</pubDate>
<guid>https://blog.codinghorror.com/how-should-we-teach-computer-science/</guid>
</item>
</channel>
</rss>
