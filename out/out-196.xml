<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0">
<channel>
<title>Coding Horror</title>
<description>programming and human factors</description>
<link>https://blog.codinghorror.com/</link>
<pubDate>Sun, 19 Apr 2020 00:00:01 GMT</pubDate>
<!-- other elements omitted from this example -->
<item>
<title>The Paper Data Storage Option</title>
<link>https://blog.codinghorror.com/the-paper-data-storage-option/</link>
<content>
                <!--kg-card-begin: markdown--><p>
As programmers, <a href="http://www.codinghorror.com/blog/archives/000178.html">we regularly work with text encodings</a>. But there's another sort of encoding at work here, one we process so often and so rapidly that it's invisible to us, and we forget about it. I'm talking about <b>visual encoding -- translating the visual glyphs of the alphabet you're reading right now</b>. The alphabet is no different than any other optical machine readable input, except the machines are <i>us</i>.
</p>
<p>
But how efficient is the alphabet at encoding information on a page? Consider some of the alternatives -- different visual representations of data you could print on a page, or display on a monitor:
</p>
<p>
<a href="http://en.wikipedia.org/wiki/Punched_card#IBM_80_column_punch_card_format">5081 punch card</a><br>
up to 80 alphanumeric characters
</p>
<p>
<img alt="codinghorror-5081-punch-card.png" class="at-xid-6a0120a85dcdae970b0120a86e2e26970b" height="280" src="https://blog.codinghorror.com/content/images/uploads/2009/07/6a0120a85dcdae970b0120a86e2e26970b-pi.png" width="607">
</p>
<p>
<a href="http://en.wikipedia.org/wiki/MaxiCode">Maxicode</a><br>
up to 93 alphanumeric characters
</p>
<p>
<img alt="codinghorror-maxicode.png" class="at-xid-6a0120a85dcdae970b0120a86e2e55970b" height="236" src="https://blog.codinghorror.com/content/images/uploads/2009/07/6a0120a85dcdae970b0120a86e2e55970b-pi.png" width="245">
</p>
<p>
<a href="http://en.wikipedia.org/wiki/Data_matrix_%28computer%29">Data Matrix</a><br>
up to 2,335 alphanumeric characters
</p>
<p>
<img alt="codinghorror-datamatrix.png" class="at-xid-6a0120a85dcdae970b0120a86e2e7d970b" height="113" src="https://blog.codinghorror.com/content/images/uploads/2009/07/6a0120a85dcdae970b0120a86e2e7d970b-pi.png" width="114">
</p>
<p>
<a href="http://en.wikipedia.org/wiki/QR_Code">QR Code</a><br>
up to 4,296 alphanumeric characters
</p>
<p>
<img alt="codinghorror-qr-code.png" class="at-xid-6a0120a85dcdae970b0120a86e2ea4970b" height="126" src="https://blog.codinghorror.com/content/images/uploads/2009/07/6a0120a85dcdae970b0120a86e2ea4970b-pi.png" width="124">
</p>
<p>
<a href="http://en.wikipedia.org/wiki/Aztec_Code">Aztec Code</a><br>
up to 3,067 alphanumeric characters
</p>
<p>
<img alt="codinghorror-aztec-code.png" height="99" src="http://www.codinghorror.com/blog/images/codinghorror-aztec-code.png" width="99">
</p>
<p>
<a href="http://en.wikipedia.org/wiki/High_Capacity_Color_Barcode">High Capacity Color Barcode</a><br>
varies by # of color and density; up to 3,500 characters per square inch
</p>
<p>
<img alt="codinghorror-microsoft-tag.png" height="197" src="http://www.codinghorror.com/blog/codinghorror-microsoft-tag.png" width="200">
</p>
<p>
Printed page<br>
about 10,000 characters per page
</p>
<p>
<img alt="alice-printed-page.png" class="at-xid-6a0120a85dcdae970b0120a86e2edd970b" height="503" src="https://blog.codinghorror.com/content/images/uploads/2009/07/6a0120a85dcdae970b0120a86e2edd970b-pi.png" width="400">
</p>
<p>
Paper the way we typically use it is criminally inefficient. It has a ton of wasted data storage space. That's where programs like <a href="http://ollydbg.de/Paperbak/">PaperBack</a> come in:
</p>
<p>
</p>
<blockquote>
PaperBack is a free application that allows you to back up your precious files on ordinary paper in the form of oversized bitmaps. <b>If you have a good laser printer with the 600 dpi resolution, you can save up to 500,000 bytes of uncompressed data on a single sheet.</b>
<p>
You may ask - why? Why, for heaven's sake, do I need to make paper backups, if there are so many alternative possibilities like CD-R's, DVDÂ±R's, memory sticks, flash cards, hard disks, streaming tapes, ZIP drives, network storage, magneto-optical cartridges, and even 8-inch double-sided floppy disks formatted for DEC PDP-11? The answer is simple: you don't. However, by looking on CD or magnetic tape, you are not able to tell whether your data is readable or not. You must insert your medium into the drive, if you even have one, and try to read it.
</p>
<p>
Paper is different. Do you remember punched cards? For years, cards were the main storage medium for the source code. I agree that 100K+ programs were... inconvenient, but hey, only real programmers dared to write applications that large. And used cards were good as notepads, too. Punched tapes were also common. And even the most weird encodings, like <a href="http://en.wikipedia.org/wiki/CDC_display_code">CDC</a> or <a href="http://en.wikipedia.org/wiki/Extended_Binary_Coded_Decimal_Interchange_Code">EBCDIC</a>, were readable by humans (I mean, by real programmers).
</p>
<p>
Of course, bitmaps produced by PaperBack are also human-readable (with the small help of any decent microscope). I'm joking. What you need is a scanner attached to your PC.
</p>
</blockquote>
<p>
PaperBack, like many of the other visual encodings listed above, includes provisions for:
</p>
<p>
</p>
<ul>
<li>compression -- to increase the amount of data stored in a given area.
</li>
<li>redundancy -- in case part of the image becomes damaged or is otherwise unreadable.
</li>
<li>encryption -- to prevent the image from being readable by anyone except the intended recipient.
</li>
</ul>
<p>
<img alt="paperback-options.png" class="at-xid-6a0120a85dcdae970b0120a86e2f05970b" height="253" src="https://blog.codinghorror.com/content/images/uploads/2009/07/6a0120a85dcdae970b0120a86e2f05970b-pi.png" width="389">
</p>
<p>
Sure, it's still paper, but the digital "alphabet" you're putting on that paper is a far more sophisticated way to store the underlying data than traditional ASCII text.
</p>
<p>
This may all seem a bit fanciful, since the alphabet is about all us poor human machines can reasonably deal with, at least not without the assistance of a computer and scanner.  But there is at least one legitimate use for this stuff, the <a href="http://en.wikipedia.org/wiki/Trusted_paper_key">trusted paper key</a>. There's even software for this purpose, <a href="http://www.jabberwocky.com/software/paperkey/">PaperKey</a>:
</p>
<p>
</p>
<blockquote>
The goal with paper is not secure storage. There are countless ways to store something securely. A paper backup also isn't a replacement for the usual machine readable (tape, CD-R, DVD-R, etc) backups, but rather as an if-all-else-fails method of restoring a key. Most of the storage media in use today do not have particularly good long-term (measured in years to decades) retention of data. If and when the CD-R and/or tape cassette and/or USB key and/or hard drive the secret key is stored on becomes unusable, the paper copy can be used to restore the secret key.
<p>
For paper, on the other hand, to claim it will last for 100 years is not even vaguely impressive. High-quality paper with good ink regularly lasts many hundreds of years even under less than optimal conditions.
</p>
<p>
Another bonus is that ink on paper is readable by humans. Not all backup methods will be readable 50 years later, so even if you have the backup, you can't easily buy a drive to read it. I doubt this will happen anytime soon with CD-R as there are just so many of them out there, but the storage industry is littered with old now-dead ways of storing data.
</p>
</blockquote>
<p>
Computer encoding formats and data storage schemes come and go. This is why so much archival material survives best in the simplest possible formats, like unadorned ASCII. Depending on what your goals are, <b>a combination of simple digital encoding and the good old boring, reliable, really <i>really</i> old school technology of physical paper</b> can still make sense.
</p>
<p>
</p>
<p></p>
<!--kg-card-end: markdown-->
            </content>
<pubDate>2009-07-31T12:00:00.000Z</pubDate>
<guid>https://blog.codinghorror.com/the-paper-data-storage-option/</guid>
</item>
</channel>
</rss>
