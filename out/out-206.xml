<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0">
<channel>
<title>Coding Horror</title>
<description>programming and human factors</description>
<link>https://blog.codinghorror.com/</link>
<pubDate>Sun, 19 Apr 2020 00:00:01 GMT</pubDate>
<!-- other elements omitted from this example -->
<item>
<title>All Abstractions Are Failed Abstractions</title>
<link>https://blog.codinghorror.com/all-abstractions-are-failed-abstractions/</link>
<content>
                <!--kg-card-begin: markdown--><p>
In programming, <a href="http://www.advogato.org/person/Bram/diary.html?start=43">abstractions are powerful things</a>:
</p>
<p>
</p>
<blockquote>
Joel Spolsky has <a href="http://www.joelonsoftware.com/articles/LeakyAbstractions.html">an article</a> in which he states
<p>
</p>
<blockquote>
<i>All non-trivial abstractions, to some degree, are leaky.</i>
</blockquote>
<p>
This is overly dogmatic - for example, bignum classes are exactly the same regardless of the native integer multiplication. Ignoring that, this statement is essentially true, but rather inane and missing the point. Without abstractions, all our code would be completely interdependent and unmaintainable, and abstractions do a remarkable job of cleaning that up. <b>It is a testament to the power of abstraction and how much we take it for granted that such a statement can be made at all</b>, as if we always expected to be able to write large pieces of software in a maintainable manner.
</p>
</blockquote>
<p>
But they can cause problems of their own. Let's consider a particular <a href="http://msdn.microsoft.com/en-us/library/bb425822.aspx">LINQ to SQL</a> query, designed to retrieve the most recent 48 Stack Overflow questions.
</p>
<p>
</p>
<pre>
var posts =
(from p in DB.Posts
where
p.PostTypeId == PostTypeId.Question &amp;&amp;
p.DeletionDate == null &amp;&amp;
p.Score &gt;= minscore
orderby p.LastActivityDate descending
select p).
Take(maxposts);
</pre>
<p>
The big hook here is that <b>this is code the compiler actually understands</b>. You get code completion, compiler errors if you rename a database field or mistype the syntax, and so forth. Perhaps best of all, you get an honest to goodness <code>post</code> object as output! So you can turn around and immediately do stuff like this:
</p>
<p>
</p>
<pre>
foreach (var post in posts.ToList())
{
Render(post.Body);
}
</pre>
<p>
Pretty cool, right?
</p>
<p>
Well, that Linq to SQL query is functionally equivalent to this old-school SQL blob. More than functionally, <b>it is <i>literally</i> identical</b>, if you examine the SQL string that LINQ generates behind the scenes:
</p>
<p>
</p>
<pre>
string query =
"select top 48 * from Posts
where
PostTypeId = 1 and
DeletionDate is null and
Score &gt;= -4
order by LastActivityDate desc";
</pre>
<p>
This text blob is of course totally opaque to the compiler. Fat-finger a syntax error in here, and you won't find out about it until runtime. Even if it does run without a runtime error, processing the output of the query is awkward. It takes row level references and a lot of tedious data conversion to get at the underlying data.
</p>
<p>
</p>
<pre>
var posts = DB.ExecuteQuery(query);
foreach (var post in posts.ToList());
{
Render(post["Body"].ToString());
}
</pre>
<p>
So, LINQ to SQL is an abstraction -- we're <b>abstracting away raw SQL and database access in favor of native language constructs and objects</b>. I'd argue that Linq to SQL is a <i>good</i> abstraction. Heck, it's <a href="http://www.codinghorror.com/blog/archives/000033.html">exactly what I asked for five years ago</a>.
</p>
<p>
But even a good abstraction can break down in unexpected ways.
</p>
<p>
Consider this optimization, which is trivial in the old-school SQL blob code: instead of pulling down every single field in the post records, why not pull just the id number? Makes sense, if that's all I need. And it's faster -- much faster!
</p>
<p>
</p>
<table width="400">
<tr>
</tr>
<tr>
<td>select top 48 <font color="red">*</font> from Posts</td>
<td align="right">827 ms</td>
</tr>
<tr>
<td>select top 48 <font color="red">Id</font> from Posts</td>
<td align="right">260 ms</td>
</tr>
</table>
<p>
Selecting all columns with the star (*) operator is expensive, and that's what LINQ to SQL always does by default. Yes, <a href="http://mkdot.net/blogs/thearchitect/archive/2008/04/24/lazy-load-in-linq-to-sql.aspx">you can specify lazy loading</a>, but not on a per-query basis. Normally, this is a non-issue, because selecting all columns for simple queries is not all <i>that</i> expensive. And you'd think pulling down <b>48 measly little post records</b> would be squarely in the "not expensive" category!
</p>
<p>
So let's compare apples to apples. What if we got just the id numbers, then retrieved the full data for each row?
</p>
<p>
</p>
<table width="400">
<tr>
<td>select top 48 Id from Posts</td>
<td align="right">260 ms</td>
</tr>
<tr>
<td>select * from Posts where Id = 12345</td>
<td align="right">3 ms</td>
</tr>
</table>
<p>
Now, retrieving 48 individual records one by one is sort of silly, becase you could easily construct a single <code>where Id in (1,2,3..,47,48)</code> query that would grab all 48 posts in one go. But even if we did it in this naive way, the total execution time is still a very reasonable (48 * 3 ms) + 260 ms = 404 ms. <b>That is <i>half</i> the time of the standard select-star SQL emitted by LINQ to SQL!</b>
</p>
<p>
An extra 400 milliseconds doesn't sound like much, but <a href="http://radar.oreilly.com/2009/06/bing-and-google-agree-slow-pag.html">slow pages lose users</a>. And why in the world would you perform a slow database query on every single page of your website when you don't have to?
</p>
<p>
It's tempting to blame Linq, but is Linq really at fault here? These seem like <i>identical</i> database operations to me:
</p>
<p>
</p>
<blockquote>
1. Give me all columns of data for the top 48 posts.
</blockquote>
<p>
or
</p>
<p>
</p>
<blockquote>
1. Give me just the ids for the top 48 posts.<br>
2. Retrieve all columns of data for each of those 48 ids.
</blockquote>
<p>
So why in the wide, wide world of sports would one of these <b>seemingly identical operations</b> be twice as slow as the other?
</p>
<p>
The problem isn't Linq to SQL. The problem is that <b>we're attempting to spackle a nice, clean abstraction over a database that is full of highly irregular and unusual real world behaviors.</b> Databases that:
</p>
<p>
</p>
<ul>
<li>may not have the right indexes
</li>
<li>may misinterpret your query and generate an inefficient query plan
</li>
<li>are trying to perform an operation that doesn't fit well in available memory
</li>
<li>are paging data from disks which might be busy at that particular moment
</li>
<li>might contain irregularly sized column datatypes
</li>
</ul>
<p>
That's what's so frustrating. We can't just pretend all our data is formatted into neat, orderly data structures sitting there in memory, lined up in convenient little queues for us to reach out and casually scoop them up. As I've demonstrated, even trivial queries can have bizarre behavior and performance characteristics that are not at all clear.
</p>
<p>
To its credit, Linq to SQL is quite flexible: we can use strongly typed queries, or we can  use SQL blob queries that we cast to the right object type. That flexibility is critical, because <b>so much of our performance depends on these quirks of the database</b>. We default to the built-in Linq language constructs, and drop down to hand-tuning ye olde SQL blobs where the performance traces tell us we need to.
</p>
<p>
Either way, it's clear that you've <i>got</i> to know what's happening in the database every step of the way to even begin understanding the performance of your application, much less troubleshoot it.
</p>
<p>
I think you could make a fairly solid case that Linq to SQL is, in fact, a leaky and failed abstraction. Exactly the kind of thing Joel was complaining about. But I'd also argue that <b>virtually <i>all</i> good programming abstractions are failed abstractions</b>. I don't think I've ever used one that didn't leak like a sieve. But I think that's an awfully <a href="http://www.codinghorror.com/blog/archives/000165.html">architecture astronaut</a> way of looking at things. Instead, let's ask ourselves a more pragmatic question:
</p>
<p>
</p>
<blockquote>
Does this abstraction make our code at least a <i>little</i> easier to write? To understand? To troubleshoot? Are we better off <i>with</i> this abstraction than we were without it?
</blockquote>
<p>
It's our job as modern programmers not to abandon abstractions due to these deficiencies, but to embrace the useful elements of them, to adapt the working parts and construct ever so slightly <i>less</i> leaky and broken abstractions over time. Like desperate citizens manning a dike in a category 5 storm, <b>we programmers keep piling up these leaky abstractions, shoring up as best we can, desperately attempting to stay ahead of the endlessly rising waters of complexity.</b>
</p>
<p>
As much as I may curse Linq to SQL as yet another failed abstraction, I'll continue to use it. Yes, I may end up soggy and irritable at times. But it sure as <i>heck</i> beats drowning.
</p>
<p>
</p>
<p></p>
<!--kg-card-end: markdown-->
            </content>
<pubDate>2009-06-30T12:00:00.000Z</pubDate>
<guid>https://blog.codinghorror.com/all-abstractions-are-failed-abstractions/</guid>
</item>
</channel>
</rss>
