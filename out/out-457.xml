<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0">
<channel>
<title>Coding Horror</title>
<description>programming and human factors</description>
<link>https://blog.codinghorror.com/</link>
<pubDate>Sun, 19 Apr 2020 00:00:01 GMT</pubDate>
<!-- other elements omitted from this example -->
<item>
<title>The Great Browser JavaScript Showdown</title>
<link>https://blog.codinghorror.com/the-great-browser-javascript-showdown/</link>
<content>
                <!--kg-card-begin: markdown--><p>
In <a href="http://www.codinghorror.com/blog/archives/000509.html">The Day Performance Didn't Matter Any More</a>, I found that <b>the performance of JavaScript improved a hundredfold between 1996 and 2006</b>. If Web 2.0 is built on a backbone of JavaScript, it's largely possible only because of those crucial <a href="http://www.codinghorror.com/blog/archives/000741.html">Moore's Law performance improvements</a>.
</p>
<p>
But have we hit a performance wall? <b>Is it possible for browsers to run JavaScript significantly faster than they do today?</b> I've always thought that just-in-time optimizing (or even compiling) JavaScript was an unexplored frontier in browser technology. And now the landscape has shifted:
</p>
<ol>
<li>Apple's WebKit team <a href="http://webkit.org/blog/152/announcing-sunspider-09/">just announced</a> a great new JavaScript benchmark, SunSpider.
</li>
<li>The browser market is <a href="http://www.codinghorror.com/blog/archives/001006.html">more competitive than it has been in years</a>, with Opera 9.5, Firefox 3, Safari 3, and IE 8 all vying for the coveted default browser position.
</li>
</ol>
<p>
Perhaps browser teams will begin to consider JavaScript performance a competitive advantage.  The <a href="http://www.codinghorror.com/blog/archives/000509.html">last time</a> I looked for common JavaScript benchmarks, I came away deeply disappointed. That's why I'm particularly excited by <a href="http://webkit.org/perf/sunspider-0.9/sunspider.html">the SunSpider benchmark</a>: it's remarkably well thought out, easy to run, and comprehensive.
</p>
<p>
</p>
<blockquote>
It's <b>based on real code that does interesting things</b>; both things that the web apps of today are doing, and more advanced code of the sorts we can expect as web apps become more advanced. Very few of the tests could be classed as microbenchmarks.
<p>
It's <b>balanced between different aspects of the JavaScript language</b> -- not dominated by just a small handful of different things. In fact, we collected test cases from all over the web, including from other benchmarks. But at the same time, we avoided DOM tests and stuck to the core JavaScript language itself.
</p>
<p>
It's super <b>easy to <a href="http://webkit.org/perf/sunspider-0.9/sunspider.html">run in the browser</a></b> or from the command line, so you can test both pure engine performance, and the results you actually get in the browser.
</p>
<p>
We included <b>statistical analysis</b> so you can see how stable the results you're getting really are.
</p>
</blockquote>
<p>
<a href="http://webkit.org/blog/">Maciej Stachowiak</a>, a member of Apple's WebKit team, graciously explained what each subsection of the benchmarks do in the comments:
</p>
<p>
</p>
<table cellpadding="4" cellspacing="4" width="600">
<tr>
<td valign="top">3d</td>
<td>Pure JavaScript computations of the kind you might use to do 3d rendering, but without the rendering. This ends up mostly hitting floating point math and array access.</td>
</tr>
<tr>
<td valign="top">access</td>
<td>Array, object property and variable access.</td>
</tr>
<tr>
<td valign="top">bitops</td>
<td>Bitwise operations, these can be useful for various things including games, mathematical computations, and various kinds of encoding/decoding. It's also the only kind of math in JavaScript that is done as integer, not floating point.</td>
</tr>
<tr>
<td valign="top">controlflow</td>
<td>Control flow constructs (looping, recursion, conditionals). Right now it mostly covers recursion, as the others are pretty well covered by other tests.</td>
</tr>
<tr>
<td valign="top">crypto</td>
<td>Real cryptography code, mostly covers bitwise operations and string operations.</td>
</tr>
<tr>
<td valign="top">date</td>
<td>Performance of JavaScript's "date" objects.</td>
</tr>
<tr>
<td valign="top">math</td>
<td>Various mathematical type computations.</td>
</tr>
<tr>
<td valign="top">regexp</td>
<td>Regular expressions. Pretty self-explanatory.</td>
</tr>
<tr>
<td valign="top">string</td>
<td>String processing, including code to generate a giant "tagcloud", extracting compressed JS code, etc.
</td>
</tr>
</table>
<p>
<a href="http://webkit.org/perf/sunspider-0.9/sunspider.html">SunSpider</a> is the best JavaScript benchmark I've seen, something we desperately need in an era where <a href="http://www.codinghorror.com/blog/archives/000857.html">JavaScript is the Lingua Franca of the web</a>. I was so excited, in fact, that I ran some quick benchmarks to compare the four major players in the browser market:
</p>
<p>
</p>
<ul>
<li>Windows Vista 32-bit
</li>
<li>4 GB RAM
</li>
<li>dual-core 3.0 GHz Core 2 Duo CPU
</li>
<li>all browser extensions disabled (clean install)
</li>
</ul>
<p>
<img alt="Browser JavaScript performance graph, result totals by browser" border="0" class="at-xid-6a0120a85dcdae970b0120a86dc52e970b" height="271" src="https://blog.codinghorror.com/content/images/uploads/2007/12/6a0120a85dcdae970b0120a86dc52e970b-pi.png" width="776">
</p>
<p>
What surprised me here is that Firefox is substantially slower than IE, once you factor out that <a href="http://blogs.msdn.com/jscript/archive/2007/10/17/performance-issues-with-string-concatenation-in-jscript.aspx">wildly anomalous string result</a>. I had to use a beta version of Opera to get something other than invalid (NaN) results for this benchmark, which coincidentally summarizes my opinion of Opera. Great when it works! I expected Opera to do well; it was handily winning JavaScript benchmarks <a href="http://www.codinghorror.com/blog/archives/000211.html">way back in 2005</a>. The new kid on the block, Safari, shows extremely well particularly considering that it is running outside its native OS X environment. Kudos to Apple. Well, except for <a href="http://www.codinghorror.com/blog/archives/000884.html">that whole font thing</a>.
</p>
<p>
If you're curious how each browser stacked up in each benchmark area, I broke that down, too:
</p>
<p>
<img alt="Browser JavaScript performance graph, breakdown by test area" border="0" class="at-xid-6a0120a85dcdae970b0120a86dc542970b" height="635" src="https://blog.codinghorror.com/content/images/uploads/2007/12/6a0120a85dcdae970b0120a86dc542970b-pi.png" width="593">
</p>
<p>
If you need greater detail-- including variances-- you can <a href="http://www.codinghorror.com/blog/files/sunspider-09-benchmark-results.txt">download my complete set of SunSpider 0.9 results as a text file</a>.
</p>
<p>
If I've learned anything from the computer industry, it's that competition benefits everyone. Here's hoping that <b>a great JavaScript browser performance showdown</b> spurs the browser teams on to better performance in this increasingly crucial area.
</p>
<p>
</p>
<p></p>
<!--kg-card-end: markdown-->
            </content>
<pubDate>2007-12-19T12:00:00.000Z</pubDate>
<guid>https://blog.codinghorror.com/the-great-browser-javascript-showdown/</guid>
</item>
</channel>
</rss>
