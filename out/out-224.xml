<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0">
<channel>
<title>Coding Horror</title>
<description>programming and human factors</description>
<link>https://blog.codinghorror.com/</link>
<pubDate>Sun, 19 Apr 2020 00:00:01 GMT</pubDate>
<!-- other elements omitted from this example -->
<item>
<title>Why Do Computers Suck at Math?</title>
<link>https://blog.codinghorror.com/why-do-computers-suck-at-math/</link>
<content>
                <!--kg-card-begin: markdown--><p>
You've probably seen <a href="http://www.google.com/search?&amp;q=399999999999999-399999999999998">this old chestnut</a> by now.
</p>
<p>
<a href="http://www.google.com/search?&amp;q=399999999999999-399999999999998"><img alt="google-calculator-incorrect.png" border="0" class="at-xid-6a0120a85dcdae970b012877709c5c970c" height="186" src="https://blog.codinghorror.com/content/images/uploads/2009/05/6a0120a85dcdae970b012877709c5c970c-pi.png" width="511"></a>
</p>
<p>
Insert your own joke here. Google can't be wrong -- <i>math is!</i> But Google is hardly alone; this is just another example in a long and storied history of obscure little computer math errors that go <i>way</i> back, such as <a href="http://support.microsoft.com/kb/72540">this bug report from Windows 3.0</a>.
</p>
<p>
</p>
<ol>
<li>Start Calculator.
</li>
<li>Input the largest number to subtract first (for example, 12.52).
</li>
<li>Press the MINUS SIGN (-) key on the numeric keypad.
</li>
<li>Input the smaller number that is one unit lower in the decimal portion (for example, 12.51).
</li>
<li>Press the EQUAL SIGN (=) key on the numeric keypad.
</li>
</ol>
<p>
On my virtual machine, 12.52 - 12.51 on Ye Olde Windows Calculator indeed results in 0.00.
</p>
<p>
<img alt="Windows 3.11 calculator incorrect" border="0" class="at-xid-6a0120a85dcdae970b012877709c97970c" height="269" src="https://blog.codinghorror.com/content/images/uploads/2009/05/6a0120a85dcdae970b012877709c97970c-pi.png" width="261">
</p>
<p>
And then there was the <a href="http://www.lawtechguru.com/archives/2007/09/25_excel_2007_multiplication_math_bug.html">famous Excel bug</a>.
</p>
<p>
</p>
<blockquote>
If you have Excel 2007 installed, try this: Multiply 850 by 77.1 in Excel.
<p>
One way to do this is to type "=850*77.1" (without the quotes) into a cell. The correct answer is 65,535. However, Excel 2007 displays a result of 100,000.
</p>
</blockquote>
<p>
At this point, you might be a little perplexed, as <b>computers are supposed to be pretty good at this math stuff</b>. What gives? How is it possible to produce such blatantly incorrect results from seemingly trivial calculations? Should we even be trusting our computers to do math at all?
</p>
<p>
Well, numbers are <a href="http://www.johndcook.com/blog/2009/04/06/numbers-are-a-leaky-abstraction/">harder to represent on computers than you might think</a>:
</p>
<p>
</p>
<blockquote>
A standard floating point number has roughly 16 decimal places of precision and a maximum value on the order of 10<sup>308</sup>, a 1 followed by 308 zeros. (According to <a href="http://en.wikipedia.org/wiki/IEEE_754">IEEE standard 754</a>, the typical floating point implementation.)
<p>
Sixteen decimal places is a lot. Hardly any measured quantity is known to anywhere near that much precision. For example, the constant in Newton's Law of Gravity is only known to four significant figures. The charge of an electron is known to 11 significant figures, much more precision than Newton's gravitational constant, but still less than a floating point number. So <b>when are 16 figures not enough?</b> One problem area is subtraction. The other elementary operations -- addition, multiplication, division -- are very accurate. As long as you don't overflow or underflow,  these operations often produce results that are correct to the last bit. But subtraction can be anywhere from exact to completely inaccurate.  If two numbers agree to n figures, you can lose up to n figures of precision in their subtraction. This problem can show up unexpectedly in the middle of other calculations.
</p>
</blockquote>
<p>
Number precision is a funny thing; did you know that an <a href="http://en.wikipedia.org/wiki/0.999...">infinitely repeating sequence of 0.999.. is equal to one</a>?
</p>
<p>
</p>
<blockquote>
In mathematics, the repeating decimal 0.999Ãƒâ€“ denotes a real number equal to one. In other words: the notations 0.999Ãƒâ€“ and 1 actually represent the same real number.
<p>
<img alt="0.999 infinitely repeating" border="0" height="38" src="http://www.codinghorror.com/blog/images/999-perspective.png" width="300">
</p>
<p>
This equality has long been accepted by professional mathematicians and taught in textbooks. Proofs have been formulated with varying degrees of mathematical rigour, taking into account preferred development of the real numbers, background assumptions, historical context, and target audience.
</p>
</blockquote>
<p>
Computers <a href="http://www.codinghorror.com/blog/archives/000874.html">are awesome</a>, yes, but they aren't <i>infinite</i>.. yet. So any prospects of storing any infinitely repeating number on them are dim at best. The best we can do is work with approximations at varying levels of precision that are "good enough", where "good enough" depends on what you're doing, and how you're doing it. And it's complicated to get right.
</p>
<p>
Which brings me to <a href="http://docs.sun.com/source/806-3568/ncg_goldberg.html">What Every Computer Scientist Should Know About Floating-Point Arithmetic</a>.
</p>
<p>
</p>
<blockquote>
<b>Squeezing infinitely many real numbers into a finite number of bits requires an approximate representation.</b> Although there are infinitely many integers, in most programs the result of integer computations can be stored in 32 bits. In contrast, given any fixed number of bits, most calculations with real numbers will produce quantities that cannot be exactly represented using that many bits. Therefore the result of a floating-point calculation must often be rounded in order to fit back into its finite representation. This rounding error is the characteristic feature of floating-point computation.
</blockquote>
<p>
What do the Google, Windows, and <a href="http://www.lomont.org/Math/Papers/2007/Excel2007/Excel2007Bug.pdf">Excel</a> (pdf) math errors have in common? They're all related to number precision approximation issues. Google doesn't think it's important enough to fix. They're probably right. But some mathematical rounding errors can be <a href="http://www.maa.org/mathland/mathland_5_12.html">a bit more serious</a>.
</p>
<p>
</p>
<blockquote>
Interestingly, the launch failure of the Ariane 5 rocket, which exploded 37 seconds after liftoff on June 4, 1996, occurred because of a software error that resulted from converting a 64-bit floating point number to a 16-bit integer. The value of the floating point number happened to be larger than could be represented by a 16-bit integer. The overflow wasn't handled properly, and in response, the computer cleared its memory. The memory dump was interpreted by the rocket as instructions to its rocket nozzles, and an explosion resulted.
</blockquote>
<p>
I'm starting to believe that it's not the computers that suck at math, but the people programming those computers. I know I'm <a href="http://www.codinghorror.com/blog/archives/001187.html">living proof of that</a>.
</p>
<p>
</p>
<p></p>
<!--kg-card-end: markdown-->
            </content>
<pubDate>2009-05-13T12:00:00.000Z</pubDate>
<guid>https://blog.codinghorror.com/why-do-computers-suck-at-math/</guid>
</item>
</channel>
</rss>
