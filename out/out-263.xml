<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0">
<channel>
<title>Coding Horror</title>
<description>programming and human factors</description>
<link>https://blog.codinghorror.com/</link>
<pubDate>Sun, 19 Apr 2020 00:00:01 GMT</pubDate>
<!-- other elements omitted from this example -->
<item>
<title>The Ferengi Programmer</title>
<link>https://blog.codinghorror.com/the-ferengi-programmer/</link>
<content>
                <!--kg-card-begin: markdown--><p>
There was a little <a href="http://blog.objectmentor.com/articles/2009/01/31/quality-doesnt-matter-that-much-jeff-and-joel">brouhaha</a> recently about <a href="http://www.joelonsoftware.com/items/2009/01/31.html">some comments Joel Spolsky made</a> on our podcast:
</p>
<p>
</p>
<blockquote>
Last week I was listening to a <a href="http://www.hanselminutes.com/default.aspx?showID=163">podcast on Hanselminutes</a>, with Robert Martin talking about the <a href="http://butunclebob.com/ArticleS.UncleBob.PrinciplesOfOod">SOLID principles</a>. (That's a real easy-to-Google term!) It's object-oriented design, and they're calling it agile design, which it really, really isn't. It's principles for how to design your classes, and how they should work. And, when I was listening to them, they all sounded to me like extremely bureaucratic programming that came from the mind of somebody that has not written a lot of code, frankly.
</blockquote>
<p>
There's nothing really objectionable about <a href="http://butunclebob.com/ArticleS.UncleBob.PrinciplesOfOod">Bob's object-oriented design principles</a>, on the face of it. (Note that all links in the below table are PDFs, so click accordingly.)
</p>
<p>
</p>
<table cellpadding="4" cellspacing="4" width="600">
<tr>
<td><a href="http://www.objectmentor.com/resources/articles/srp.pdf">The Single Responsibility Principle</a></td>
<td>A class should have one, and only one, reason to change.</td>
</tr>
<tr>
<td><a href="http://www.objectmentor.com/resources/articles/ocp.pdf">The Open Closed Principle</a></td>
<td>You should be able to extend a classes behavior, without modifying it.</td>
</tr>
<tr>
<td><a href="http://www.objectmentor.com/resources/articles/lsp.pdf">The Liskov Substitution Principle</a></td>
<td>Derived classes must be substitutable for their base classes.</td>
</tr>
<tr>
<td><a href="http://www.objectmentor.com/resources/articles/dip.pdf">The Dependency Inversion Principle</a></td>
<td>Depend on abstractions, not on concretions.</td>
</tr>
<tr>
<td><a href="http://www.objectmentor.com/resources/articles/isp.pdf">The Interface Segregation Principle</a></td>
<td>Make fine grained interfaces that are client specific.</td>
</tr>
<tr>
<td><a href="http://www.objectmentor.com/resources/articles/granularity.pdf">The Release Reuse Equivalency Principle</a></td>
<td>The granule of reuse is the granule of release.</td>
</tr>
<tr>
<td><a href="http://www.objectmentor.com/resources/articles/granularity.pdf">The Common Closure Principle</a></td>
<td>Classes that change together are packaged together.</td>
</tr>
<tr>
<td><a href="http://www.objectmentor.com/resources/articles/granularity.pdf">The Common Reuse Principle</a></td>
<td>Classes that are used together are packaged together.</td>
</tr>
<tr>
<td><a href="http://www.objectmentor.com/resources/articles/granularity.pdf">The Acyclic Dependencies Principle</a></td>
<td>The dependency graph of packages must have no cycles.</td>
</tr>
<tr>
<td><a href="http://www.objectmentor.com/resources/articles/stability.pdf">The Stable Dependencies Principle</a></td>
<td>Depend in the direction of stability.</td>
</tr>
<tr>
<td><a href="http://www.objectmentor.com/resources/articles/stability.pdf">The Stable Abstractions Principle</a></td>
<td>Abstractness increases with stability.</td>
</tr>
</table>
<p>
While I do believe every software development team should endeavor to <a href="http://www.codinghorror.com/blog/archives/000568.html">follow the instructions on the paint can</a>, there's a limit to what you can fit on a paint can. It's the most basic, most critical information you need to proceed and not make a giant mess of the process. As brief as the instructions on a paint can are, they do represent the upper limit of what most people will realistically read, comprehend, and derive immediate benefit from.
</p>
<p>
<b>Expanding from a few guidelines on a paint can into a detailed painting manual is far riskier.</b> The bigger and more grandiose the set of rules you come up with, the more severe the danger. A few broad guidelines on a paint can begets thirty rules for painting, which begets a hundred detailed principles of painting..
</p>
<p>
Pretty soon you'll find yourself believing that every possible situation in software development can be prescribed, <i>if only you could come up with a sufficiently detailed set of rules!</i> And, of course, a critical mass of programmers patient enough to read Volumes I - XV of said rules. You'll also want to set up a few messageboards for these programmers to argue endlessly amongst themselves about the meaning and interpretation of the rules.
</p>
<p>
This strikes me as <b>a bit like Ferengi programming</b>.
</p>
<p>
<a href="http://www.amazon.com/dp/0671529366/?tag=codihorr-20">
<img alt="Ferengi Rules of Acquisition, book cover" border="0" class="at-xid-6a0120a85dcdae970b0120a86e1125970b" height="582" src="https://blog.codinghorror.com/content/images/uploads/2009/02/6a0120a85dcdae970b0120a86e1125970b-pi.jpg" width="478"></a>
</p>
<p>
The <a href="http://en.wikipedia.org/wiki/Ferengi">Ferengi</a> are a part of the Star Trek universe, primarily in <a href="http://en.wikipedia.org/wiki/Star_Trek:_Deep_Space_Nine">Deep Space Nine</a>. They're a race of ultra-capitalists whose every business transaction is governed by <a href="http://memory-alpha.org/en/wiki/Rules_of_Acquisition">the 285 Rules of Acquisition</a>. There's a rule for every possible business situation -- and, inevitably, an interpretation of those rules that gives the Ferengi license to cheat, steal, and bend the truth to suit their needs.
</p>
<p>
At what point do you stop having a set of basic, reasonable programming guidelines -- and start being <b>a Ferengi programmer, an imperfect manifestation of the ruleset?</b>
</p>
<p>
Like James Bach, I've found <a href="http://www.satisfice.com/blog/archives/174">less and less use for rules</a> in my career. Not because I'm a <a href="http://www.codinghorror.com/blog/archives/001080.html">self-made genius who plays by my own rules</a>, mind you, but because I value the skills, experience, and judgment of my team far more than any static set of rules.
</p>
<p>
</p>
<blockquote>
When <a href="http://xprogramming.com/blog/2009/01/30/context-my-foot">Ron says there is an "absolute minimum of practice"</a> that must be in for an agile project to succeed, I want to reply that I believe there is an absolute minimum of practice needed to have a competent opinion about things that are needed -- and that in his post he does not achieve that minimum. I think part of that minimum is to understand what words like "practice" and "agile" and "success" can mean (recognizing they are malleable ideas). Part of it is to recognize that people can and have behaved in agile ways without any concept of agile or ability to explain what they do.
<p>
My style of development and testing is highly agile. I am agile in that I am prepared to question and rethink anything. I change and develop my methods. I may learn from packaged ideas like Extreme Programming, but I never <i>follow</i> them. <i>Following is for novices who are under active supervision</i>. Instead, I craft methods on a project by project basis, and I encourage other people to do that, as well. <b>I take responsibility for my choices. That's engineering for adults like us.</b>
</p>
</blockquote>
<p>
Guidelines, particularly in the absence of experts and mentors, <a href="http://www.codinghorror.com/blog/archives/000578.html">are useful</a>. But there's also a very real danger of <b>hewing too slavishly to rulesets</b>. Programmers are already quite systematic by disposition, so the idea that you can come up with a detailed enough set of rules, and sub-rules, and sub-sub-rules, that you can literally <i>program yourself</i> for success with a "system" of sufficient sophistication -- this, unfortunately, comes naturally to most software developers. If you're not careful, you might even slip and <a href="http://www.codinghorror.com/blog/archives/000203.html">fall into a Methodology</a>. Then you're in <i>real</i> trouble.
</p>
<p>
<b>Don't become a Ferengi Programmer.</b> Rules, guidelines, and principles are gems of distilled experience that should be studied and respected. But they're never a substute for thinking critically about your work.
</p>
<p>
</p>
<p></p>
<!--kg-card-end: markdown-->
            </content>
<pubDate>2009-02-11T12:00:00.000Z</pubDate>
<guid>https://blog.codinghorror.com/the-ferengi-programmer/</guid>
</item>
</channel>
</rss>
