<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0">
<channel>
<title>Coding Horror</title>
<description>programming and human factors</description>
<link>https://blog.codinghorror.com/</link>
<pubDate>Sun, 19 Apr 2020 00:00:01 GMT</pubDate>
<!-- other elements omitted from this example -->
<item>
<title>Revisiting The Facts and Fallacies of Software Engineering</title>
<link>https://blog.codinghorror.com/revisiting-the-facts-and-fallacies-of-software-engineering/</link>
<content>
                <!--kg-card-begin: markdown--><p>
I like to re-read my favorite books every few years, so I brought Robert Glass' seminal <a href="http://www.amazon.com/exec/obidos/ASIN/0321117425/codihorr-20%0A">Facts and Fallacies of Software Engineering</a> with me on my most recent trip. I thought it was a decent, but imperfect read when I originally bought it in 2004. As I scanned through the introduction and table of contents, I realized that <b>I've written about almost everything in this book by now</b>.
</p>
<p>
<a href="http://www.amazon.com/exec/obidos/ASIN/0321117425/codihorr-20%0A"><img alt="Facts and Fallacies of Software Engineering" border="0" class="at-xid-6a0120a85dcdae970b012877703e5c970c" height="375" src="https://blog.codinghorror.com/content/images/uploads/2008/03/6a0120a85dcdae970b012877703e5c970c-pi.jpg" style="border: 1px solid gray;" width="299">
</a>
</p>
<p>
I'm not sure I gave Facts and Fallacies its due <a href="http://www.codinghorror.com/blog/archives/000084.html">on my first read</a>.
</p>
<p>
Simply reciting the various facts and fallacies feels like a zen koan to software engineering. Even without any of the background discussion and explanation in the book, it's therapeutic to ponder the brief one sentence summaries presented in the table of contents. As you read these, what comes to mind, based on your experience?
</p>
<p>
<b>People</b>
</p>
<ol>
<li>The most important factor in software work is the quality of the programmers.
</li>
<li>The best programmers are up to 28 times better than the worst programmers.
</li>
<li>Adding people to a late project makes it later.
</li>
<li>The working environment has a profound impact on productivity and quality.
</li>
</ol>
<p>
<b>Tools and Techniques</b>
</p>
<ol start="5">
<li>Hype (about tools and technology) is a plague on the house of software.
</li>
<li>New tools and techniques cause an initial <i>loss</i> of productivity / quality.
</li>
<li>Software developers talk a lot about tools, but seldom use them.
</li>
</ol>
<p>
<b>Estimation</b>
</p>
<ol start="8">
<li>One of the two most common causes of runaway projects is poor estimation.
</li>
<li>Software estimation usually occurs at the wrong time.
</li>
<li>Software estimation is usually done by the wrong people.
</li>
<li>Software estimates are rarely corrected as the project proceeds.
</li>
<li>It is not surprising that software estimates are bad. But we live and die by them anyway!
</li>
<li>There is a disconnect between software management and their programmers.
</li>
<li>The answer to a feasability study is almost always "yes".
</li>
</ol>
<p>
<b>Reuse</b>
</p>
<ol start="15">
<li>Reuse-in-the-small is a solved problem.
</li>
<li>Reuse-in-the-large remains a mostly unsolved problem.
</li>
<li>Reuse-in-the-large works best in families of related systems.
</li>
<li>Reuseable components are three times as hard to build and should be tried out in three different settings.
</li>
<li>Modification of reused code is particularly error-prone.
</li>
<li>Design pattern reuse is one solution to the problems of code reuse.
</li>
</ol>
<p>
<b>Requirements</b>
</p>
<ol start="23">
<li>One of the two most common causes of runaway projects is unstable requirements.
</li>
<li>Requirements errors are the most expensive to fix during production.
</li>
<li>Missing requirements are the hardest requirements errors to correct.
</li>
</ol>
<p>
<b>Design</b>
</p>
<ol start="26">
<li>Explicit requirements 'explode' as implicit requirements for a solution evolve.
</li>
<li>There is seldom one best design solution to a software problem.
</li>
<li>Design is a complex, iterative process. Initial design solutions are usually wrong and certainly not optimal.
</li>
</ol>
<p>
<b>Coding</b>
</p>
<ol start="29">
<li>Designer 'primitives' rarely match programmer 'primitives'.
</li>
<li>COBOL is a very bad language, but all the others are so much worse.
</li>
</ol>
<p>
<b>Error removal</b>
</p>
<p>
</p>
<ol start="31">
<li>Error removal is the most time-consuming phase of the lifecycle.
</li>
</ol>
<p>
<b>Testing</b>
</p>
<ol start="32">
<li>Software is usually tested at best to the 55 to 60 percent coverage level.
</li>
<li>100 percent test coverage is still far from enough.
</li>
<li>Test tools are essential, but rarely used.
</li>
<li>Test automation rarely is. Most testing activities cannot be automated.
</li>
<li>Programmer-created, built-in debug code is an important supplement to testing tools.
</li>
</ol>
<p>
<b>Reviews and Inspections</b>
</p>
<p>
</p>
<ol start="37">
<li>Rigorous inspections can remove up to 90 percent of errors before the first test case is run.
</li>
<li>Rigorous inspections should not replace testing.
</li>
<li>Post-delivery reviews, postmortems, and retrospectives are important and seldom performed.
</li>
<li>Reviews are both technical and sociological, and both factors must be accommodated.
</li>
</ol>
<p>
<b>Maintenance</b>
</p>
<p>
</p>
<ol start="41">
<li>Maintenance typically consumes 40 to 80 percent of software costs. It is probably the most important software lifecycle phase.
</li>
<li>Enhancements represent roughly 60 percent of maintenance costs.
</li>
<li>Maintenance is a solution-- not a problem.
</li>
<li>Understanding the existing product is the most difficult maintenance task.
</li>
<li>Better methods lead to <i>more</i> maintenance, not less.
</li>
</ol>
<p>
<b>Quality</b>
</p>
<ol start="46">
<li>Quality is a collection of attributes.
</li>
<li>Quality is <i>not</i> user satisfaction, meeting requirements, achieving cost and schedule, or reliability.
</li>
</ol>
<p>
<b>Reliability</b>
</p>
<p>
</p>
<ol start="48">
<li>There are errors that most programmers tend to make.
</li>
<li>Errors tend to cluster.
</li>
<li>There is no single best approach to software error removal.
</li>
<li>Residual errors will always persist. The goal should be to minimize or eliminate <i>severe</i> errors.
</li>
</ol>
<p>
<b>Efficiency</b>
</p>
<p>
</p>
<ol start="52">
<li>Efficiency stems more from good design than good coding.
</li>
<li>High-order language code can be about 90 percent as efficient as comparable assembler code.
</li>
<li>There are tradeoffs between optimizing for time and optimizing for space.
</li>
</ol>
<p>
<b>Research</b>
</p>
<ol start="55">
<li>Many researchers advocate rather than investigate.
</li>
</ol>
<p>
I had forgotten how much ground the book covers; it's a perfect springboard to all the essential topics in software engineering.
</p>
<p>
I've posted on almost every one of these facts in the intervening four years since I originally read them. As I delved into the table of contents presented above, I could barely contain myself. I remembered and mentally checked each post off the list as I went: check, check, check. I've been accused of gratuitous self-linking in the past, so I won't clutter up the rules with dozens of links to my old posts on these topics. If you're interested, you can find it. That's sort of the point.
</p>
<p>
If those are the fifty-five facts, then these are the <b>ten fallacies</b> presented at the end. Fallacies have the <i>ring</i> of truth, but upon closer inspection, turn out to be problematic when applied to a real live software project.
</p>
<p>
</p>
<ol>
<li>You can't manage what you can't measure.
</li>
<li>You can manage quality into a software product.
</li>
<li>Programming can and should be egoless.
</li>
<li>Tools and techniques: one size fits all.
</li>
<li>Software needs more methodologies.
</li>
<li>To estimate cost and schedule, first estimate lines of code.
</li>
<li>Random test input is a good way to optimize testing.
</li>
<li>"Given enough eyeballs, all bugs are shallow".
</li>
<li>The way to preduct future maintenance costs and to make product replacement decisions is to look at past cost data.
</li>
<li>You teach people how to program by showing them how to <i>write</i> programs.
</li>
</ol>
<p>
If you're curious about the rationale behind these facts and fallacies, that's entirely the reason the book exists: to remind us to question what we're doing. <b>We should be thinking about our craft every day, in some small way, on our own software projects.</b> That's how we collectively advance software engineering-- by building our shared memory and history in the field. As Mr. Glass states in the introduction:
</p>
<p>
</p>
<blockquote>
In presenting these facts, I am also indentifying problems in the field. It is not my intention to present solutions to these problems. <a href="http://www.codinghorror.com/blog/archives/000189.html">This is a what-is book, not a how-to book</a>. That's important to me. I want to bring these facts into the open, where they can be freely discussed, and we can act on them to make progress.
</blockquote>
<p>
I encourage you to <a href="http://www.codinghorror.com/blog/archives/000084.html">pick up a copy of the full book</a> for a deeper exploration. I do believe there's a rich learning experience-- or a rich remembering experience-- here for those of you who choose to read on.
</p>
<p>
</p>
<p></p>
<!--kg-card-end: markdown-->
            </content>
<pubDate>2008-03-25T13:00:00.000Z</pubDate>
<guid>https://blog.codinghorror.com/revisiting-the-facts-and-fallacies-of-software-engineering/</guid>
</item>
</channel>
</rss>
