<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0">
<channel>
<title>Coding Horror</title>
<description>programming and human factors</description>
<link>https://blog.codinghorror.com/</link>
<pubDate>Sun, 19 Apr 2020 00:00:01 GMT</pubDate>
<!-- other elements omitted from this example -->
<item>
<title>The Best Code is No Code At All</title>
<link>https://blog.codinghorror.com/the-best-code-is-no-code-at-all/</link>
<content>
                <!--kg-card-begin: markdown--><p>
Rich Skrenta writes that <a href="http://www.skrenta.com/2007/05/code_is_our_enemy.html">code is our enemy</a>.
</p>
<p>
</p>
<blockquote>
Code is bad. It rots. It requires periodic maintenance. It has bugs that need to be found. New features mean old code has to be adapted. The more code you have, the more places there are for bugs to hide. The longer checkouts or compiles take. The longer it takes a new employee to make sense of your system. If you have to refactor there’s more stuff to move around.
<p>
Code is produced by engineers. To make more code requires more engineers. Engineers have n^2 communication costs, and all that code they add to the system, while expanding its capability, also increases a whole basket of costs. You should do whatever possible to increase the productivity of individual programmers in terms of the expressive power of the code they write. Less code to do the same thing (and possibly better). Less programmers to hire. Less organizational communication costs.
</p>
</blockquote>
<p>
Rich hints at it here, but the real problem isn’t the code. The code, like a newborn babe, is blameless and innocent the minute it is written into the world. Code isn’t our enemy. You want to see the real enemy? Go look in the mirror. There’s your problem, right there.
</p>
<p>
<img alt="car mirror view" border="0" class="at-xid-6a0120a85dcdae970b0120a86d949c970b" height="480" src="https://blog.codinghorror.com/content/images/uploads/2007/05/6a0120a85dcdae970b0120a86d949c970b-pi.jpg" width="440">
</p>
<p>
<b>As a software developer, you are your own worst enemy. The sooner you realize that, the better off you’ll be.</b>
</p>
<p>
I know you have the best of intentions. We all do. We’re software developers; we love writing code. It’s what we do. We never met a problem we couldn’t solve with some duct tape, a jury-rigged coat hanger, and a pinch of code. But Wil Shipley argues that we should <a href="http://wilshipley.com/blog/2007/05/pimp-my-code-part-14-be-inflexible.html">rein in our natural tendencies to write lots of code</a>:
</p>
<p>
</p>
<blockquote>
The fundamental nature of coding is that our task, as programmers, is to recognize that every decision we make is a trade-off. To be a master programmer is to understand the nature of these trade-offs, and be conscious of them in everything we write.
<p>
In coding, you have many dimensions in which you can rate code:
</p>
<p>
</p>
<ul>
<li>Brevity of code</li>
<li>Featurefulness</li>
<li>Speed of execution</li>
<li>Time spent coding</li>
<li>Robustness</li>
<li>Flexibility</li>
</ul>
<p>
Now, remember, these dimensions are all in opposition to one another. You can spend three days writing a routine which is really beautiful <i>and</i> fast, so you’ve gotten two of your dimensions up, but you’ve spent <i>three days</i>, so the "time spent coding" dimension is <i>way</i> down.
</p>
<p>
So, when is this worth it? How do we make these decisions? The answer turns out to be very sane, very simple, and also the one nobody, ever, listens to: <b>Start with brevity. Increase the other dimensions as required by testing.</b>
</p>
</blockquote>
<p>
I couldn’t agree more. I’ve given similar advice when I <a href="https://blog.codinghorror.com/code-smaller/">exhorted developers to Code Smaller</a>. And I’m not talking about a <a href="http://en.wikipedia.org/wiki/Reductio_ad_absurdum">reductio ad absurdum</a> contest where we use up all the clever tricks in our books to make the code fit into less physical space. <b>I’m talking about practical, sensible strategies to reduce the volume of code an individual programmer has to read to understand how a program works.</b> Here’s a trivial little example of what I’m talking about:
</p>
<p>
</p>
<pre>
if (s == String.Empty)
if (s == "")
</pre>
<p>
It seems obvious to me that the latter case is better because it’s just plain <i>smaller</i>. And yet I’m virtually guaranteed to encounter developers who will fight me, almost <a href="https://blog.codinghorror.com/are-you-there-god-its-me-microsoft/">literally to the death</a>, because they’re absolutely convinced that the verbosity of <code>String.Empty</code> is somehow friendlier to the compiler. As if I care about that. As if <i>anyone</i> cared about that!
</p>
<p>
It’s painful for most software developers to acknowledge this, because they love code so much, but <b>the best code is no code at all</b>. Every new line of code you willingly bring into the world is code that has to be debugged, code that has to be read and understood, code that has to be supported. Every time you write new code, you should do so reluctantly, under duress, because you completely exhausted all your other options. Code is only our enemy because there are so many of us programmers writing so damn much of it. If you <i>can’t</i> get away with no code, the next best thing is to <b>start with brevity</b>.
</p>
<p>
If you love writing code — really, truly <i>love to write code</i> — you’ll love it enough to write as little of it as possible.
</p>
<p>
<!--kg-card-end: markdown-->
            </p></content>
<pubDate>2007-05-30T12:00:00.000Z</pubDate>
<guid>https://blog.codinghorror.com/the-best-code-is-no-code-at-all/</guid>
</item>
</channel>
</rss>
