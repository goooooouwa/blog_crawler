<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0">
<channel>
<title>Coding Horror</title>
<description>programming and human factors</description>
<link>https://blog.codinghorror.com/</link>
<pubDate>Sun, 19 Apr 2020 00:00:01 GMT</pubDate>
<!-- other elements omitted from this example -->
<item>
<title>Is DoEvents Evil, Revisited</title>
<link>https://blog.codinghorror.com/is-doevents-evil-revisited/</link>
<content>
                <!--kg-card-begin: markdown--><p>
A colleague of mine had some excellent comments on the surprising reentrancy issues you'll run into when using <b>Application.DoEvents()</b>:
</p>
<p>
</p>
<blockquote>
<i>The Application.DoEvents method is often used to allow applications to repaint while some longer task is taking place. This is usually the result of polling instead of using events / delegates. That's fine, but developers need to understand <b>DoEvents processes all of the messages in the message queue, not just paint messages</b>. This can lead to unexpected reentrancy issues. A simple example is shown below.</i>
<p>
</p>
<pre language="c#">
// some data we care about
private int _count;
// the click handler for a button
private void buttonUserAction_Click(object sender, System.EventArgs e)
{
_count++;
// _count won't always be 1; it depends how many times
// this method was reentered during the DoEvents calls
Console.WriteLine(_count);
// simulate longer tasks that we are polling the status on.
// call DoEvents to allows the window to repaint
for (int i=0; i &lt; 100000; i++)
Application.DoEvents();
_count--;
}
</pre>
<p>
<i>In this example, it doesn't matter if the method is reentered. But it might in other methods or applications. Always remember that DoEvents can cause methods to be reentered. And understand which methods are affected: any method that is called directly or indirectly in response to processing messages in the message queue.
</i></p>
<p>
It would be useful if the Form object had a Busy property; the form would only process paint related messages and skip input related messages like menus, clicks, keyboard, etc.</p>
</blockquote>
<p>
I put together a <a href="http://www.codinghorror.com/blog/files/IsDoEventsEvil_Source.zip">VS.NET 2003 winforms solution</a> (6kb) demonstrating the code sample above.
</p>
<p>
This may make you wonder: <a href="http://www.codinghorror.com/blog/archives/000159.html">Is DoEvents Evil?</a>
</p>
<p>
I think it's definitely the <i>lesser</i> of two evils: it's either this simplified cooperative yielding or <a href="http://www.codinghorror.com/blog/archives/000169.html">full-bore multithreaded code</a>. DoEvents can be a big win with minimal effort in the right situations. For example, how about using it to <a href="http://www.codinghorror.com/blog/archives/000177.html">improve perceived form load performance?</a>
</p>
<p>
</p>
<p></p>
<!--kg-card-end: markdown-->
            </content>
<pubDate>2005-08-22T12:00:00.000Z</pubDate>
<guid>https://blog.codinghorror.com/is-doevents-evil-revisited/</guid>
</item>
</channel>
</rss>
