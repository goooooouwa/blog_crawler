<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0">
<channel>
<title>Coding Horror</title>
<description>programming and human factors</description>
<link>https://blog.codinghorror.com/</link>
<pubDate>Sun, 19 Apr 2020 00:00:01 GMT</pubDate>
<!-- other elements omitted from this example -->
<item>
<title>Shuffling</title>
<link>https://blog.codinghorror.com/shuffling/</link>
<content>
                <!--kg-card-begin: markdown--><p>Pop quiz, hotshot. <strong>How would you write code to shuffle a deck of cards?</strong></p>
<p><img class="at-xid-6a0120a85dcdae970b012877702239970c" src="https://blog.codinghorror.com/content/images/uploads/2007/12/6a0120a85dcdae970b012877702239970c-pi.jpg" border="0" alt="a complete deck of 52 cards, arranged by suit and in ascending order" width="650" height="319"></p>
<p>I was thinking about this after reading <a href="http://www.mikepope.com/blog/AddComment.aspx?blogid=1851">Mike's card-shuffling algorithm woes</a>:</p>
<blockquote>Here's where the non-CS mind comes into play. My first thought was to generate an unshuffled deck as an array-like structure -- all cards in order by suit. Then I'd create a second array-like structure. I'd walk through each card in the unshuffled deck, pick a random number, and insert the card at the randomly selected spot in the second array. If the randomly chosen position in the second array was already occupied, I'd choose another random number, see if it was used, and so on until the random selection happened to land on a free spot. I'll call this the Random Insert approach.</blockquote>
<p>It seemed an odd approach to me, but unlike Mike, I have the dubious benefit of a programming background. I went immediately for my old friend, the loop. Let's assume we have an array with 52 members representing the 52 cards in the deck.</p>
<pre>var rand = new Random();
for (int i = cards.Length - 1; i &gt; 0; i--)
{
int n = rand.Next(i + 1);
int temp = cards[i];
cards[i] = cards[n];
cards[n] = temp;
}
</pre>
<p>So we loop through the deck, switching each card with another card from a random position in the deck. Seems straightforward enough, although I do wish there was a built in Swap command in the C# language to simplify the code a bit. It's eerily similar to <a href="http://en.wikipedia.org/wiki/Knuth_shuffle">the Knuth or Fisher-Yates shuffle</a>, which doesn't mean I'm particularly smart, but that shuffling is an easily solved problem.</p>
<p>Or is it? This <em>looks</em> correct; there's nothing obviously wrong here. But <strong>there are two problems with this code</strong>. Can you see them?</p>
<p>The first problem is right here:</p>
<pre>new Random();
</pre>
<p><a href="http://www.codinghorror.com/blog/archives/000728.html">Computers are lousy random number generators</a>. <strong>Any shuffling you do, whatever the algorithm, will only be as good as your random number generator.</strong> So if you're running, say, an online casino, you need to be <a href="http://en.wikipedia.org/wiki/Knuth_shuffle#Potential_sources_of_bias">very careful</a> when you start throwing around the word "Random" in your code. If you aren't careful, <a href="http://www.ibm.com/developerworks/library/s-playing/">there will be.. problems</a>.</p>
<blockquote>The flaw exists in the card shuffling algorithm used to generate each deck. Ironically, the code was publicly displayed at www.planetpoker.com/ppfaq.htm with the idea of showing how fair the game is to interested players (the relevant question has since been removed). In the code, a call to randomize() is included to produce a random deck before each deck is generated. The implementation, built with Delphi 4 (a Pascal IDE), seeds the random number generator with the number of milliseconds since midnight according to the system clock. That means the output of the random number generator is easily predicted. A predictable "random number generator" is a very serious security problem.
<p>By synchronizing our clock with the clock on the online casino and hitting the "shuffle" button, our program can calculate the exact shuffle. That means we know all the cards that have yet to appear, everyone's hand, and who will win. The screen shot below shows the information displayed by our program in realtime during an actual game. Our program knows what cards are to appear <em>in advance</em>, before they are revealed by the online game.</p>
</blockquote>
<p>To be fair, this was 1999. I'd assume most online casinos have hired competent cryptographers and statisticians by now. With the ever looming specter of <a href="http://freakonomics.blogs.nytimes.com/2007/09/20/how-not-to-cheat/">insider cheating</a> and <a href="http://www.codinghorror.com/blog/archives/000374.html">poker bots</a>, they'd be fools not to.</p>
<p>The second problem with this code is that <strong>it's too complicated</strong>. Eric <a href="http://www.codinghorror.com/blog/archives/000750.html">"purplicious"</a> Lippert explains why, in his own inimitable way:</p>
<blockquote>The standard way of implementing this algorithm is: associate each card with a random real number between 0.0 and 1.0. Sort the list based on its associated number. That's O(n log n) and has no bias.</blockquote>
<p>As it turns out, <a href="http://www.secureprogramming.com/?action=view&amp;feature=recipes&amp;recipeid=23">the easiest way to implement a shuffle is by sorting</a>. It's not exactly <em>faster</em>, as <a href="http://www.codinghorror.com/blog/archives/000957.html">the typical sort</a> is O(n log n) compared to the O(n) of the Knuth Fisher-Yates shuffle algorithm. We'll just sort by a random number-- in this case, a <a href="http://en.wikipedia.org/wiki/Globally_Unique_Identifier">GUID</a>.</p>
<pre>var cards = Enumerable.Range(0, 51);
var shuffledcards = cards.OrderBy(a =&gt; Guid.NewGuid());
</pre>
<p>So we can ultimately implement a secure, unbiased shuffle as a one-liner in a modern programming language.</p>
<p>Which proves.. well, nothing, I suppose, but like so many other programming problems, there are a lot of ways to get shuffling wrong if you're not careful.</p>
<!--kg-card-end: markdown-->
            </content>
<pubDate>2007-12-03T12:00:00.000Z</pubDate>
<guid>https://blog.codinghorror.com/shuffling/</guid>
</item>
</channel>
</rss>
