<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0">
<channel>
<title>Coding Horror</title>
<description>programming and human factors</description>
<link>https://blog.codinghorror.com/</link>
<pubDate>Sun, 19 Apr 2020 00:00:01 GMT</pubDate>
<!-- other elements omitted from this example -->
<item>
<title>The bloated world of Managed Code</title>
<link>https://blog.codinghorror.com/the-bloated-world-of-managed-code/</link>
<content>
                <!--kg-card-begin: markdown--><p>
Mark Russinovich recently posted a blog entry bemoaning the <a href="http://www.sysinternals.com/blog/2005/04/coming-net-world-im-scared.html">bloated footprint of managed .NET apps</a> compared to their unmanaged equivalents. He starts by comparing a trivial managed implemention of Notepad to the one that ships with Windows:
</p>
<p>
</p>
<blockquote><i>
First notice the total CPU time consumed by each process. Remember, all I've done is launch the programs Ã¢â‚¬â€œ I haven't interacted with either one of them. The managed Notepad has taken twice the CPU time as the native one to start. Granted, a tenth of a second isn't large in absolute terms, but it represents 200 million cycles on the 2 GHz processor that they are running on. Next notice the memory consumption, which is really where the managed code problem is apparent. The managed Notepad has consumed close to 8 MB of private virtual memory (memory that can't be shared with other processes) whereas the native version has used less than 1 MB. That's a 10x difference! And the peak working set, which is the maximum amount of physical memory Windows has assigned a process, is almost 9 MB for the managed version and 3 MB for the unmanaged version, close to a 3x difference.
</i></blockquote>
<p>
While Mark has more coding skill in his pinky finger than I have in my entire body, I think his comparison is misleading at best and specious at worst. He clarifies his position in a <a href="http://www.sysinternals.com/blog/2005/04/net-world-follow-up.html">subsequent post</a>:
</p>
<blockquote>
<i>
Memory footprint is much more important for a client-side-only application since there can be many such applications running concurrently and clients often have limited memory. Someone stated that by the time that Longhorn ships most new systems will have 1 to 2 GB of memory. In corporate environments clients have at least 3-year life cycles and home users even in prosperous nations might upgrade less often. In developing nations you'll see system configurations lagging the mainstream by 5 years. That means that most of the world's computers won't have 1-2 GB of memory until several years after Longhorn finally ships.
</i><p>
It's amazing to me that no matter how much memory we add, how much faster we make our CPUs, and how much faster we make our disks spin and seek, computing doesn't seem to get faster. If you have a Windows NT 4 system around compare its boot time and common tasks with that of a Windows XP system. Then compare their system specs. Then ask yourself what you really can do on the Windows XP system that you can't do on the Windows NT 4 system.
</p>
</blockquote>
<p>
I'm not sure why this trend is currently bothering Mark so much, because it's been going on for decades. The subset of tasks that <i>must</i> be done in (insert favorite low-level language here) for acceptable performance gets smaller and smaller every day as hardware improves over time. This is a perfectly reasonable tradeoff to make; <b>computers get faster every day, but our brains don't</b>.  The goal of the .NET runtime is not to squeeze every drop of performance out of the platform-- it's to make software development easier. A talented developer could write several managed .NET apps in the same time it would take to write one unmanaged C++ app. Would you rather have a <a href="http://www.grc.com/smgassembly.htm">single fast native app</a>, or a dozen slower managed apps to choose from?
</p>
<p>
Mark's article did get me thinking about the inherent overhead of .NET. <b>What is the real minimum footprint of a .NET application?</b>
</p>
<p>
First, I started a new <b>Console C# project</b> in VS.NET, then added a single Console.WriteLine and a Console.ReadLine. I compiled in release mode, closed the IDE, and double-clicked on the release executable. I then used <a href="http://www.codinghorror.com/blog/archives/000162.html">Mark's Process Exporer</a> to view the process properties:
</p>
<p>
</p>
<table>
<tr>
<td></td>
<td><b>.NET 1.1</b></td>
<td><b>.NET 2.0 b2</b></td>
<td>
<b>.NET 2.0 final</b>
</td>
</tr>
<tr>
<td>Private Bytes</td>
<td>3,912 K</td>
<td>6,984 K</td>
<td>7,076 K
</td>
</tr>
<tr>
<td>Working Set</td>
<td>5,800 K</td>
<td>3,792 K</td>
<td>3,872 K
</td>
</tr>
<tr>
<td>Page Faults</td>
<td>1,484</td>
<td>963</td>
<td>989
</td>
</tr>
<tr>
<td>Handles</td>
<td>67</td>
<td>65</td>
<td>67
</td>
</tr>
<tr>
<td>GDI Handles</td>
<td>11</td>
<td>5</td>
<td>5
</td>
</tr>
<tr>
<td>USER Handles</td>
<td>2</td>
<td>0</td>
<td>0
</td>
</tr>
</table>
<p>
Next, I started a new <b>Windows Forms C# project</b> in VS.NET, then added a single close Button and a label. I compiled in release mode, closed the IDE, and double-clicked on the release executable. I again used process explorer to view the process properties:
</p>
<p>
</p>
<table>
<tr>
<td></td>
<td><b>.NET 1.1</b></td>
<td><b>.NET 2.0 b2</b></td>
<td>
<b>.NET 2.0 final</b>
</td>
</tr>
<tr>
<td>Private Bytes</td>
<td>5,760 K</td>
<td>11,432 K</td>
<td>11,684 K
</td>
</tr>
<tr>
<td>Working Set</td>
<td>7,876 K</td>
<td>7,280 K</td>
<td>7,072 K
</td>
</tr>
<tr>
<td>Page Faults</td>
<td>2,140</td>
<td>1,876</td>
<td>1,817
</td>
</tr>
<tr>
<td>Handles</td>
<td>72</td>
<td>84</td>
<td>76
</td>
</tr>
<tr>
<td>GDI Handles</td>
<td>34</td>
<td>23</td>
<td>25
</td>
</tr>
<tr>
<td>USER Handles</td>
<td>15</td>
<td>18</td>
<td>12
</td>
</tr>
</table>
<p>
(Updated with .NET 2.0 final numbers on 1-12-06. I generated these numbers in a clean Windows XP VM, so they should be accurate.)
</p>
<p>
The .NET 2.0 beta results were generated on a different machine via Remote Desktop, but I don't think that should affect memory and handles. Maybe it's my VB background talking, but <b>these baseline footprints seem totally reasonable to me</b>, particularly considering the incredible productivity I get in exchange.
</p>
<p>
</p>
<p></p>
<!--kg-card-end: markdown-->
            </content>
<pubDate>2005-04-21T12:00:00.000Z</pubDate>
<guid>https://blog.codinghorror.com/the-bloated-world-of-managed-code/</guid>
</item>
</channel>
</rss>
