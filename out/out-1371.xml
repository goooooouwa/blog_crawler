<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0">
<channel>
<title>Coding Horror</title>
<description>programming and human factors</description>
<link>https://blog.codinghorror.com/</link>
<pubDate>Sun, 19 Apr 2020 00:00:01 GMT</pubDate>
<!-- other elements omitted from this example -->
<item>
<title>Why aren't my optimizations optimizing?</title>
<link>https://blog.codinghorror.com/why-arent-my-optimizations-optimizing/</link>
<content>
                <!--kg-card-begin: markdown--><p>
</p>
<blockquote>
<i>
"We should forget about small efficiencies, say about 97% of the time: premature optimization is the root of all evil."
</i>- <a href="http://en.wikipedia.org/wiki/Knuth">Donald Knuth</a>
</blockquote>
Michael Teper's blog has a <a href="http://michaelteper.com/archive/2004/06/14/173.aspx">great post about a bread and butter optimization scenario involving string replacement</a>. After implementing three logical alternatives, Mike looks at the benchmark runs and asks,
<blockquote><i>
Why aren't my optimizations optimizing?
</i></blockquote>
Optimizing code is a tricky business. I would have tried the exact same things-- probably in the same order. Many times approaches I just assume will be "faster" turn out not to be. That's why I tell developers, <b>always measure performance</b>. Never assume anything will be faster or slower until you've actually measured it to be so-- you'll be surprised how often your assumptions are wrong. Unfortunately, <b>sometimes the way you measure performance can even be flawed.</b> That's what revealed Mike's third optimization, was, in fact, <a href="http://michaelteper.com/archive/2004/06/14/174.aspx">an optimization</a>:
<p>
</p>
<blockquote><i>
it turns out that Replace is only fast when the input string does not contain the string (or character) that is intended for replacement. When the string does contain it, the performance of CleanString class drops, and, as expected, the character array exhibits better perf.
</i></blockquote>
<p>
If you must optimize, make sure you're benchmarking valid test cases, with a reasonable set of test data, to ensure that you actually have an improvement. And before "improving" anything, take the optimization rules of  <a href="http://cisx2.uma.maine.edu/NickTemp/JSP&amp;JSDLec/jsd.html">M.A. Jackson</a> to heart:
</p>
<blockquote>
Rules of Optimization:<br>
<br>
Rule 1: Don't do it.<br>
Rule 2 (for experts only): Don't do it yet.
</blockquote>
<p>
And I would add a third: don't optimize work that doesn't have to be done. Don't get me wrong, performance is <a href="http://www.useit.com/papers/responsetime.html">incredibly important</a>...
</p>
<blockquote><i>
The basic advice regarding response times has been about the same for almost thirty years [Miller 1968; Card et al. 1991]:
<ul>
<li>
<b>0.1 second</b> is about the limit for having the user feel that the system is reacting instantaneously, meaning that no special feedback is necessary except to display the result.
</li>
<li>
<b>1 second</b> is about the limit for the user's flow of thought to stay uninterrupted, even though the user will notice the delay. Normally, no special feedback is necessary during delays of more than 0.1 but less than 1.0 second, but the user does lose the feeling of operating directly on the data.
</li>
<li>
<b>10 seconds</b> is about the limit for keeping the user's attention focused on the dialogue. For longer delays, users will want to perform other tasks while waiting for the computer to finish, so they should be given feedback indicating when the computer expects to be done. Feedback during the delay is especially important if the response time is likely to be highly variable, since users will then not know what to expect.
</li>
</ul></i></blockquote>
... but so is having a functioning, stable system. It's up to you to decide how to balance that. For more, there's an excellent treatment of this topic in chapter 9 of <a href="http://www.amazon.com/exec/obidos/ASIN/0201657880/codihorr-20">Programming Pearls</a>, and <a href="http://blogs.msdn.com/ricom/">Microsoft Performance Blogger Rico</a> is a fun (and .NET specific) read as well.
<p>
</p>
<p></p>
<!--kg-card-end: markdown-->
            </content>
<pubDate>2004-08-24T12:00:00.000Z</pubDate>
<guid>https://blog.codinghorror.com/why-arent-my-optimizations-optimizing/</guid>
</item>
</channel>
</rss>
